---
title: "Host traits determining worm LH,  multivariate"
output: 
  github_document:
    toc: true
    df_print: kable
---

Worm parasites have different life cycles - some infect more hosts in succession, others fewer. Lengthening the life cycle (more consecutive hosts) is costly because it increases the chances of not being transmitted to the next host and it delays reproduction. Do long cycles have other advantages? In other notebooks, we examined the relationship between [life cycle length and adult worm life history](../lcl_adult_worm_traits/adult_worm_traits_vs_lcl.Rmd) and how [host trais vary across life cycles](../kinds_of_hosts/host_traits_across_clc.Rmd). In this notebook, we examine how host traits affect parasite life history traits.

```{r setup, include=FALSE}
library(tidyverse)
library(MCMCglmm)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
options(stringsAsFactors = FALSE)
theme_set(new = theme_bw())
```
```{r}
dat <- read.csv(file = "../../data/stage_level_combined_noimputed.csv", header = T)
dat <- mutate(dat, Host_no_fac = factor(Host_no_fac),
              obs = factor(1:length(Parasite.species)))%>%
  mutate(stage_lcl = paste0("lc", lcl_max_fac, "_", Host_no_fac),
         is_paratenic = if_else(Facultative == "paratenic", 1, 0))%>%
  mutate(log_end = log(biovolume), log_start = log(initial_biov), 
         log_dt = log(avg_dt), log_dd = log(avg_dd))%>%
  mutate(rg = log_end - log_start, rgr = (log_end - log_start)/avg_dt)%>%
  mutate(rgr_doubles = (log(biovolume, base = 2) - log(initial_biov, base = 2))/avg_dt)%>%
  mutate(doubling_time = 1/rgr_doubles
         # doubling_time2 = log(2)/rgr # different way to calculate doubling time
         )%>%
  mutate(host_bm = log(10^(host_bm)))
```

We'll examine 3 parasite traits: initial size, final size, and development time. Together, they determine how long and how fast parasites grow. Fast growth is advantageous, so we are looking for the host traits that favor large size and short devo time. We'll examine each of these simultaneously in a multivariate model.

# Relative growth rate - multivariate

The three parasite traits combine to determine how fast parasites grow. Let's put them into a multivariate model to see how growth rate varies with host traits. This is better than explicitly modeling growth rate, because it accounts for variability in each variable when calculating the composite variable growth rate. We fit the multivariate models with `MCMCglmm`. We also include 'empty' data in the model, so that it will return predictions for parasite traits, holding either host mass or trophic level constant.

```{r}
# first filter to just data including fixed predictors
dxy <- filter(dat, !(is.na(avg_dt) & is.na(biovolume) & is.na(initial_biov)))
dxy <- filter(dat, Facultative != 'postcyclic',
              !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
dxy$pred <- 'no'

# then make data that want marginal predicions for
dx_avg <- group_by(dxy, endo_ecto)%>%
  summarize(min_bm = min(host_bm, na.rm = T),
            max_bm = max(host_bm, na.rm = T),
            min_tl = min(host_tl, na.rm = T),
            max_tl = max(host_tl, na.rm = T))

nd_bm <- bind_rows( data.frame(endo_ecto = 'ecto',
                            host_bm = seq(dx_avg$min_bm[1], dx_avg$max_bm[1], length.out = 50),
                            host_tl = median(dxy$host_tl, na.rm = T),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy$parasite_genus)[1],
                            parasite_family = unique(dxy$parasite_family)[1],
                            parasite_order = unique(dxy$parasite_order)[1],
                            parasite_class = unique(dxy$parasite_class)[1],
                            parasite_phylum = unique(dxy$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo',
                            host_bm = seq(dx_avg$min_bm[2], dx_avg$max_bm[2], length.out = 50),
                            host_tl = median(dxy$host_tl, na.rm = T),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy$parasite_genus)[1],
                            parasite_family = unique(dxy$parasite_family)[1],
                            parasite_order = unique(dxy$parasite_order)[1],
                            parasite_class = unique(dxy$parasite_class)[1],
                            parasite_phylum = unique(dxy$parasite_phylum)[1])
                 )


nd_tl <- bind_rows( data.frame(endo_ecto = 'ecto',
                            host_bm = median(dxy$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[1], dx_avg$max_tl[1], length.out = 50),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy$parasite_genus)[1],
                            parasite_family = unique(dxy$parasite_family)[1],
                            parasite_order = unique(dxy$parasite_order)[1],
                            parasite_class = unique(dxy$parasite_class)[1],
                            parasite_phylum = unique(dxy$parasite_phylum)[1]),
                 data.frame(endo_ecto = 'endo',
                            host_bm = median(dxy$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[2], dx_avg$max_tl[2], length.out = 50),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy$parasite_genus)[1],
                            parasite_family = unique(dxy$parasite_family)[1],
                            parasite_order = unique(dxy$parasite_order)[1],
                            parasite_class = unique(dxy$parasite_class)[1],
                            parasite_phylum = unique(dxy$parasite_phylum)[1])
                 )
nd_bm$pred <- 'yes, bm'
nd_tl$pred <- 'yes, tl'

dxy <- bind_rows(dxy, nd_bm, nd_tl)

# observations with at least 1 wk devo on average; better estimate of growth rate?
obs_for_rg <- dxy%>%
  filter(avg_dt>6)%>%
  .$obs

dxy2 <- filter(dxy, obs %in% obs_for_rg | pred != "no")
```

As for model structure, we allow the residuals to be correlated. For example, if a worm stage has a large final size relative to its host, it probably started large or developed longer, i.e. positive residual correlations. Parasite taxonomy is treated as nested random effects. We fit the same series of models as in univariate analyses: (i) intercept only, (ii) host trait main effects, (iii) host trait interactions (2nd order). 

Here are the sample sizes for each trait included in the model.

```{r}
filter(dxy, pred == "no")%>%
  # group_by(Parasite.species)%>%
  summarize(n_dt = sum(!is.na(avg_dt)),
            n_end_size = sum(!is.na(biovolume)),
            n_ini_size = sum(!is.na(initial_biov)))
```

It is worth noting that a good portion of those missing devo times are paratenic stages. Here are paratenic stages with and without devo times.

```{r}
filter(dat, Facultative == "paratenic")%>%
  mutate(devo_missing = is.na(avg_dt))%>%
  group_by(devo_missing)%>%
  summarize(n = n())
```

```{r}
prior <- list(R = list(V = diag(3)/6, n = 2),
              G = list(G1 = list(V = diag(3)/6, n = 2),
                       G2 = list(V = diag(3)/6, n = 2),
                       G3 = list(V = diag(3)/6, n = 2),                       
                       G4 = list(V = diag(3)/6, n = 2),
                       G5 = list(V = diag(3)/6, n = 2),
                       G6 = list(V = diag(3)/6, n = 2)
                        )
               )
startc <- list(G = list(G1 = diag(3)/6,
                        G2 = diag(3)/6,
                        G3 = diag(3)/6,
                        G4 = diag(3)/6,
                        G5 = diag(3)/6,
                        G6 = diag(3)/6),
              R = diag(3)/6
              )
```
```{r}
nit <- 30500
# int-only model
chains0 <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1, 
                        random = ~ idh(trait):Parasite.species +
                          idh(trait):parasite_genus +
                          idh(trait):parasite_family + 
                          idh(trait):parasite_order + 
                          idh(trait):parasite_class + 
                          idh(trait):parasite_phylum, # taxonomic tree as random effect
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        nitt = nit, thin = 30, burnin = 500,
                        data = dxy,
                        family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                        verbose = F)
# model with host traits, main effx
chains1 <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                            trait:host_bm + trait:host_tl + trait:endo_ecto, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          nitt = nit, thin = 30, burnin = 500,
                          data = dxy,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
# model with all host trait 2nd order interactions
chains2 <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                             trait:host_bm + trait:host_tl + trait:endo_ecto +
                             trait:host_bm:host_tl + trait:host_bm:endo_ecto + trait:host_tl:endo_ecto, 
                        random = ~ idh(trait):Parasite.species +
                          idh(trait):parasite_genus +
                          idh(trait):parasite_family + 
                          idh(trait):parasite_order + 
                          idh(trait):parasite_class + 
                          idh(trait):parasite_phylum, # taxonomic tree as random effect
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        prior = prior,
                        start = startc,
                    nitt = nit, thin = 30, burnin = 500,
                        data = dxy,
                        family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                        verbose = F)
# model for looking at growth, excluding stages with very short devo times
chains2rg <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                            trait:host_bm + trait:host_tl + trait:endo_ecto +
                             trait:host_bm:host_tl + trait:host_bm:endo_ecto + trait:host_tl:endo_ecto, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                      nitt = nit, thin = 30, burnin = 500,
                          data = dxy2,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
```

Here is a comparison of the three models. Adding host traits (red) is better than an intercept-only model (black). Adding host trait interactions (green) is slight further improvement.

```{r}
plot(mcmc.list(chains0$Deviance, chains1$Deviance, chains2$Deviance), density = F)
```

Here are the DIC values for the models.

```{r}
cat("DIC, int-only:", chains0$DIC )
```
```{r}
cat("DIC, host traits (main);", chains1$DIC )
```
```{r}
cat("DIC, host traits (int);", chains2$DIC )
```

Here is the delta DIC for adding the host traits...

```{r}
cat('Delta DIC, int-only vs host traits:', 
    chains0$DIC - chains1$DIC, '(higher is better)')
```

...and the host trait interactions, an improvement.

```{r}
cat('Delta DIC, host trait main vs host trait interactions:', 
    chains1$DIC - chains2$DIC, '(higher is better)')
```

```{r}
# with log-log regression, we need to interpret this coefficient with regards to proportional change. A change in 1 log unit corresponds to a exp(1) or 2.72-fold increase in host mass. We can express this with more intuitive percents. Here is the predicted percent increase in the odds of infection with a 100% (log(2)) increase in worm size.

lcl_effect <- exp(chains1$Sol[,'traitlog_end:host_bm'] * log(2)) - 1 # beta x "log of fold change corresponding to 100% incr in host mass"
```

Here is the predicted increase in final worm size with host mass. A doubling of host mass results in a `r round(mean(lcl_effect), 2)*100`% increase in parasite size. This was was much larger than...

```{r}
summary(lcl_effect)
```
```{r}
lcl_effect <- exp(chains1$Sol[,'traitlog_start:host_bm'] * log(2)) - 1
```

...the increase in initial worm size with host mass, which was `r round(mean(lcl_effect), 2)*100`%.

```{r}
summary(lcl_effect)
```

```{r}
lcl_effect <- exp(chains1$Sol[,'traitlog_dt:host_bm'] * log(2)) - 1
```

Development time increased with host mass as well. This slope is not comparable to the parasite size slopes, since devo time had a more limited range than size. Devo time increased `r round(mean(lcl_effect), 2)*100`% with a 100% increase in host mass.

```{r}
summary(lcl_effect)
```

Initial worm size increased more than 10-fold with each unit increase in host trophic level.

```{r}
lcl_effect <- exp(chains1$Sol[,'traitlog_start:host_tl'])
summary(lcl_effect)
```

```{r}
lcl_effect <- exp(chains1$Sol[,'traitlog_end:endo_ectoendo'])
```

Here is the effect of endothermy on worm final size. Final size was ~`r round(mean(lcl_effect), 0)` fold higher in an endotherm. To properly interpret this, though, host mass and trophic level would need to be standardized.

```{r}
summary(lcl_effect)
```

Here are the model parameters and credible intervals for host trait main effx model...

```{r}
s <- data.frame(quant = summary(chains1$Sol)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

...and the model including host trait interactions...

```{r}
s <- data.frame(quant = summary(chains2$Sol)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

Here are the parameters for the host traits interaction model, but excluding stages with devo times less than a week.

```{r}
s <- data.frame(quant = summary(chains2rg$Sol)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

Here's the R^2^ for these models.

```{r}
# function to return R2 from models
r2_multiv <- function(m){
  
  sol <- m$Sol # fix param
  vcv <- m$VCV # vc
  X <- m$X # design matrix
  num_fe <- m$Fixed$nfl # fixed effects
  l <- dim(X)[1]/3 # number of data points in model


  # calculate fixed effects var
  p_all <- as.matrix(X) %*% t(sol[,1:num_fe]) # predicteds for every post sample
  p1 <- p_all[1:l,] # preds for start size
  p2 <- p_all[(l+1):(l*2),] # preds for end size
  p3 <- p_all[(l*2 + 1):(l*3),] # preds for dt
  
  f1 <- apply(p1, MARGIN = 2, FUN = var)
  f2 <- apply(p2, MARGIN = 2, FUN = var)
  f3 <- apply(p3, MARGIN = 2, FUN = var)

  
  # random effects var
  resi <- which(grepl(colnames(vcv), pattern = '.units')) # remove resid variance from variance components
  randVar <- vcv[,-resi]
  ran1 <- randVar[, grepl(colnames(randVar), pattern = 'traitlog_start.')] # RE for start size
  ran1 <- rowSums(ran1)
  ran2 <- randVar[, grepl(colnames(randVar), pattern = 'traitlog_end.')] # RE for start size
  ran2 <- rowSums(ran2)
  ran3 <- randVar[, grepl(colnames(randVar), pattern = 'traitlog_dt.')] # RE for devo time
  ran3 <- rowSums(ran3)
  
  
  # resid var
  res1 <- vcv[, "traitlog_start:traitlog_start.units"]
  res2 <- vcv[, "traitlog_end:traitlog_end.units"]
  res3 <- vcv[, "traitlog_dt:traitlog_dt.units"]
  
  # calculate R2 marginal
  r2m1 <- f1/(f1 + ran1 + res1)
  r2m2 <- f2/(f2 + ran2 + res2)
  r2m3 <- f3/(f3 + ran3 + res3)
  # for output...
  r2m1 <- paste0(round(median(r2m1),3), ' [', 
         round(quantile(r2m1, probs = 0.025), 3), '-', 
         round(quantile(r2m1, probs = 0.975), 3), ']')
  r2m2 <- paste0(round(median(r2m2),3), ' [', 
         round(quantile(r2m2, probs = 0.025), 3), '-', 
         round(quantile(r2m2, probs = 0.975), 3), ']')
  r2m3 <- paste0(round(median(r2m3),3), ' [', 
         round(quantile(r2m3, probs = 0.025), 3), '-', 
         round(quantile(r2m3, probs = 0.975), 3), ']')
  
  # calculate R2 conditional
  r2c1 <- (f1 + ran1)/(f1 + ran1 + res1)
  r2c2 <- (f2 + ran2)/(f2 + ran2 + res2)
  r2c3 <- (f3 + ran3)/(f3 + ran3 + res3)
  r2c1 <- paste0(round(median(r2c1),3), ' [', 
         round(quantile(r2c1, probs = 0.025), 3), '-', 
         round(quantile(r2c1, probs = 0.975), 3), ']')
  r2c2 <- paste0(round(median(r2c2),3), ' [', 
         round(quantile(r2c2, probs = 0.025), 3), '-', 
         round(quantile(r2c2, probs = 0.975), 3), ']')
  r2c3 <- paste0(round(median(r2c3),3), ' [', 
         round(quantile(r2c3, probs = 0.025), 3), '-', 
         round(quantile(r2c3, probs = 0.975), 3), ']')
  

  out_d <- data.frame(trait = c('start_size', 'end_size', 'dt'),
                      r2m = c(r2m1, r2m2, r2m3),
                      r2c = c(r2c1, r2c2, r2c3))
  return(out_d)
}
```

The addition of host trait interactions only explain a few additional percentage points of the variation in worm sizes. It appears more important for parasite development.

```{r}
m1 <- r2_multiv(chains0)
m2 <- r2_multiv(chains1)
m3 <- r2_multiv(chains2)

m1$model <- 'int-only'
m2$model <- 'host traits, main effects'
m3$model <- 'host traits, second-order interactions'

r2_table <- bind_rows(m1, m2, m3)%>%
  arrange(trait)%>%
  select(model, trait, r2m, r2c)
r2_table
```

The residual covariances in the multivariate model are non-zero. Here is the correlation matrix for the residuals:

```{r}
# residual covarianc matrix
x <- posterior.mode(posterior.cor(chains2$VCV[,19:27]))
x <- round(matrix(x, nrow =3), 3)
x
summary(posterior.cor(chains2$VCV[,19:27]))
```

Start and end size are positively correlated as are devo time and end size. Start size and devo time are negatively correlated. These correlations are consistent with classic LH tradeoffs. Growing to a large size requires time, but entering hosts as a large larvae reduces the time needed to develop.

For all traits, there was substantial taxonomic variation. Let's look at the breakdown of taxonomic effects, after accounting for host traits. Here is the plot for initial size...

```{r}
# initial size
resi <- which( grepl(colnames(chains2$VCV), pattern = ".units")) # res var-cov
st_re <- which( grepl(colnames(chains2$VCV), pattern = "traitlog_start")) # var comp for ini size
st_re <- st_re[!st_re %in% resi] # just tax var comp
st_re <- c(st_re, 
           which(grepl(colnames(chains2$VCV), 
                       pattern = "traitlog_start:traitlog_start.units"))) # tax vc + resid vc

tax_eff_st <- rbind(
  quantile(chains2$VCV[,"traitlog_start.Parasite.species"]/
      rowSums(chains2$VCV[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_start.parasite_genus"]/
             rowSums(chains2$VCV[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_start.parasite_family"]/
             rowSums(chains2$VCV[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_start.parasite_order"]/
             rowSums(chains2$VCV[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_start.parasite_class"]/
             rowSums(chains2$VCV[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_start.parasite_phylum"]/
             rowSums(chains2$VCV[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(rowSums(chains2$VCV[,st_re[1:6]])/
             rowSums(chains2$VCV[,st_re]), probs = c(0.025, 0.5, 0.975))
)
tax_eff_st <- data.frame(tax_eff_st)
names(tax_eff_st) <- c('vc.lwr', 'vc.fit', 'vc.upr')
tax_eff_st$t_level <- factor(c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'),
                          levels = c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'))

ggplot(tax_eff_st, aes(x = t_level, y = vc.fit)) +
  geom_pointrange(aes(ymin = vc.lwr, ymax = vc.upr)) +
  labs(x = NULL, y = 'Taxonomic effect on initial size', 
       title = 'Prop. variance explained after accounting for host traits' ) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

...final size...

```{r}
# final size
resi <- which( grepl(colnames(chains2$VCV), pattern = ".units")) # res var-cov
fs_re <- which( grepl(colnames(chains2$VCV), pattern = "traitlog_end")) # var comp for final size
fs_re <- fs_re[!fs_re %in% resi] # just tax var comp
fs_re <- c(fs_re, 
           which(grepl(colnames(chains2$VCV), 
                       pattern = "traitlog_end:traitlog_end.units"))) # tax vc + resid vc

tax_eff_fs <- rbind(
  quantile(chains2$VCV[,"traitlog_end.Parasite.species"]/
      rowSums(chains2$VCV[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_end.parasite_genus"]/
             rowSums(chains2$VCV[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_end.parasite_family"]/
             rowSums(chains2$VCV[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_end.parasite_order"]/
             rowSums(chains2$VCV[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_end.parasite_class"]/
             rowSums(chains2$VCV[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_end.parasite_phylum"]/
             rowSums(chains2$VCV[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(rowSums(chains2$VCV[,fs_re[1:6]])/
             rowSums(chains2$VCV[,fs_re]), probs = c(0.025, 0.5, 0.975))
)
tax_eff_fs <- data.frame(tax_eff_fs)
names(tax_eff_fs) <- c('vc.lwr', 'vc.fit', 'vc.upr')
tax_eff_fs$t_level <- factor(c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'),
                          levels = c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'))

ggplot(tax_eff_fs, aes(x = t_level, y = vc.fit)) +
  geom_pointrange(aes(ymin = vc.lwr, ymax = vc.upr)) +
  labs(x = NULL, y = 'Taxonomic effect on final size', 
       title = 'Prop. variance explained after accounting for host traits' ) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

...and development time.

```{r}
# devo time
resi <- which( grepl(colnames(chains2$VCV), pattern = ".units")) # res var-cov
dt_re <- which( grepl(colnames(chains2$VCV), pattern = "traitlog_dt")) # var comp for dt
dt_re <- dt_re[!dt_re %in% resi] # just tax var comp
dt_re <- c(dt_re, 
           which(grepl(colnames(chains2$VCV), 
                       pattern = "traitlog_dt:traitlog_dt.units"))) # tax vc + resid vc

tax_eff_dt <- rbind(
  quantile(chains2$VCV[,"traitlog_dt.Parasite.species"]/
      rowSums(chains2$VCV[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_dt.parasite_genus"]/
             rowSums(chains2$VCV[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_dt.parasite_family"]/
             rowSums(chains2$VCV[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_dt.parasite_order"]/
             rowSums(chains2$VCV[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_dt.parasite_class"]/
             rowSums(chains2$VCV[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(chains2$VCV[,"traitlog_dt.parasite_phylum"]/
             rowSums(chains2$VCV[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(rowSums(chains2$VCV[,dt_re[1:6]])/
             rowSums(chains2$VCV[,dt_re]), probs = c(0.025, 0.5, 0.975))
)
tax_eff_dt <- data.frame(tax_eff_dt)
names(tax_eff_dt) <- c('vc.lwr', 'vc.fit', 'vc.upr')
tax_eff_dt$t_level <- factor(c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'),
                          levels = c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'))

ggplot(tax_eff_dt, aes(x = t_level, y = vc.fit)) +
  geom_pointrange(aes(ymin = vc.lwr, ymax = vc.upr)) +
  labs(x = NULL, y = 'Taxonomic effect on devo time', 
       title = 'Prop. variance explained after accounting for host traits' ) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

For size variables, there is both a phyla effect (nematodes are smaller) and a order/family effect. Devo time seems to differ more among higher taxonomic groups.


## Multivariate vs univariate model predictions

We also fit the univariate models with `MCMCglmm` for comparison.

```{r}
# univariate models
# parameter expanded priors for tax effects, not used
# priorP <- list(R=list(V=1, nu=0.002),
#                G=list(G1=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#                       G2=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#                       G3=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#                       G4=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#                       G5=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000)))
# model with correlated residuals
model.uni1.1is <- MCMCglmm(log_start ~ host_bm + host_tl + endo_ecto +
                             host_bm:host_tl + host_bm:endo_ecto + host_tl:endo_ecto,
                        random = ~Parasite.species + parasite_genus + parasite_family +
                         parasite_order + parasite_class + parasite_phylum, # taxonomic tree as random effect
                        nitt = nit, thin = 30, burnin = 500,
                        data = dxy,
                        family = "gaussian", pr=F, 
                        verbose = F)

model.uni1.1fs <- MCMCglmm(log_end ~ host_bm + host_tl + endo_ecto +
                             host_bm:host_tl + host_bm:endo_ecto + host_tl:endo_ecto, 
                        random = ~Parasite.species + parasite_genus + parasite_family +
                         parasite_order + parasite_class + parasite_phylum, # taxonomic tree as random effect
                        nitt = nit, thin = 30, burnin = 500,
                        data = dxy,
                        family = "gaussian", pr=F, 
                        verbose = F)

model.uni1.1dt <- MCMCglmm(log_dt ~ host_bm + host_tl + endo_ecto +
                             host_bm:host_tl + host_bm:endo_ecto + host_tl:endo_ecto, 
                        random = ~Parasite.species +parasite_genus + parasite_family +
                         parasite_order + parasite_class + parasite_phylum, # taxonomic tree as random effect
                        nitt = nit, thin = 30, burnin = 500,
                        data = dxy,
                        family = "gaussian", pr=F, 
                        verbose = F)
```

I get marginal predicted values from the multivariate and univariate models.

```{r}
# predicted values, correlated res
p <- predict(chains2, 
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ idh(trait):Parasite.species +
               idh(trait):parasite_genus +
               idh(trait):parasite_family + 
               idh(trait):parasite_order + 
               idh(trait):parasite_class + 
               idh(trait):parasite_phylum
             )
p1 <- data.frame(log_start_p = p[1:length(dxy$pred),])
p2 <- data.frame(log_end_p = p[(length(dxy$pred)+1):(length(dxy$pred)*2),])
p3 <- data.frame(log_dt_p = p[(length(dxy$pred)*2 + 1):(length(dxy$pred)*3),])

p <- bind_cols(dxy, p1, p2, p3)
p <- filter(p, pred != 'no')
```
```{r}
# predicted values univariate
puni_is <- predict(model.uni1.1is, 
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ Parasite.species + parasite_genus + parasite_family + parasite_order + parasite_class + parasite_phylum
             )

puni_fs <- predict(model.uni1.1fs, 
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ Parasite.species + parasite_genus + parasite_family + parasite_order + parasite_class + parasite_phylum
             )

puni_dt <- predict(model.uni1.1dt, 
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ Parasite.species + parasite_genus + parasite_family + parasite_order + parasite_class + parasite_phylum
             )

puni <- bind_cols(dxy, 
                  data.frame(log_start_p = puni_is),
                  data.frame(log_end_p = puni_fs),
                  data.frame(log_dt_p = puni_dt))
puni <- filter(puni, pred != 'no')
```
```{r}
p$rescor <- 'multivariate\ncorr resid'
puni$rescor <- 'univariate, mcmc'

pc <- bind_rows(p, puni)
pc <- pc%>%
  select(pred, host_bm, host_tl, endo_ecto, rescor, log_start_p.fit:log_dt_p.upr)%>%
  mutate(rgr.fit = (log_end_p.fit - log_start_p.fit)/(exp(log_dt_p.fit)), # growth rate calculated from means
         rgr.upr = (log_end_p.upr - log_start_p.upr)/(exp(log_dt_p.upr)),
         rgr.lwr = (log_end_p.lwr - log_start_p.lwr)/(exp(log_dt_p.lwr))
         )
```

Let's compare the predictions for univariate and multivariate models, starting with final size. The increase with host mass and endothermy is essentially the same in both models. However, the CI might be a bit wider for the univariate model. 

```{r}
ggplot(filter(pc, pred == 'yes, bm'),
       aes(x = host_bm, y = log_end_p.fit, color = rescor, fill = rescor)) +
  geom_line(size = 1.5) +
  geom_ribbon(aes(ymin = log_end_p.lwr, ymax = log_end_p.upr),
              alpha = 0.5, color = NA) +
  facet_wrap(~endo_ecto) +
  labs(x = 'Log host mass', y = 'Log final size', fill = 'Endothermy', color = 'Endothermy')
```

For initial size, the CI was again narrower for the multivariate model.

```{r}
ggplot(filter(pc, pred == 'yes, bm'),
       aes(x = host_bm, y = log_start_p.fit, color = rescor, fill = rescor)) +
  geom_line(size = 1.5) +
  geom_ribbon(aes(ymin = log_start_p.lwr, ymax = log_start_p.upr),
              alpha = 0.5, color = NA) +
  facet_wrap(~endo_ecto) +
  labs(x = 'Log host mass', y = 'Log initial size', fill = 'Endothermy', color = 'Endothermy')
```

This was not the case for devo time. Interestingly, the devo time relationship appears slightly different in the multivariate model. Uni- and multi-variate models probably diverge most for devo time, because it was the trait with the most missing data.

```{r}
ggplot(filter(pc, pred == 'yes, bm'),
       aes(x = host_bm, y = log_dt_p.fit, color = rescor, fill = rescor)) +
  geom_line(size = 1.5) +
  geom_ribbon(aes(ymin = log_dt_p.lwr, ymax = log_dt_p.upr),
              alpha = 0.5, color = NA) +
  facet_wrap(~endo_ecto) +
  labs(x = 'Log host mass', y = 'Log devo time', fill = 'Endothermy', color = 'Endothermy')
```

This is even clearer when we look at devo time as a function of host trophic level.

```{r}
ggplot(filter(pc, pred == 'yes, tl'),
       aes(x = host_tl, y = log_dt_p.fit, color = rescor, fill = rescor)) +
  geom_line(size = 1.5) +
  geom_ribbon(aes(ymin = log_dt_p.lwr, ymax = log_dt_p.upr),
              alpha = 0.5, color = NA) +
  facet_wrap(~endo_ecto) +
  labs(x = 'Log host tl', y = 'Log devo time', fill = 'Endothermy', color = 'Endothermy')
```

An advantage of multivariate models is that we can use the posterior distribution to calculate composite traits like growth rate. This is preferable to calculating growth rate from the means of the univariate models, because it accounts for variation in all parameters simultaneously. 

```{r}
pdx <- chains2$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(chains2$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth rate from every iteration
p_allrg <- 
  ( p_all[(p_n+1):(p_n*2),] - # end size
     p_all[1:p_n,] ) / # start size
  (exp(p_all[(p_n*2 + 1):(p_n*3),])) # devo time

# predicted means for every iteration for every trait
px <- data.frame(filter(dxy, pred != "no")%>%
                   select(pred, host_bm, host_tl, endo_ecto),
                 log_start_p = p_all[1:p_n,],
                 log_end_p = p_all[(p_n+1):(p_n*2),],
                 log_dt_p = p_all[(p_n*2 + 1):(p_n*3),],
                 rgr = p_allrg)

# reshape predicted vals for all iter, calc fit and quantiles
p_all <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, host_bm, host_tl, endo_ecto, trait)%>%
  summarise(fit = median(mod_pred),
            upr = quantile(mod_pred, probs = 0.025),
            lwr = quantile(mod_pred, probs = 0.975))

rm(px,pdx, n, nt, p_i, p_n, num_fe, p_allrg)
```
```{r}
p_all <- p_all%>%
  pivot_wider(names_from = trait, values_from = fit:lwr)%>%
  ungroup()
names(p_all) <- c("pred","host_bm","host_tl","endo_ecto",
                  "log_dt_p.fit", "log_end_p.fit", "log_start_p.fit", "rgr.fit",
                  "log_dt_p.upr", "log_end_p.upr", "log_start_p.upr", "rgr.upr",
                  "log_dt_p.lwr", "log_end_p.lwr", "log_start_p.lwr", "rgr.lwr")

p_all$rescor <- 'multivariate\nparam'

pc <- bind_rows(pc, p_all)
```

So let's look at growth rates. The next plot shows predicted growth rates calculated two ways, either by using the full posterior distribution of all parameters or just the means given by the univariate models. It is clear that the CI is much wider when we account for variation in all the parameters simultaneously.

```{r}
ggplot(filter(pc, pred == 'yes, bm', rescor != 'univariate, mcmc'),
       aes(x = host_bm, y = rgr.fit, color = rescor, fill = rescor)) +
  geom_line(size = 1.5) +
  geom_ribbon(aes(ymin = rgr.lwr, ymax = rgr.upr),
              alpha = 0.5, color = NA) +
  facet_wrap(~endo_ecto) +
  labs(x = 'Log host mass', y = 'Relative growth rate', fill = 'Model', color = 'Model')
```

Here's the same plot, but with growth rate as a function of host trophic level.

```{r}
ggplot(filter(pc, pred == 'yes, tl', rescor != 'univariate, mcmc'),
       aes(x = host_tl, y = rgr.fit, color = rescor, fill = rescor)) +
  geom_line(size = 1.5) +
  geom_ribbon(aes(ymin = rgr.lwr, ymax = rgr.upr),
              alpha = 0.5, color = NA) +
  facet_wrap(~endo_ecto) +
  labs(x = 'Host trophic level', y = 'Relative growth rate', fill = 'Model', color = 'Model')
```


# Panels for Fig 3

Let's now make some plots using the predictions and credible intervals from the model including host trait interactions.

```{r}
# full host trait model
pdx <- chains2$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(chains2$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate derived traits (not modeled) like relative growth and relative growth rate from every iteration
p_allrg <- 
  ( p_all[(p_n+1):(p_n*2),] - # end size
     p_all[1:p_n,] ) # start size
p_allrgr <- 
  ( p_all[(p_n+1):(p_n*2),] - # end size
     p_all[1:p_n,] ) / # start size
  ( exp(p_all[(p_n*2 + 1):(p_n*3),])) # devo time



# calculate relative growth rate excluding short devo times
pdx <- chains2rg$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy2$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n2 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2rg$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all2 <- as.matrix(pdx) %*% t(chains2rg$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx


p_allrg2 <- 
  ( p_all2[(p_n2+1):(p_n2*2),] - # end size
     p_all2[1:p_n2,] ) / # start size
  ( exp(p_all2[(p_n2*2 + 1):(p_n2*3),])) # devo time


# predicted means for every iteration for every trait
px <- data.frame(filter(dxy, pred != "no")%>%
                   select(pred, host_bm, host_tl, endo_ecto),
                 log_start_p = p_all[1:p_n,],
                 log_end_p = p_all[(p_n+1):(p_n*2),],
                 log_dt_p = p_all[(p_n*2 + 1):(p_n*3),],
                 log_dt_overaweek = p_all2[(p_n2*2 + 1):(p_n2*3),],
                 rg = p_allrg,
                 rgr = p_allrgr,
                 rgr_overaweek = p_allrg2)

# reshape predicted vals for all iter, calc fit and quantiles
p_all <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, host_bm, host_tl, endo_ecto, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

p_all$group <- 'group'
rm(px,pdx, n, nt, p_i, p_n, num_fe, p_allrg, p_allrgr, p_allrg2)
```

The points in each plot are observed values. First final size...

```{r}
f2a <- ggplot(dxy,
              aes(x = exp(host_bm), y = biovolume, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(biovolume))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "log_end_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "log_end_p"),
            aes(x = exp(host_bm), y = exp(fit),
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', 
       y = bquote("Final worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(a)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max(dxy$biovolume, na.rm = T))
f2a
# ggsave(f2a, filename = "../../figs/fig2a.png", width = 4, height = 3)
```



```{r}
f2b <- ggplot(dxy,
              aes(x = host_tl, y = biovolume, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(biovolume))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "log_end_p"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "log_end_p"),
            aes(x = host_tl, y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', 
       y = bquote("Final worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(b)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max(dxy$biovolume, na.rm = T))

f2b
```

...then initial size.

```{r}
f2c <- ggplot(dxy,
              aes(x = exp(host_bm), y = initial_biov, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "log_start_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "log_start_p"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', 
       y = bquote("Initial worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(c)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max(dxy$initial_biov, na.rm = T))
f2c
```

```{r}
f2d <- ggplot(dxy,
              aes(x = host_tl, y = initial_biov, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "log_start_p"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "log_start_p"),
            aes(x = host_tl, y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', 
       y = bquote("Initial worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(d)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max(dxy$initial_biov, na.rm = T))
f2d
```

Instead of plotting final and initial size separately, we could plot relative growth, i.e. the difference between final and initial size. It increases with host mass.

```{r}
f2c_rg <- ggplot(dxy,
              aes(x = exp(host_bm), y = exp(log(biovolume) - log(initial_biov)), color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "rg"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "rg"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', 
       y = "Relative growth\n(fold increase in size)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(c)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max( exp(dxy$log_end - dxy$log_start), na.rm = T))
f2c_rg
```

and decreases with trophic level.

```{r}
f2d_rg <- ggplot(dxy,
              aes(x = host_tl, y = exp(log(biovolume) - log(initial_biov)), color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "rg"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "rg"),
            aes(x = host_tl, y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', 
       y = "Relative growth\n(fold increase in size)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(d)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max( exp(dxy$log_end - dxy$log_start), na.rm = T))
f2d_rg
```

Here's how relative growth changed with host size. This is relative growth in a 1 mg host...

```{r}
# 1 mg
filter(p_all, pred == "yes, bm", trait == "rg", endo_ecto == "ecto")%>%
  mutate(diff_from_wanted = abs(host_bm-log(1/1000)))%>%
  arrange(diff_from_wanted)%>%
  ungroup()%>%slice(1)%>%
  select(rg_1mg = fit, rg_1mg_upr = upr, rg_1mg_lwr = lwr)%>%
  mutate(fold_change = exp(rg_1mg), fold_change_lwr = exp(rg_1mg_lwr), fold_change_upr = exp(rg_1mg_upr))
```

...a 1 g host...

```{r}
# 1 g
filter(p_all, pred == "yes, bm", trait == "rg", endo_ecto == "ecto")%>%
  mutate(diff_from_wanted = abs(host_bm-log(1)))%>%
  arrange(diff_from_wanted)%>%
  ungroup()%>%slice(1)%>%
  select(rg_1g = fit, rg_1g_upr = upr, rg_1g_lwr = lwr)%>%
  mutate(fold_change = exp(rg_1g), fold_change_lwr = exp(rg_1g_lwr), fold_change_upr = exp(rg_1g_upr))
```

...and a 10 kg host.

```{r}
# 10 kg
filter(p_all, pred == "yes, bm", trait == "rg", endo_ecto == "ecto")%>%
  mutate(diff_from_wanted = abs(host_bm-log(10*1000)))%>%
  arrange(diff_from_wanted)%>%
  ungroup()%>%slice(1)%>%
  select(rg_10kg = fit, rg_10kg_upr = upr, rg_10kg_lwr = lwr)%>%
  mutate(fold_change = exp(rg_10kg), fold_change_lwr = exp(rg_10kg_lwr), fold_change_upr = exp(rg_10kg_upr))
```

And here is the relative growth difference between an average sized (10 g) endotherm and ectotherm.

```{r}
# 10 g host
filter(p_all, between(host_tl, 2.799, 2.805), trait == "rg")%>%
  mutate(diff_from_wanted = abs(host_bm - log(10)))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, rg_10g = fit, rg_10g_lwr = lwr, rg_10g_upr = upr)%>%
  mutate(fold_change = exp(rg_10g), fold_change_lwr = exp(rg_10g_lwr), fold_change_upr = exp(rg_10g_upr))
```


Moving onto development time, the solid and dashed lines represent trends including or excluding short devo times (< 1 week).

```{r}
f2e <- ggplot(dxy,
              aes(x = exp(host_bm), y = avg_dt, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "log_dt_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "log_dt_p"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "log_dt_overaweek"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            linetype = "dashed", size = 1.5) +
  # geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "log_dt_overaweek"),
  #           aes(x = exp(host_bm), y = exp(fit), 
  #               color = endo_ecto, fill = endo_ecto,
  #               ymin = exp(lwr), ymax = exp(upr)),
  #             alpha = 0.2, color = NA) +
  scale_y_log10() + 
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', y = 'Development time (days)') +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(e)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max(dxy$avg_dt, na.rm = T))
f2e
```

```{r}
f2f <- ggplot(dxy,
              aes(x = host_tl, y = avg_dt, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "log_dt_p"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "log_dt_p"),
            aes(x = host_tl, y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "log_dt_overaweek"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            linetype = "dashed", size = 1.5) +
  scale_y_log10() + 
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', y = 'Development time (days)') +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(f)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max(dxy$avg_dt, na.rm = T))

f2f
```

Growth rate is only plotted for species that spent at least 1 week developing.

```{r}
f2g <- ggplot(filter(dxy, avg_dt>6),
              aes(x = exp(host_bm), y = (log_end-log_start)/avg_dt, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume)|is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "rgr_overaweek"),
            aes(x = exp(host_bm), y = fit, color = endo_ecto),
            linetype = "dashed", size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "rgr_overaweek"),
            aes(x = exp(host_bm), y = fit, 
                color = endo_ecto, fill = endo_ecto,
                ymin = lwr, ymax = upr),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', 
       y = "Relative growth rate\n(~% size increase per day)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(g)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max(filter(dxy, avg_dt>6)$rgr, na.rm = T))
f2g
```

Growth varies little with trophic level. 

```{r}
f2h <- ggplot(filter(dxy, avg_dt>6),
              aes(x = host_tl, y = (log_end-log_start)/avg_dt, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume)|is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "rgr"),
            aes(x = host_tl, y = fit, color = endo_ecto),
            linetype = "dashed", size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "rgr"),
            aes(x = host_tl, y = fit, 
                color = endo_ecto, fill = endo_ecto,
                ymin = lwr, ymax = upr),
              alpha = 0.2, color = NA) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', 
       y = "Relative growth rate\n(~% size increase per day)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(h)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max(filter(dxy, avg_dt>6)$rgr, na.rm = T) )
f2h
```

Worms grow slightly faster in endotherms than ectotherms. Here is the difference for an average sized host (10 g).

```{r}
# 10 g host
filter(p_all, between(host_tl, 2.799, 2.805), trait == "rgr_overaweek")%>%
  mutate(diff_from_wanted = abs(host_bm - log(10)))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(rgr_10g = fit, rgr_10g_upr = upr, rgr_10g_lwr = lwr)
```

We combined these plots into a single figure.
```{r}
library(cowplot)
```
```{r}
f2a2 <- f2a + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        legend.position = 'none')
f2c2 <- f2c + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        legend.position = c(0.05,0.9),
        legend.justification = c(0,1),
        legend.text = element_text(face = 'bold', size = 10),
        legend.background = element_rect(color = 'black'))
f2e2 <- f2e + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        legend.position = 'none')
f2g2 <- f2g + 
  theme(legend.position = 'none')

f2b2 <- f2b + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        legend.position = 'none')
f2d2 <- f2d + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        legend.position = 'none')
f2f2 <- f2f + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        legend.position = 'none')
f2h2 <- f2h + 
  theme(axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        legend.position = 'none')


f2 <- cowplot::plot_grid(f2a2, f2b2, f2c2, f2d2, f2e2, f2f2, f2g2, f2h2,
          # labels = 'auto', hjust = -3, label_fontface = 'plain',
          align = 'hv', ncol = 2)
f2dd <- plot_grid(f2e2, f2f2, f2g2, f2h2,
                  align = 'hv', ncol = 2)
rm(f2a2, f2b2, f2c2, f2d2, f2e2, f2f2, f2g2, f2h2)
```
```{r}
title <- ggdraw() +
  draw_label("Not Imputed",
    fontface = 'bold',
    size = 20
  ) 

f2gif <- plot_grid(title, 
                   f2,
                   ncol = 1, 
                   rel_heights = c(0.1, 1))
```
```{r}
title <- ggdraw() +
  draw_label("Not imputed, days",
    fontface = 'bold',
    size = 20
  ) 

f2dd <- plot_grid(title, 
                   f2dd,
                   ncol = 1, 
                   rel_heights = c(0.1, 1))
```
```{r}
ggsave(f2, filename = "../../figs/fig3_noimp.png", width = 8, height = 12)
ggsave(f2, filename = "../../figs/fig3_noimp.svg", width = 8, height = 12)
# move plots closer together, fix legend pos
ggsave(f2gif, filename = "../../figs/gif_imp_vs_noimp/fig3_noimp.png", width = 8, height = 12)
ggsave(f2dd, filename = "../../figs/gif_dd_vs_nodd/fig3_noimp.png", width = 8, height = 6)
rm(f2gif, f2dd)
```

# Host trait effects driven by intermediate vs definitive host distinction?

Since definitive hosts are mostly endotherms and intermediate hosts are mostly ectotherms, it is possible that growth differences are exaggerated by limited growth in some intermediate hosts, e.g. in paratenic hosts.  To check this, we re-fit the model with the distinction between intermediate vs definitive host, as well as its interactions with the other host traits.

```{r}
# first filter to just data including fixed predictors
dxy_dh <- filter(dat, !(is.na(avg_dt) & is.na(biovolume) & is.na(initial_biov)))
dxy_dh <- filter(dat, Facultative != 'postcyclic',
              !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
dxy_dh$pred <- 'no'

# then make data that want marginal predicions for
dx_avg <- group_by(dxy_dh, endo_ecto, Def.int)%>%
  summarize(min_bm = min(host_bm, na.rm = T),
            max_bm = max(host_bm, na.rm = T),
            min_tl = min(host_tl, na.rm = T),
            max_tl = max(host_tl, na.rm = T))

nd_bm <- bind_rows( data.frame(endo_ecto = 'ecto', Def.int = "def",
                            host_bm = seq(dx_avg$min_bm[1], dx_avg$max_bm[1], length.out = 50),
                            host_tl = median(dxy_dh$host_tl, na.rm = T),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'ecto', Def.int = "int",
                            host_bm = seq(dx_avg$min_bm[2], dx_avg$max_bm[2], length.out = 50),
                            host_tl = median(dxy_dh$host_tl, na.rm = T),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo', Def.int = "def",
                            host_bm = seq(dx_avg$min_bm[3], dx_avg$max_bm[3], length.out = 50),
                            host_tl = median(dxy_dh$host_tl, na.rm = T),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo', Def.int = "int",
                            host_bm = seq(dx_avg$min_bm[4], dx_avg$max_bm[4], length.out = 50),
                            host_tl = median(dxy_dh$host_tl, na.rm = T),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1])
                 )

nd_tl <- bind_rows( data.frame(endo_ecto = 'ecto', Def.int = "def",
                            host_bm = median(dxy_dh$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[1], dx_avg$max_tl[1], length.out = 50),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'ecto', Def.int = "int",
                            host_bm = median(dxy_dh$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[2], dx_avg$max_tl[2], length.out = 50),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo', Def.int = "def",
                            host_bm = median(dxy_dh$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[3], dx_avg$max_tl[3], length.out = 50),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo', Def.int = "int",
                            host_bm = median(dxy_dh$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[4], dx_avg$max_tl[4], length.out = 50),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1])
                 )

nd_bm$pred <- 'yes, bm'
nd_tl$pred <- 'yes, tl'

dxy_dh <- bind_rows(dxy_dh, nd_bm, nd_tl)

# observations with at least 1 wk devo on average; better estimate of growth rate?
obs_for_rg <- dxy_dh%>%
  filter(avg_dt>6)%>%
  .$obs

dxy_dh2 <- filter(dxy_dh, obs %in% obs_for_rg | pred != "no")
```

```{r}
# model with all host trait 2nd order interactions, but just definitive hosts
chains2_dh <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                             trait:host_bm + trait:host_tl + trait:endo_ecto + trait:Def.int +
                             trait:host_bm:host_tl + trait:host_bm:endo_ecto + trait:host_tl:endo_ecto +
                               trait:host_bm:Def.int + trait:endo_ecto:Def.int + trait:host_tl:Def.int +
                         trait:host_bm:endo_ecto:Def.int + trait:host_tl:endo_ecto:Def.int, 
                        random = ~ idh(trait):Parasite.species +
                          idh(trait):parasite_genus +
                          idh(trait):parasite_family + 
                          idh(trait):parasite_order + 
                          idh(trait):parasite_class + 
                          idh(trait):parasite_phylum, # taxonomic tree as random effect
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        prior = prior,
                        start = startc,
                        nitt = nit, thin = 30, burnin = 500,
                        data = dxy_dh,
                        family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                        verbose = F)
# model with all host trait 2nd order interactions, but just definitive hosts
chains2_dhrg <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                             trait:host_bm + trait:host_tl + trait:endo_ecto + trait:Def.int +
                             trait:host_bm:host_tl + trait:host_bm:endo_ecto + trait:host_tl:endo_ecto +
                           trait:host_bm:Def.int + trait:endo_ecto:Def.int + trait:host_tl:Def.int +
                           trait:host_bm:endo_ecto:Def.int + trait:host_tl:endo_ecto:Def.int, 
                        random = ~ idh(trait):Parasite.species +
                          idh(trait):parasite_genus +
                          idh(trait):parasite_family + 
                          idh(trait):parasite_order + 
                          idh(trait):parasite_class + 
                          idh(trait):parasite_phylum, # taxonomic tree as random effect
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        prior = prior,
                        start = startc,
                        nitt = nit, thin = 30, burnin = 500,
                        data = dxy_dh2,
                        family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                        verbose = F)
```

The resulting model did not explain much more variation in final size, but it did account for some additional variation in start size and devo time. This fits with what we know about stages - i.e. worms grow less in some stages than we might expect given host size.

```{r}
m1 <- r2_multiv(chains2)
m2 <- r2_multiv(chains2_dh)

m1$model <- 'host traits, second-order interactions'
m2$model <- 'host traits + def vs int interactions'

r2_table <- bind_rows(m1, m2)%>%
  arrange(trait)%>%
  select(model, trait, r2m, r2c)
r2_table
```

What about the predictions for growth in definitive hosts?

```{r}
# full host trait model
pdx <- chains2_dh$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy_dh$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2_dh$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all_dh <- as.matrix(pdx) %*% t(chains2_dh$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate derived traits (not modeled) like relative growth and relative growth rate from every iteration
p_allrg <- 
  ( p_all_dh[(p_n+1):(p_n*2),] - # end size
     p_all_dh[1:p_n,] ) # start size
p_allrgr <- 
  ( p_all_dh[(p_n+1):(p_n*2),] - # end size
     p_all_dh[1:p_n,] ) / # start size
  ( exp(p_all_dh[(p_n*2 + 1):(p_n*3),])) # devo time


# calculate relative growth rate excluding short devo times
pdx <- chains2_dhrg$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy_dh2$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n2 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2_dhrg$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all2 <- as.matrix(pdx) %*% t(chains2_dhrg$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx


p_allrg2 <- 
  ( p_all2[(p_n2+1):(p_n2*2),] - # end size
     p_all2[1:p_n2,] ) / # start size
  ( exp(p_all2[(p_n2*2 + 1):(p_n2*3),])) # devo time


# predicted means for every iteration for every trait
px <- data.frame(filter(dxy_dh, pred != "no")%>%
                   select(pred, host_bm, host_tl, Def.int, endo_ecto),
                 log_start_p = p_all_dh[1:p_n,],
                 log_end_p = p_all_dh[(p_n+1):(p_n*2),],
                 log_dt_p = p_all_dh[(p_n*2 + 1):(p_n*3),],
                 log_dt_overaweek = p_all2[(p_n2*2 + 1):(p_n2*3),],
                 rg = p_allrg,
                 rgr = p_allrgr,
                 rgr_overaweek = p_allrg2)

# reshape predicted vals for all iter, calc fit and quantiles
p_all_dh <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, host_bm, host_tl, endo_ecto, Def.int, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

p_all_dh$group <- 'group'
rm(px,pdx, n, nt, p_i, p_n, num_fe, p_allrg, p_allrgr, p_allrg2)
```

Here is the predicted growth in endo vs ectotherm for an average sized definitive host. It is higher for endotherms, but the CIs are wide and nearly overlapping.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "def")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm", 
       Def.int == "def", trait == "rg")%>%
  mutate(diff_from_wanted = abs(host_bm - dx_dh$median_bm))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rg_avg = fit, rg_avg_lwr = lwr, rg_avg_upr = upr)%>%
  mutate(fold_change = exp(rg_avg), fold_change_lwr = exp(rg_avg_lwr), fold_change_upr = exp(rg_avg_upr))
```

```{r}
# the predicted means and actual means match nicely - taxonomic effects are not changing them much
# filter(dxy, pred == "no", Def.int == "def")%>%
#   group_by(endo_ecto)%>%
#   summarize(n = sum(!is.na(rg)), rg = median(rg, na.rm = T))
```

Here is the predicted relative growth in 10g intermediate host. We chose 10g because this is whether endotherm and ectotherm body sizes overlap; the average endotherm intermediate host is much bigger than the average ectotherm intermediate host. The CI for endotherms is very wide, because there were few endotherm intermediate hosts. Consequently, the CIs overlap and it is not clear that endothermy affects total growth in intermediate hosts.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "int")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm",
       Def.int == "int", trait == "rg")%>%
  mutate(diff_from_wanted = abs(host_bm - log(10)))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rg_avg = fit, rg_avg_lwr = lwr, rg_avg_upr = upr)%>%
  mutate(fold_change = exp(rg_avg), fold_change_lwr = exp(rg_avg_lwr), fold_change_upr = exp(rg_avg_upr))
```
Here is growth in an average-sized ectotherm intermediate host. The predicted growth was than in an average-sized ectotherm definitive host, though not significantly so.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "int", endo_ecto == "ecto")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm", endo_ecto == "ecto",
       Def.int == "int", trait == "rg")%>%
  mutate(diff_from_wanted = abs(host_bm - dx_dh$median_bm))%>%
  arrange(diff_from_wanted)%>%
  ungroup()%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rg_avg = fit, rg_avg_lwr = lwr, rg_avg_upr = upr)%>%
  mutate(fold_change = exp(rg_avg), fold_change_lwr = exp(rg_avg_lwr), fold_change_upr = exp(rg_avg_upr))
```

Growth *rates* are faster in endotherm definitive hosts.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "def")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm", 
       Def.int == "def", trait == "rgr_overaweek")%>%
  mutate(diff_from_wanted = abs(host_bm - dx_dh$median_bm))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rgr_avg = fit, rgr_avg_lwr = lwr, rgr_avg_upr = upr)
```
We can't make the same comparison in intermediate hosts, given the lack of data.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "int")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm",
       Def.int == "int", trait == "rgr_overaweek")%>%
  mutate(diff_from_wanted = abs(host_bm - log(10)))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rgr_avg = fit, rgr_avg_lwr = lwr, rgr_avg_upr = upr)
```

Let's plot the model output. Intermediate vs definitive hosts are distinguished by dotted and solid lines, respectively.

End size tends to be a bit larger in definitive hosts than comparable intermediate hosts, especially if they are endotherms.

```{r}
f2a_dh <- ggplot(dxy_dh,
              aes(x = exp(host_bm), y = biovolume, color = endo_ecto, linetype = Def.int)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(biovolume))
             ) + 
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_end_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_end_p"),
            aes(x = exp(host_bm), y = exp(fit),
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)', 
       y = bquote("Final worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2a_dh
```
Starting size is a little bit lower for endotherms than for ectotherms, but the difference is small.

```{r}
f2c_dh <- ggplot(dxy_dh,
              aes(x = exp(host_bm), y = initial_biov, color = endo_ecto, linetype = Def.int)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov))
             ) + 
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_start_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_start_p"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)', 
       y = bquote("Initial worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2c_dh
```
The combination of smaller initial sizes and larger final sizes indicates more growth in endothermic definitive hosts.

```{r}
f2c_rg_dh <- ggplot(dxy,
              aes(x = exp(host_bm), y = exp(log(biovolume) - log(initial_biov)), 
                  color = endo_ecto, linetype = Def.int)) +
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume))
             ) +
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "rg"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "rg"),
            aes(x = exp(host_bm), y = exp(fit),
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)',
       y = "Relative growth\n(fold increase in size)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2c_rg_dh
```
However, although they growth more in endotherm definitive hosts, the average prepatent period is shorter. The large CI for endotherm intermediate hosts reflects little data.

```{r}
f2e_dh <- ggplot(filter(dxy, avg_dt>6),
              aes(x = exp(host_bm), y = avg_dt, color = endo_ecto,
                  linetype = Def.int)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_dt_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_dt_p"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_y_log10() + 
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)', y = 'Devo time (days)') +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2e_dh
```
In endothermic definitive hosts, worms grow more in a shorter period, resulting in faster growth.

```{r}
f2g_dh <- ggplot(filter(dxy, avg_dt>6),
              aes(x = exp(host_bm), y = (log_end-log_start)/avg_dt, 
                  linetype = Def.int, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume)|is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "rgr_overaweek", 
                          !(Def.int == "int" & endo_ecto == "endo")),
            aes(x = exp(host_bm), y = fit, color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "rgr_overaweek",
                            !(Def.int == "int" & endo_ecto == "endo")),
            aes(x = exp(host_bm), y = fit, 
                color = endo_ecto, fill = endo_ecto,
                ymin = lwr, ymax = upr),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)', 
       y = "Relative growth rate\n(~% size increase per day)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2g_dh
```

Overall, adding a definitive vs intermediate host distinction does not change the results much. Worms still grow more in endotherm than ectotherm hosts. However, when we restrict the data to just definitive hosts and refit the model, then the estimated difference is much smaller (and marginally significant).

```{r}
library(lme4)
```
```{r}
l0 <- lmer(rg ~ host_bm_c + host_tl_c + host_bm_c:host_tl_c + (1|parasite_genus) + (1|parasite_family) +
             (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
           data = filter(dxy, Def.int == "def")%>%
             mutate(host_bm_c = host_bm - mean(dxy$host_bm, na.rm = T),
                    host_tl_c = host_tl - mean(dxy$host_tl, na.rm = T))
           )
l1 <- update(l0, . ~ . + endo_ecto)
# anova(l0,l1)
fe <- fixef(l1)
fe <- fe[c("(Intercept)","endo_ectoendo")]
fe<-c(fe[1], fe[1]+fe[2])

cat("Fold change, ecto vs endo def host:", round(exp(fe),0))

```
I think this is caused by larger taxonomic effects. When restricted to a single stage (def host), the model considers more of the differences to be taxonomic. That is, a taxon may not grow consistently more (or less) than expected from host size across the full life cycle. But when restricted to just one stage, more variation is considered taxonomic.

The differences between definitive and intermediate hosts are also part of the next modeling step: adding life stage to the model.

# Overachieving worms?

Now that we have estimated the relationship between host and parasite traits, we can ask whether certain parasite life stages grow faster or larger than expected. In particular, we are interested in the possibility that parasites with long cycles overperform at particular stages as a way to compensate. A quick way to test this is to add parasite stage into models with the host traits. Does stage account for additional variation beyond that accounted for by host traits? Let's do a few quick likelihood ratio tests with our "best" imputed datasets.

Stage explains additional variation in final size...

```{r}
library(lme4)
```

```{r}
modfs1.1 <- lmer(log_end ~ 1 + host_bm + host_tl + endo_ecto +
                 (host_bm + host_tl + endo_ecto)^2 +
                 (1|Parasite.species) + (1|parasite_genus) + (1|parasite_family) + 
                 (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
             data = filter(dxy, pred == "no"))
modfs3.1 <- update(modfs1.1, . ~ . + stage_lcl) # 2nd-order interaction effects
anova(modfs1.1, modfs3.1)
```

and initial size...

```{r}
modis1.1 <- lmer(log_start ~ 1 + host_bm + host_tl + endo_ecto +
                 (host_bm + host_tl + endo_ecto)^2 +
                 (1|Parasite.species) + (1|parasite_genus) + (1|parasite_family) + 
                 (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
             data = filter(dxy, pred == "no"))
modis3.1 <- update(modis1.1, . ~ . + stage_lcl) # 2nd-order interaction effects
anova(modis1.1, modis3.1)
```

and devo time (barely).

```{r}
moddt1.1 <- lmer(log_dt ~ 1 + host_bm + host_tl + endo_ecto +
                 (host_bm + host_tl + endo_ecto)^2 +
                 (1|Parasite.species) + (1|parasite_genus) + (1|parasite_family) + 
                 (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
             data = filter(dxy, pred == "no"))
moddt3.1 <- update(moddt1.1, . ~ . + stage_lcl) # 2nd-order interaction effects
anova(moddt1.1, moddt3.1)
```

So, parasite life stages seem to explain additional variation, even after accounting for host traits. Now let's again fit multivariate models and then we'll compare stage means predicted from just host traits or just stages, both adjusted for taxonomic effects. When the predictions diverge it suggests parasites grow more (or less) in particular stages than expected from their hosts.

I need to tweek the host-trait model compared to above. I want to get predicted values for each stage, and stages do not infect either endotherms or ectotherms. Rather, some proportion of species infect endotherms or ectotherms. Therefore, I replaced endothermy as a category with endothermy as a proportion in the model, so that I can predict stage means for a given level of endothermy. This does not change the number of model parameters.

```{r}
# Calculate cumulative devo time
dxyz <- mutate(dat, avg_dt_p = if_else(is_paratenic == 1, 3, avg_dt))
dxyz$pred <- 'no'
# spp where full dt not available, because partial life cycle
nspp <- dat%>%
  filter(Facultative != 'postcyclic', assumed_stage == "no",
         )%>%
  group_by(Parasite.species)%>%
  summarise(n = n(), lcl = max(lcl_max))%>%
  filter(n != lcl)%>%
  .$Parasite.species
nspp <- unique(nspp)

# id spp without complete dt data or paratenic stage
incomp_spp <- dxyz%>%
  filter(is.na(avg_dt_p), is_paratenic != 1)%>%
  select(Parasite.species)%>%
  .$Parasite.species
incomp_spp <- unique( incomp_spp )

# make sp level df with cum dt
dxyz <- dxyz%>%
  group_by(Parasite.species)%>%
  mutate(cum_dt = if_else(!Parasite.species %in% nspp & !Parasite.species %in% incomp_spp, cumsum(avg_dt_p), NA_real_))%>%
  mutate(log_cumdt = log(cum_dt))%>%
  ungroup()

# filter to just data including fixed predictors
dxyz <- filter(dxyz, !(is.na(avg_dt) & is.na(biovolume) & is.na(initial_biov))) # remove stages wo LH data
dxyz <- filter(dxyz, Facultative != 'postcyclic',
              !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))

# then make data that want marginal predicions for, first for just host traits
nd_stage <- group_by(dxyz, Host_no_fac, lcl_max_fac, stage_lcl)%>%
  summarize(host_bm = mean(host_bm, na.rm = T),
            host_tl = mean(host_tl, na.rm = T),
            prop_endo = sum(endo_ecto == 'endo')/sum(!is.na(endo_ecto)))
nd_stage$Parasite.species <- unique(dxy$Parasite.species)[1]
nd_stage$parasite_genus <- unique(dxy$parasite_genus)[1]
nd_stage$parasite_family <- unique(dxy$parasite_family)[1]
nd_stage$parasite_order <- unique(dxy$parasite_order)[1]
nd_stage$parasite_class <- unique(dxy$parasite_class)[1]
nd_stage$parasite_phylum <- unique(dxy$parasite_phylum)[1]

nd_stage$pred <- 'yes, host traits'

dxyy <- dxyz # make same df, but for stage-only model

dxyz <- bind_rows(dxyz, nd_stage)

nd_stage$pred <- 'yes, stage'

dxyy <- bind_rows(dxyy, nd_stage)

# restrict to observations where a week of growth
dxyz2 <- filter(dxyz, obs %in% obs_for_rg | pred != "no")
dxyy2 <- filter(dxyy, obs %in% obs_for_rg | pred != "no")

obs_for_cdt <- dxyz%>%
  filter(!is.na(cum_dt))%>%
  .$obs

dxyz3 <- filter(dxyz, obs %in% obs_for_cdt | pred != "no")
dxyy3 <- filter(dxyy, obs %in% obs_for_cdt | pred != "no")

dxyz <- as.data.frame(dxyz)
dxyy <- as.data.frame(dxyy)
dxyz2 <- as.data.frame(dxyz2)
dxyy2 <- as.data.frame(dxyy2)
dxyz3 <- as.data.frame(dxyz3)
dxyy3 <- as.data.frame(dxyy3)
```

I also fit the same models with cumulative development time instead of stage development time. When we summed mean developmental times across stages within a life cycle length (e.g. devo time in first host and devo time in second host), mean cumulative devo times were lower than the observed values. One reason for this is that we removed species with partial life cycles (e.g. 2 of 3 hosts known). Several of these species had imputed values for their paratenic stages, but not earlier ones, resulting in cumulative development being too low. Additionally, summing stage means underestimated total development time, because mean development times are negatively correlated across stages (i.e. if you grow a lot now, there is less need to grow later).

```{r}
# # cum devo time too low
# filter(dxy, pred == "no")%>%
#   select(Parasite.species, Host_no_fac, lcl_max_fac, avg_dt, avg_dt)%>%
#   mutate(removed = Parasite.species %in% nspp)%>%
#   group_by(Parasite.species)%>%
#   mutate(cum_dt = cumsum(avg_dt))%>%
#   ggplot(., aes(x = Host_no_fac, y = cum_dt, color = removed)) +
#   geom_boxplot(outlier.color = NA) +
#   geom_point(alpha = 0.2, position = position_jitterdodge(jitter.width = 0.3)) +
#   scale_y_log10() +
#   facet_grid(~lcl_max_fac, space = "free_x", scales = "free_x")
```

I fit both models with the same imputation approach as above: loop through imputed datasets, fit model, sample post dist, repeat with next imputed dataset.

```{r}
prior <- list(R = list(V = diag(3)/6, n = 2),
              G = list(G1 = list(V = diag(3)/6, n = 2),
                       G2 = list(V = diag(3)/6, n = 2),
                       G3 = list(V = diag(3)/6, n = 2),                       
                       G4 = list(V = diag(3)/6, n = 2),
                       G5 = list(V = diag(3)/6, n = 2),
                       G6 = list(V = diag(3)/6, n = 2)
                        )
               )
startc <- list(G = list(G1 = diag(3)/6,
                        G2 = diag(3)/6,
                        G3 = diag(3)/6,
                        G4 = diag(3)/6,
                        G5 = diag(3)/6,
                        G6 = diag(3)/6),
              R = diag(3)/6
              )
```
```{r}
# model with just host traits
chains3.0 <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                        trait:host_bm + trait:host_tl + trait:prop_endo +
                        trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo, 
                      random = ~ idh(trait):Parasite.species +
                        idh(trait):parasite_genus +
                        idh(trait):parasite_family + 
                        idh(trait):parasite_order + 
                        idh(trait):parasite_class + 
                        idh(trait):parasite_phylum, # taxonomic tree as random effect
                      rcov = ~us(trait):units, # residual var-covar unstructured
                      prior = prior,
                      start = startc,
                      nitt = nit, thin = 30, burnin = 500,
                      data = dxyz,
                      family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                      verbose = F)
# host traits model, but just with growing stages
chains3.0rg <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                          trait:host_bm + trait:host_tl + trait:prop_endo +
                          trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo, 
                        random = ~ idh(trait):Parasite.species +
                          idh(trait):parasite_genus +
                          idh(trait):parasite_family + 
                          idh(trait):parasite_order + 
                          idh(trait):parasite_class + 
                          idh(trait):parasite_phylum, # taxonomic tree as random effect
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        prior = prior,
                        start = startc,
                        nitt = nit, thin = 30, burnin = 500,
                        data = dxyz2,
                        family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                        verbose = F)
# model with just stage means
chains3.1 <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                        trait:stage_lcl, 
                      random = ~ idh(trait):Parasite.species +
                        idh(trait):parasite_genus +
                        idh(trait):parasite_family + 
                        idh(trait):parasite_order + 
                        idh(trait):parasite_class + 
                        idh(trait):parasite_phylum, # taxonomic tree as random effect
                      rcov = ~us(trait):units, # residual var-covar unstructured
                      prior = prior,
                      start = startc,
                      nitt = nit, thin = 30, burnin = 500,
                      data = dxyy,
                      family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                      verbose = F)
chains3.1rg <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                          trait:stage_lcl, 
                        random = ~ idh(trait):Parasite.species +
                          idh(trait):parasite_genus +
                          idh(trait):parasite_family + 
                          idh(trait):parasite_order + 
                          idh(trait):parasite_class + 
                          idh(trait):parasite_phylum, # taxonomic tree as random effect
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        prior = prior,
                        start = startc,
                        nitt = nit, thin = 30, burnin = 500,
                        data = dxyy2,
                        family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                        verbose = F)
# model with stage means and host traits
chains3.2 <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                        trait:host_bm + trait:host_tl + trait:prop_endo +
                        trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo +
                        trait:stage_lcl, 
                      random = ~ idh(trait):Parasite.species +
                        idh(trait):parasite_genus +
                        idh(trait):parasite_family + 
                        idh(trait):parasite_order + 
                        idh(trait):parasite_class + 
                        idh(trait):parasite_phylum, # taxonomic tree as random effect
                      rcov = ~us(trait):units, # residual var-covar unstructured
                      prior = prior,
                      start = startc,
                      nitt = nit, thin = 30, burnin = 500,
                      data = dxyz,
                      family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                      verbose = F)
# model with cum dt instead of dt, stages
chains4 <- MCMCglmm(cbind(log_start, log_end, log_cumdt) ~ trait-1 + 
                      trait:stage_lcl, 
                    random = ~ idh(trait):Parasite.species +
                      idh(trait):parasite_genus +
                      idh(trait):parasite_family + 
                      idh(trait):parasite_order + 
                      idh(trait):parasite_class + 
                      idh(trait):parasite_phylum, # taxonomic tree as random effect
                    rcov = ~us(trait):units, # residual var-covar unstructured
                    prior = prior,
                    start = startc,
                    nitt = nit, thin = 30, burnin = 500,
                    data = dxyy3,
                    family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                    verbose = F)
# model with cum dt instead of dt, host traits
chains4.1 <- MCMCglmm(cbind(log_start, log_end, log_cumdt) ~ trait-1 + 
                        trait:host_bm + trait:host_tl + trait:prop_endo +
                        trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo, 
                      random = ~ idh(trait):Parasite.species +
                        idh(trait):parasite_genus +
                        idh(trait):parasite_family + 
                        idh(trait):parasite_order + 
                        idh(trait):parasite_class + 
                        idh(trait):parasite_phylum, # taxonomic tree as random effect
                      rcov = ~us(trait):units, # residual var-covar unstructured
                      prior = prior,
                      start = startc,
                      nitt = nit, thin = 30, burnin = 500,
                      data = dxyz3,
                      family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                      verbose = F)
```

The deviance is lower for the life-stage model (red) compared to the host-traits model (black). Deviance goes down even further with both host traits and parasite stages in the model (green)

```{r}
plot(mcmc.list(chains3.0$Deviance, chains3.1$Deviance, chains3.2$Deviance), density = F)
```

Here are the DIC values of the three models:

```{r}
cat('Host traits only:', 
    chains3.0$DIC)
```
```{r}
cat('Stages only:', 
    chains3.1$DIC)
```
```{r}
cat('Host traits and stages:',
    chains3.2$DIC)
```

The stage model is clearly better than the host traits model.

```{r}
cat('Delta DIC, host traits only vs life stage only:', 
    chains3.0$DIC - chains3.1$DIC, '(higher is better)')
```

Both together is an even better model, suggesting that host traits explain variation within stages (e.g. worm size may covary with host size at a given stage).

```{r}
cat('Delta DIC, stage only vs stage and host traits:', 
    chains3.1$DIC - chains3.2$DIC, '(higher is better)')
```

Here are the model parameters and credible intervals for the stage-only model:

```{r}
s <- data.frame(quant = summary(chains3.1$Sol)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

Here is a comparison of final worm size in the definitive host...

```{r}
sx <- s[c("traitlog_end", "traitlog_end:stage_lcllc2_2", "traitlog_end:stage_lcllc3_3",  
          "traitlog_end:stage_lcllc3+_4"), "quant.50."]
sx <- data.frame(lcl = 1:4,
                 final_ws_avg = c(sx[1],
                                         sx[1]+sx[2],
                                         sx[1]+sx[3],
                                         sx[1]+sx[4]))
sx <- mutate(sx, prev_ws_avg = lag(final_ws_avg))%>%
  mutate(ord_mag_change = final_ws_avg - prev_ws_avg)%>%
  mutate(untransformed_mass = exp(final_ws_avg))%>%
  mutate(nh = lag(untransformed_mass))%>%
  mutate(fold_change = untransformed_mass/nh, 
         perc_increase = ((untransformed_mass-nh)/nh) * 100)
sx <- select(sx, lcl, final_ws_avg, untransformed_mass, ord_mag_change, fold_change, perc_increase)
sx
```

...it does not increase as much as initial size in definitive host: 

```{r}
sx <- s[c("traitlog_start", "traitlog_start:stage_lcllc2_2", "traitlog_start:stage_lcllc3_3", 
          "traitlog_start:stage_lcllc3+_4"), "quant.50."]
sx <- data.frame(lcl = 1:4,
                 initial_ws_avg = c(sx[1],
                                         sx[1]+sx[2],
                                         sx[1]+sx[3],
                                         sx[1]+sx[4]))
sx <- mutate(sx, prev_ws_avg = lag(initial_ws_avg))%>%
  mutate(ord_mag_change = initial_ws_avg - prev_ws_avg)%>%
  mutate(untransformed_mass = exp(initial_ws_avg))%>%
  mutate(nh = lag(untransformed_mass))%>%
  mutate(fold_change = untransformed_mass/nh, 
         perc_increase = ((untransformed_mass-nh)/nh) * 100)
sx <- select(sx, lcl, initial_ws_avg, untransformed_mass, ord_mag_change, fold_change, perc_increase)
sx
rm(sx)
```

And here are the parameters for the stage and host traits model:

```{r}
s <- data.frame(quant = summary(chains3.2$Sol)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

In the R^2^ table, the stages model explains more variation for initial size, but not end size or devo time. This was one of the main differences from imputed analysis, where stage had a clear affect on devo time (via paratenics).

```{r}
m1 <- r2_multiv(chains3.0)
m2 <- r2_multiv(chains3.1)
m3 <- r2_multiv(chains3.2)

m1$model <- 'host traits'
m2$model <- 'parasite stages'
m3$model <- 'host traits & parasite stages'

r2_table <- bind_rows(m1, m2, m3)%>%
  arrange(trait)%>%
  select(model, trait, r2m, r2c)
r2_table
```

Now let's extract the predicted marginal means and credible intervals for each parasite life stage from these two models.

```{r}
# predicted and CI from model with all stages
pdx <- chains3.1$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyy$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains3.1$Fixed$nfl # number of fixed effx, rand effx marginalized
p_stg <- as.matrix(pdx) %*% t(chains3.1$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth from every iteration
p_stgrg <- 
  ( p_stg[(p_n+1):(p_n*2),] - # end size
     p_stg[1:p_n,] ) # start size


# predicted and CI from model excluding stages that grow little
pdx <- chains3.1rg$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyy2$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n2 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains3.1rg$Fixed$nfl # number of fixed effx, rand effx marginalized
p_stg2 <- as.matrix(pdx) %*% t(chains3.1rg$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth rate from every iteration
p_stgrgr <- 
  ( p_stg2[(p_n2+1):(p_n2*2),] - # end size
     p_stg2[1:p_n2,] ) / # start size
  (exp(p_stg2[(p_n2*2 + 1):(p_n2*3),])) # devo time

# predicted and CI from cumulative dt model
pdx <- chains4$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyy3$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n3 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains4$Fixed$nfl # number of fixed effx, rand effx marginalized
p_stg3 <- as.matrix(pdx) %*% t(chains4$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

p_cdt <- (p_stg3[(p_n3*2 + 1):(p_n3*3),]) # cum dt

# predicted means for every iteration for every trait
px <- data.frame(filter(dxyy, pred != "no")%>%
                   select(pred, Host_no_fac, lcl_max_fac, prop_endo),
                 log_start_p = p_stg[1:p_n,],
                 log_end_p = p_stg[(p_n+1):(p_n*2),],
                 log_dt_p = p_stg[(p_n*2 + 1):(p_n*3),],
                 # log_start_p2 = p_stg3[1:p_n3,],
                 # log_end_p2 = p_stg3[(p_n3+1):(p_n3*2),],
                 cum_dt = p_cdt,
                 rg = p_stgrg,
                 rgr = p_stgrgr)


# calculate cumulative development time within lc groups
# px_cum_dt <-px%>%
#   pivot_longer(
#     cols = log_start_p.1:names(px)[length(px)],
#     names_to = c("trait","iter"),
#     names_sep = "\\.",
#     values_to = "mod_pred"
#   )%>%
#   filter(trait == "log_dt_p")%>%
#   arrange(iter, lcl_max_fac, Host_no_fac)%>%
#   group_by(iter, lcl_max_fac)%>%
#   mutate(trait = "cum_dt", cum_dt = cumsum(exp(mod_pred)))%>%
#   select(-mod_pred)%>%rename(mod_pred = cum_dt)%>%
#   ungroup()

# reshape predicted vals for all iter, calc fit and quantiles
px_stg_contrasts <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )
p_stg <- px_stg_contrasts%>%
  # bind_rows(., px_cum_dt)%>%
  group_by(pred, Host_no_fac, lcl_max_fac, prop_endo, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

```{r}
# predicted and CI from model with all stages
pdx <- chains3.0$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyz$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains3.0$Fixed$nfl # number of fixed effx, rand effx marginalized
p_ht <- as.matrix(pdx) %*% t(chains3.0$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth from every iteration
p_htrg <- 
  ( p_ht[(p_n+1):(p_n*2),] - # end size
     p_ht[1:p_n,] ) # start size


# predicted and CI from model with just growing stages
pdx <- chains3.0rg$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyz2$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n2 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains3.0rg$Fixed$nfl # number of fixed effx, rand effx marginalized
p_ht2 <- as.matrix(pdx) %*% t(chains3.0rg$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth rate from every iteration
p_htrg2 <- 
  ( p_ht2[(p_n2+1):(p_n2*2),] - # end size
     p_ht2[1:p_n2,] ) / # start size
  (exp(p_ht2[(p_n2*2 + 1):(p_n2*3),])) # devo time

# predicted and CI from cum dt model
pdx <- chains4.1$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyz3$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n3 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains4.1$Fixed$nfl # number of fixed effx, rand effx marginalized
p_ht3 <- as.matrix(pdx) %*% t(chains4.1$Sol[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

p_htcdt <- (p_ht3[(p_n3*2 + 1):(p_n3*3),]) # cum dt

# predicted means for every iteration for every trait
px <- data.frame(filter(dxyz, pred != "no")%>%
                   select(pred, Host_no_fac, lcl_max_fac, prop_endo),
                 log_start_p = p_ht[1:p_n,],
                 log_end_p = p_ht[(p_n+1):(p_n*2),],
                 log_dt_p = p_ht[(p_n*2 + 1):(p_n*3),],
                 cum_dt = p_htcdt,
                 rg = p_htrg,
                 rgr = p_htrg2)


# # calculate cumulative development time within lc groups
# px_cum_dt <-px%>%
#   pivot_longer(
#     cols = log_start_p.1:names(px)[length(px)],
#     names_to = c("trait","iter"),
#     names_sep = "\\.",
#     values_to = "mod_pred"
#   )%>%
#   filter(trait == "log_dt_p")%>%
#   arrange(iter, lcl_max_fac, Host_no_fac)%>%
#   group_by(iter, lcl_max_fac)%>%
#   mutate(trait = "cum_dt", cum_dt = cumsum(exp(mod_pred)))%>%
#   select(-mod_pred)%>%rename(mod_pred = cum_dt)%>%
#   ungroup()

# reshape predicted vals for all iter, calc fit and quantiles
px_ht_contrasts <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )
p_ht <- px_ht_contrasts%>%
  # bind_rows(., px_cum_dt)%>%
  group_by(pred, Host_no_fac, lcl_max_fac, prop_endo, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

rm(px, pdx, n, nt, p_i, p_n, p_n2, num_fe, p_htrg, p_stgrg, p_htrg2, p_stgrg2, px_cum_dt)
```
```{r}
p_ht2 <- p_ht%>%
  pivot_wider(names_from = trait, values_from = fit:upr)%>%
  ungroup()
names(p_ht2) <- c("pred","Host_no_fac","lcl_max_fac","prop_endo",
                  "cum_dt.fit", "log_dt_p.fit", "log_end_p.fit", "log_start_p.fit", "rg.fit", "rgr.fit",
                  "cum_dt.lwr", "log_dt_p.lwr", "log_end_p.lwr", "log_start_p.lwr", "rg.lwr", "rgr.lwr",
                  "cum_dt.upr", "log_dt_p.upr", "log_end_p.upr", "log_start_p.upr", "rg.upr", "rgr.upr")
p_stg2 <- p_stg%>%
  pivot_wider(names_from = trait, values_from = fit:upr)%>%
  ungroup()
names(p_stg2) <- c("pred","Host_no_fac","lcl_max_fac","prop_endo",
                  "cum_dt.fit", "log_dt_p.fit", "log_end_p.fit", "log_start_p.fit", "rg.fit", "rgr.fit",
                  "cum_dt.lwr", "log_dt_p.lwr", "log_end_p.lwr", "log_start_p.lwr", "rg.lwr", "rgr.lwr",
                  "cum_dt.upr", "log_dt_p.upr", "log_end_p.upr", "log_start_p.upr", "rg.upr", "rgr.upr")
```
```{r}
p_ht2$model <- 'host'
p_stg2$model <- 'stage'
p_all3 <- bind_rows(p_ht2, p_stg2)

p_all3 <- left_join(p_all3, 
                    select(dxy, lcl_max_fac, Host_no_fac, Stage)%>%filter(Stage!="4larv")%>%distinct()%>%na.omit()
)
```

## Panels of Fig. 4

After calculating predicted stage means and their CI from the posterior distribution, we plot them over boxplots of the observed data, starting with final size.

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, log_end_p.fit, log_end_p.upr, log_end_p.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_end_p.fit:log_end_p.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(log_end_p.fit_host >= log_end_p.lwr_stage & log_end_p.fit_host <= log_end_p.upr_stage),
         sig2 = !(log_end_p.fit_stage >= log_end_p.lwr_host & log_end_p.fit_stage <= log_end_p.upr_host)
           # between(log_end_p.fit_stage, log_end_p.lwr_host, log_end_p.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = log_end_p.fit_stage, host = log_end_p.fit_host, sig)
```
```{r}
lc_labs <- c(
  `1` = "1",
  `2` = "2",
  `3` = "3",
  `3+` = "4 or 5"
)

f3a <- ggplot(filter(dxy, !is.na(biovolume)),
       aes(x = Host_no_fac, y = biovolume)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(biovolume)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = bquote("Final worm size "(~mm^3)),
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) + 
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(log_end_p.fit),
                      ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = exp(log_end_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min(dxy$biovolume, na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black', fill = "white"),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
f3a
# ggsave(f3a, filename = "../../figs/fig3a.png", width = 8, height = 3.5)
```

Relative to host traits, parasites tend to grow to a smaller final size in the second host of three-host cycles and the first host of two-host cycles. Direct cycle worms are also smaller than expected. Here are the differences in a table. The skew towards negative values suggests that the host trait model generally predicts larger worms than the stage model.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 1))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Here is the same plot restricted to adult stages. It suggests adult worm sizes are predicted well by host traits, except in direct life cycles.

```{r}
ggplot(filter(dxy, !is.na(biovolume), Stage == "adult"),
       aes(x = lcl_max_fac, y = biovolume)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(biovolume)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = bquote("Final worm size "(~mm^3)),
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = lcl_max_fac, y = exp(log_end_p.fit),
                      ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = lcl_max_fac, y = exp(log_end_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Here are the differences in adult worm size for different life cycle lengths.

```{r}
filter(p_all3, model == "stage",
       (lcl_max_fac == "1" & Host_no_fac == "1") | 
         (lcl_max_fac == "2" & Host_no_fac == "2") | 
         (lcl_max_fac == "3" & Host_no_fac == "3") | 
         (lcl_max_fac == "3+" & Host_no_fac == "4"))%>%
  select(Host_no_fac, lcl_max_fac, log_end_p.fit)%>%
  mutate(log_size_diff = log_end_p.fit - lag(log_end_p.fit))%>%
  mutate(fold_change = exp(log_size_diff))
```

We can also look at how life cycle truncation would impact reproductive sizes. Here is what would happen if a four-host cycle parasite reproduced in the third host.

```{r}
filter(p_all3, model == "stage",
         (lcl_max_fac == "3" & Host_no_fac == "3") | 
         (lcl_max_fac == "3+" & Host_no_fac == "3"))%>%
  arrange((lcl_max_fac))%>%
  select(Host_no_fac, lcl_max_fac, log_end_p.fit)%>%
  mutate(log_size_diff = lag(log_end_p.fit)-log_end_p.fit)%>%
  mutate(fold_change = exp(log_size_diff), perc_decrease = (log_size_diff/lag(log_end_p.fit)) * 100)
```

Here is what would happen if a three-host cycle parasite reproduced in the second host.

```{r}
filter(p_all3, model == "stage",
         (lcl_max_fac == "2" & Host_no_fac == "2") | 
         (lcl_max_fac == "3" & Host_no_fac == "2"))%>%
  arrange((lcl_max_fac))%>%
  select(Host_no_fac, lcl_max_fac, log_end_p.fit)%>%
  mutate(log_size_diff = lag(log_end_p.fit)-log_end_p.fit)%>%
  mutate(fold_change = exp(log_size_diff), perc_decrease = (log_size_diff/lag(log_end_p.fit)) * 100)
```

Here is what would happen if a two-host cycle parasite reproduced in the first host.

```{r}
filter(p_all3, model == "stage",
         (lcl_max_fac == "2" & Host_no_fac == "1") | 
         (lcl_max_fac == "2" & Host_no_fac == "2"))%>%
  arrange((lcl_max_fac))%>%
  select(Host_no_fac, lcl_max_fac, log_end_p.fit)%>%
  mutate(log_size_diff = lag(log_end_p.fit)-log_end_p.fit)%>%
  mutate(fold_change = exp(log_size_diff), perc_decrease = (log_size_diff/lag(log_end_p.fit)) * 100)
```

Another way to look at what would happen if worms reproduced in penultimate hosts is to compare worm size in penultimate hosts and final hosts. Moreover, we can also compare worms in a penultimate host to worms that reproduce in the same host number (e.g. worms in 1st intermediate host of 2-host cycle vs worms with 1-host cycle).

```{r}
px_ht_contrasts$model <- 'host'
px_stg_contrasts$model <- 'stage'
px_contrasts <- bind_rows(px_ht_contrasts, px_stg_contrasts)
c1 <- px_contrasts%>%
  filter(trait == "log_end_p",
         (lcl_max_fac == "1" & Host_no_fac == "1") | 
           (lcl_max_fac == "2" & Host_no_fac == "1") |
           (lcl_max_fac == "2" & Host_no_fac == "2") 
           )%>%
  group_by(model, iter)%>%
  arrange(model, iter)%>%
  mutate(diff_to_reprod = lag(mod_pred) - mod_pred, 
         diff_to_nexthost = lead(mod_pred) - mod_pred )%>%
  select(model, lcl_max_fac, Host_no_fac, mod_pred, diff_to_reprod, diff_to_nexthost)%>%
  filter(lcl_max_fac == "2" & Host_no_fac == "1")%>%
  group_by(model,lcl_max_fac, Host_no_fac)%>%
  summarize(diff_to_reprod_fit = median(diff_to_reprod), 
            diff_to_nexthost_fit = median(diff_to_nexthost),
            diff_to_reprod_lwr = quantile(diff_to_reprod, probs = 0.025), 
            diff_to_reprod_upr = quantile(diff_to_reprod, probs = 0.975),
            diff_to_nexthost_lwr = quantile(diff_to_nexthost, probs = 0.025), 
            diff_to_nexthost_upr = quantile(diff_to_nexthost, probs = 0.975),
            )%>%
  pivot_longer(cols = diff_to_reprod_fit:diff_to_nexthost_fit,
               names_to = "contrast", values_to = "diff")%>%
  mutate(upr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_upr, diff_to_nexthost_upr),
         lwr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_lwr, diff_to_nexthost_lwr))

c2 <- px_contrasts%>%
  filter( trait == "log_end_p",
          (lcl_max_fac == "2" & Host_no_fac == "2") | 
           (lcl_max_fac == "3" & Host_no_fac == "2") |
           (lcl_max_fac == "3" & Host_no_fac == "3") 
           )%>%
  group_by(model, iter)%>%
  arrange(model, iter)%>%
  mutate(diff_to_reprod = lag(mod_pred) - mod_pred, 
         diff_to_nexthost = lead(mod_pred) - mod_pred )%>%
  select(model, lcl_max_fac, Host_no_fac, mod_pred, diff_to_reprod, diff_to_nexthost)%>%
  filter(lcl_max_fac == "3" & Host_no_fac == "2")%>%
  group_by(model,lcl_max_fac, Host_no_fac)%>%
  summarize(diff_to_reprod_fit = median(diff_to_reprod), 
            diff_to_nexthost_fit = median(diff_to_nexthost),
            diff_to_reprod_lwr = quantile(diff_to_reprod, probs = 0.025), 
            diff_to_reprod_upr = quantile(diff_to_reprod, probs = 0.975),
            diff_to_nexthost_lwr = quantile(diff_to_nexthost, probs = 0.025), 
            diff_to_nexthost_upr = quantile(diff_to_nexthost, probs = 0.975),
            )%>%
  pivot_longer(cols = diff_to_reprod_fit:diff_to_nexthost_fit,
               names_to = "contrast", values_to = "diff")%>%
  mutate(upr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_upr, diff_to_nexthost_upr),
         lwr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_lwr, diff_to_nexthost_lwr))

c3 <- px_contrasts%>%
  filter( trait == "log_end_p",
          (lcl_max_fac == "3" & Host_no_fac == "3") | 
           (lcl_max_fac == "3+" & Host_no_fac == "3") |
           (lcl_max_fac == "3+" & Host_no_fac == "4") 
           )%>%
  group_by(model, iter)%>%
  arrange(model, iter)%>%
  mutate(diff_to_reprod = lag(mod_pred) - mod_pred, 
         diff_to_nexthost = lead(mod_pred) - mod_pred )%>%
  select(model, lcl_max_fac, Host_no_fac, mod_pred, diff_to_reprod, diff_to_nexthost)%>%
  filter(lcl_max_fac == "3+" & Host_no_fac == "3")%>%
  group_by(model,lcl_max_fac, Host_no_fac)%>%
  summarize(diff_to_reprod_fit = median(diff_to_reprod), 
            diff_to_nexthost_fit = median(diff_to_nexthost),
            diff_to_reprod_lwr = quantile(diff_to_reprod, probs = 0.025), 
            diff_to_reprod_upr = quantile(diff_to_reprod, probs = 0.975),
            diff_to_nexthost_lwr = quantile(diff_to_nexthost, probs = 0.025), 
            diff_to_nexthost_upr = quantile(diff_to_nexthost, probs = 0.975),
            )%>%
  pivot_longer(cols = diff_to_reprod_fit:diff_to_nexthost_fit,
               names_to = "contrast", values_to = "diff")%>%
  mutate(upr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_upr, diff_to_nexthost_upr),
         lwr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_lwr, diff_to_nexthost_lwr))

cx <- bind_rows(ungroup(c1), ungroup(c2), ungroup(c3))
cx <- mutate(cx, fc = exp(diff), fc_lwr = exp(lwr), fc_upr = exp(upr))
```
```{r}
dx_cx_avg <- dxy%>%
  group_by(lcl_max_fac, Host_no_fac)%>%
  summarize(log_end_med = median(log_end, na.rm = T))

d1 <- filter(dxy, 
           (lcl_max_fac == "2" & Host_no_fac == "1") |
           (lcl_max_fac == "2" & Host_no_fac == "2") 
           )%>%
  group_by(Parasite.species, parasite_phylum)%>%
  mutate(diff_to_nexthost_fit = lead(log_end) - log_end )%>%
  select(lcl_max_fac, Host_no_fac, log_end, diff_to_nexthost_fit)%>%
  filter(lcl_max_fac == "2" & Host_no_fac == "1")
d1$log_end_repro <- dx_cx_avg%>%
  filter(lcl_max_fac == "1" & Host_no_fac == "1")%>%.$log_end_med

d2 <- filter(dxy, 
           (lcl_max_fac == "3" & Host_no_fac == "2") |
           (lcl_max_fac == "3" & Host_no_fac == "3") 
           )%>%
  group_by(Parasite.species, parasite_phylum)%>%
  mutate(diff_to_nexthost_fit = lead(log_end) - log_end )%>%
  select(lcl_max_fac, Host_no_fac, log_end, diff_to_nexthost_fit)%>%
  filter(lcl_max_fac == "3" & Host_no_fac == "2")
d2$log_end_repro <- dx_cx_avg%>%
  filter(lcl_max_fac == "2" & Host_no_fac == "2")%>%.$log_end_med

d3 <- filter(dxy, 
           (lcl_max_fac == "3+" & Host_no_fac == "3") |
           (lcl_max_fac == "3+" & Host_no_fac == "4") 
           )%>%
  group_by(Parasite.species, parasite_phylum)%>%
  mutate(diff_to_nexthost_fit = lead(log_end) - log_end )%>%
  select(lcl_max_fac, Host_no_fac, log_end, diff_to_nexthost_fit)%>%
  filter(lcl_max_fac == "3+" & Host_no_fac == "3")
d3$log_end_repro <- dx_cx_avg%>%
  filter(lcl_max_fac == "3" & Host_no_fac == "3")%>%.$log_end_med

dxy_pen <- bind_rows(ungroup(d1), ungroup(d2), ungroup(d3))
dxy_pen <- dxy_pen%>%
  mutate(diff_to_reprod_fit = log_end_repro - log_end)
dxy_pen <- dxy_pen%>%
  pivot_longer(cols = starts_with("diff"),
             names_to = "contrast", values_to = "diff")%>%
  mutate(fc = exp(diff))

```

Here is that plot for final worm size. In general, worms can grow substantially larger in their next host (positive fold change, above dotted line). However, some worms reach sizes in their penultimate hosts that are comparable to sizes achieved by worms that reproduce in same host number (points falling below line in right panel). Importantly, the relative benefits of putting off reproduction decrease with life cycle length.

```{r}
contrast_labs <- c(
  `diff_to_nexthost_fit` = 'To definitive next host, n + 1', 
  `diff_to_reprod_fit` = 'To species where host n\nis definitive host'
  )
ggplot(dxy_pen, aes(x = Host_no_fac, y = fc, shape = contrast)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  geom_boxplot(outlier.colour = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             position = position_jitterdodge(jitter.width = 0.33, jitter.height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  geom_pointrange(data = cx, 
                  aes(y = fc, ymin = fc_lwr, ymax = fc_upr,
                      shape = contrast, color = model ),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = cx,
            aes(x = Host_no_fac, y = fc, group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  labs(x = "Penultimate intermediate host, n",
       y = "Fold change in worm size",
       color = NULL,
       shape = "Constrast") +
  guides(shape = F) +
  theme(legend.background = element_rect(color = 'black'),
        legend.position = c(0.2, 0.2),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) +
  facet_grid(~contrast, labeller = labeller(contrast = contrast_labs)) 
  
```

Moving onto starting size, direct cycle parasites enter the host at smaller sizes than we would expect. Worms with the longest life cycles stay small initially and then enter their final hosts at a larger size than we would expect.

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, log_start_p.fit, log_start_p.upr, log_start_p.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_start_p.fit:log_start_p.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(log_start_p.fit_host >= log_start_p.lwr_stage & log_start_p.fit_host <= log_start_p.upr_stage),
         sig2 = !(log_start_p.fit_stage >= log_start_p.lwr_host & log_start_p.fit_stage <= log_start_p.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = log_start_p.fit_stage, host = log_start_p.fit_host, sig)
```
```{r}
f3b <- ggplot(filter(dxy, !is.na(initial_biov)),
       aes(x = Host_no_fac, y = initial_biov)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(initial_biov)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = bquote("Initial worm size "(~mm^3)),
       color = 'Model predictions') +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(log_start_p.fit),
                      ymin = exp(log_start_p.lwr), ymax = exp(log_start_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = exp(log_start_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min(dxy$initial_biov, na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
f3b
```

Here's the table. Unlike for final size, stage means for initial size are sometimes overestimated and sometimes underestimated by host traits alone.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 1))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Here is initial size in definitive hosts.

```{r}
ggplot(filter(dxy, !is.na(initial_biov), Stage == "adult"),
       aes(x = lcl_max_fac, y = initial_biov)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(initial_biov)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = bquote("Initial worm size "(~mm^3)),
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = lcl_max_fac, y = exp(log_start_p.fit),
                      ymin = exp(log_start_p.lwr), ymax = exp(log_start_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = lcl_max_fac, y = exp(log_start_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

We can also look at relative growth, the difference between initial and final worm size. 

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, rg.fit, rg.upr, rg.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = rg.fit:rg.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(rg.fit_host >= rg.lwr_stage & rg.fit_host <= rg.upr_stage),
         sig2 = !(rg.fit_stage >= rg.lwr_host & rg.fit_stage <= rg.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = rg.fit_stage, host = rg.fit_host, sig)
```
```{r}
ggplot(filter(dxy, !is.na(initial_biov), !is.na(biovolume)),
       aes(x = Host_no_fac, y = exp(log(biovolume)-log(initial_biov)))
       ) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(initial_biov)|is.na(biovolume)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Relative growth\n(fold increase in size)",
       color = 'Model predictions') +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(rg.fit),
                      ymin = exp(rg.lwr), ymax = exp(rg.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, 
            aes(x = Host_no_fac, y = exp(rg.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min( exp(dxy$log_end - dxy$log_start), na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Relative growth was lower than expected in third and fourth hosts of 4-host cycles and higher in the second hosts of 4-host cycles.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 1))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Relative growth as adults decreased with life cycle length, as worms entered definitive hosts at larger initial sizes with longer life cycles.

```{r}
ggplot(filter(dxy, !is.na(initial_biov), !is.na(biovolume), Stage == "adult"),
       aes(x = Host_no_fac, y = exp(log(biovolume)-log(initial_biov)))
       ) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(initial_biov)|is.na(biovolume)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Relative growth as adult\n(fold increase in size)",
       color = 'Model predictions') +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = Host_no_fac, y = exp(rg.fit),
                      ymin = exp(rg.lwr), ymax = exp(rg.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = Host_no_fac, y = exp(rg.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Next we look at developmental time.

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, log_dt_p.fit, log_dt_p.upr, log_dt_p.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_dt_p.fit:log_dt_p.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(log_dt_p.fit_host >= log_dt_p.lwr_stage & log_dt_p.fit_host <= log_dt_p.upr_stage),
         sig2 = !(log_dt_p.fit_stage >= log_dt_p.lwr_host & log_dt_p.fit_stage <= log_dt_p.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = log_dt_p.fit_stage, host = log_dt_p.fit_host, sig)
```
```{r}
f3c <- ggplot(filter(dxy, !is.na(avg_dt)),
       aes(x = Host_no_fac, y = avg_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10() +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Development time (days)",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(log_dt_p.fit),
                      ymin = exp(log_dt_p.lwr), ymax = exp(log_dt_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = exp(log_dt_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min( exp(dxy$log_dt), na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
f3c
```

Here's the table. Worms rarely developed longer than expected, perhaps in the definitive host of 2-host cycles. Rather, in "middle" life stages like second and third intermediate hosts, parasites developed less than expected (paratenesis).

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 1))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Here is prepatent period for adults. It was quite constant.

```{r}
ggplot(filter(dxy, !is.na(avg_dt), Stage == "adult"),
       aes(x = Host_no_fac, y = avg_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10() +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Development time (days)",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = Host_no_fac, y = exp(log_dt_p.fit),
                      ymin = exp(log_dt_p.lwr), ymax = exp(log_dt_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = Host_no_fac, y = exp(log_dt_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Instead of stage-level devo time, we can also plot cumulative development time across stages. Cumulative development represents the costs of continued growth.

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, cum_dt.fit, cum_dt.upr, cum_dt.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = cum_dt.fit:cum_dt.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(cum_dt.fit_host >= cum_dt.lwr_stage & cum_dt.fit_host <= cum_dt.upr_stage),
         sig2 = !(cum_dt.fit_stage >= cum_dt.lwr_host & cum_dt.fit_stage <= cum_dt.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = cum_dt.fit_stage, host = cum_dt.fit_host, sig)
```
```{r}
ggplot(filter(dxyy3, !is.na(cum_dt),
              # !Parasite.species %in% nspp$Parasite.species
              ),
       aes(x = Host_no_fac, y = cum_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10() +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Cumulative development time",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(cum_dt.fit),
                      ymin = exp(cum_dt.lwr), ymax = exp(cum_dt.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = exp(cum_dt.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min(dxyy3$cum_dt, na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Again, stages tend to spend less time developing than expected, not more, especially in longer life cycles.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 2))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Here is total developmental time to sexual maturity. It increases with life cycle length.

```{r}
ggplot(filter(dxyy3, !is.na(cum_dt), Stage == "adult", 
              # !Parasite.species %in% nspp$Parasite.species
              ),
       aes(x = Host_no_fac, y = cum_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10() +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Cumulative development time",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = Host_no_fac, y = exp(cum_dt.fit),
                      ymin = exp(cum_dt.lwr), ymax = exp(cum_dt.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = Host_no_fac, y = exp(cum_dt.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Here are the predicted differences in total developmental time.

```{r}
filter(p_all3, model == "stage",
       (lcl_max_fac == "1" & Host_no_fac == "1") | 
         (lcl_max_fac == "2" & Host_no_fac == "2") | 
         (lcl_max_fac == "3" & Host_no_fac == "3") | 
         (lcl_max_fac == "3+" & Host_no_fac == "4"))%>%
  select(Host_no_fac, lcl_max_fac, cum_dt.fit, cum_dt.upr, cum_dt.lwr)%>%
  mutate_at(vars(starts_with("cum_dt")), function(x){exp(x)})
```

How much will temperature impact this? We can look at the time worms spend in endotherms vs ectotherms. Here is the proportion of their life spent in endotherms or ectotherms. Species with complex life cycles spend over 50% of their lives on average in ectotherms.

```{r}
cd <- dat%>%
  mutate(avg_dt_p = if_else(is_paratenic == 1, 3, avg_dt))%>%
  group_by(Parasite.species)%>%
  mutate(cum_dt = if_else(!Parasite.species %in% nspp & !Parasite.species %in% incomp_spp, cumsum(avg_dt_p), NA_real_))%>%
  ungroup()

cx <- filter(cd, !Parasite.species %in% nspp & !Parasite.species %in% incomp_spp, !is.na(cum_dt))%>%
  group_by(Parasite.species)%>%
  mutate(cmax = max(cum_dt, na.rm = T))%>%
  select(Parasite.species, lcl_max_fac, cmax)%>%distinct()

filter(cd, !is.na(cum_dt))%>%
  group_by(Parasite.species, endo_ecto)%>%
  summarise(dt_endo_ecto = sum(avg_dt_p))%>%
  pivot_wider(., names_from = endo_ecto, values_from = dt_endo_ecto)%>%
  mutate(ecto = if_else(is.na(ecto), 0, ecto), endo = if_else(is.na(endo), 0, endo))%>%
  left_join(., cx)%>%
  mutate(prop_ecto = ecto/cmax, prop_endo = endo/cmax)%>%
  ggplot(., aes(x = lcl_max_fac, y = prop_endo)) + geom_boxplot(outlier.colour = NA) + geom_jitter(alpha = 0.3)
```

Here are the median values from the plot above.

```{r}
filter(cd, !is.na(cum_dt))%>%
  group_by(Parasite.species, endo_ecto)%>%
  summarise(dt_endo_ecto = sum(avg_dt_p))%>%
  pivot_wider(., names_from = endo_ecto, values_from = dt_endo_ecto)%>%
  mutate(ecto = if_else(is.na(ecto), 0, ecto), endo = if_else(is.na(endo), 0, endo))%>%
  left_join(., cx)%>%
  mutate(prop_ecto = ecto/cmax, prop_endo = endo/cmax)%>%
  group_by(lcl_max_fac)%>%
  summarise(n = n(), prop_ecto = median(prop_ecto), prop_endo = median(prop_endo))
```

And here is the same stat, but split by simple vs complex life cycle.

```{r}
filter(cd, !is.na(cum_dt))%>%
  group_by(Parasite.species, endo_ecto)%>%
  summarise(dt_endo_ecto = sum(avg_dt_p))%>%
  pivot_wider(., names_from = endo_ecto, values_from = dt_endo_ecto)%>%
  mutate(ecto = if_else(is.na(ecto), 0, ecto), endo = if_else(is.na(endo), 0, endo))%>%
  left_join(., cx)%>%
  mutate(prop_ecto = ecto/cmax, prop_endo = endo/cmax)%>%
  group_by(lcl_max_fac!="1")%>%
  summarise(n = n(), prop_ecto = median(prop_ecto), prop_endo = median(prop_endo))
rm(cx, cd)
```

We can treat age the same way we treated final size above. In other words, let's look at how much age increases by not reproducing in the penultimate intermediate host. We also compare worms in a penultimate host to worms that reproduce in the same host number (e.g. worms in 1st intermediate host of 2-host cycle vs worms with 1-host cycle). This can be thought of as the relative costs associated with longer growth in an additional host.

```{r}
px_ht_contrasts$model <- 'host'
px_stg_contrasts$model <- 'stage'
px_contrasts <- bind_rows(px_ht_contrasts, px_stg_contrasts)
c1 <- px_contrasts%>%
  filter(trait == "cum_dt",
         (lcl_max_fac == "1" & Host_no_fac == "1") | 
           (lcl_max_fac == "2" & Host_no_fac == "1") |
           (lcl_max_fac == "2" & Host_no_fac == "2") 
           )%>%
  group_by(model, iter)%>%
  arrange(model, iter)%>%
  mutate(diff_to_reprod = lag(mod_pred) - mod_pred, 
         diff_to_nexthost = lead(mod_pred) - mod_pred )%>%
  select(model, lcl_max_fac, Host_no_fac, mod_pred, diff_to_reprod, diff_to_nexthost)%>%
  filter(lcl_max_fac == "2" & Host_no_fac == "1")%>%
  group_by(model,lcl_max_fac, Host_no_fac)%>%
  summarize(diff_to_reprod_fit = median(diff_to_reprod), 
            diff_to_nexthost_fit = median(diff_to_nexthost),
            diff_to_reprod_lwr = quantile(diff_to_reprod, probs = 0.025), 
            diff_to_reprod_upr = quantile(diff_to_reprod, probs = 0.975),
            diff_to_nexthost_lwr = quantile(diff_to_nexthost, probs = 0.025), 
            diff_to_nexthost_upr = quantile(diff_to_nexthost, probs = 0.975),
            )%>%
  pivot_longer(cols = diff_to_reprod_fit:diff_to_nexthost_fit,
               names_to = "contrast", values_to = "diff")%>%
  mutate(upr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_upr, diff_to_nexthost_upr),
         lwr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_lwr, diff_to_nexthost_lwr))

c2 <- px_contrasts%>%
  filter( trait == "cum_dt",
          (lcl_max_fac == "2" & Host_no_fac == "2") | 
           (lcl_max_fac == "3" & Host_no_fac == "2") |
           (lcl_max_fac == "3" & Host_no_fac == "3") 
           )%>%
  group_by(model, iter)%>%
  arrange(model, iter)%>%
  mutate(diff_to_reprod = lag(mod_pred) - mod_pred, 
         diff_to_nexthost = lead(mod_pred) - mod_pred )%>%
  select(model, lcl_max_fac, Host_no_fac, mod_pred, diff_to_reprod, diff_to_nexthost)%>%
  filter(lcl_max_fac == "3" & Host_no_fac == "2")%>%
  group_by(model,lcl_max_fac, Host_no_fac)%>%
  summarize(diff_to_reprod_fit = median(diff_to_reprod), 
            diff_to_nexthost_fit = median(diff_to_nexthost),
            diff_to_reprod_lwr = quantile(diff_to_reprod, probs = 0.025), 
            diff_to_reprod_upr = quantile(diff_to_reprod, probs = 0.975),
            diff_to_nexthost_lwr = quantile(diff_to_nexthost, probs = 0.025), 
            diff_to_nexthost_upr = quantile(diff_to_nexthost, probs = 0.975),
            )%>%
  pivot_longer(cols = diff_to_reprod_fit:diff_to_nexthost_fit,
               names_to = "contrast", values_to = "diff")%>%
  mutate(upr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_upr, diff_to_nexthost_upr),
         lwr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_lwr, diff_to_nexthost_lwr))

c3 <- px_contrasts%>%
  filter( trait == "cum_dt",
          (lcl_max_fac == "3" & Host_no_fac == "3") | 
           (lcl_max_fac == "3+" & Host_no_fac == "3") |
           (lcl_max_fac == "3+" & Host_no_fac == "4") 
           )%>%
  group_by(model, iter)%>%
  arrange(model, iter)%>%
  mutate(diff_to_reprod = lag(mod_pred) - mod_pred, 
         diff_to_nexthost = lead(mod_pred) - mod_pred )%>%
  select(model, lcl_max_fac, Host_no_fac, mod_pred, diff_to_reprod, diff_to_nexthost)%>%
  filter(lcl_max_fac == "3+" & Host_no_fac == "3")%>%
  group_by(model,lcl_max_fac, Host_no_fac)%>%
  summarize(diff_to_reprod_fit = median(diff_to_reprod), 
            diff_to_nexthost_fit = median(diff_to_nexthost),
            diff_to_reprod_lwr = quantile(diff_to_reprod, probs = 0.025), 
            diff_to_reprod_upr = quantile(diff_to_reprod, probs = 0.975),
            diff_to_nexthost_lwr = quantile(diff_to_nexthost, probs = 0.025), 
            diff_to_nexthost_upr = quantile(diff_to_nexthost, probs = 0.975),
            )%>%
  pivot_longer(cols = diff_to_reprod_fit:diff_to_nexthost_fit,
               names_to = "contrast", values_to = "diff")%>%
  mutate(upr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_upr, diff_to_nexthost_upr),
         lwr = if_else(contrast == "diff_to_reprod_fit", diff_to_reprod_lwr, diff_to_nexthost_lwr))

cx <- bind_rows(ungroup(c1), ungroup(c2), ungroup(c3))
cx <- mutate(cx, fc = exp(diff), fc_lwr = exp(lwr), fc_upr = exp(upr))
```

```{r}
dx_cx_avg <- dxyy3%>%
  group_by(lcl_max_fac, Host_no_fac)%>%
  summarize(cum_dt_med = median(log_cumdt, na.rm = T))

d1 <- filter(dxyy3, 
           (lcl_max_fac == "2" & Host_no_fac == "1") |
           (lcl_max_fac == "2" & Host_no_fac == "2") 
           )%>%
  group_by(Parasite.species, parasite_phylum)%>%
  mutate(diff_to_nexthost_fit = lead(log_cumdt) - log_cumdt )%>%
  select(lcl_max_fac, Host_no_fac, log_cumdt, diff_to_nexthost_fit)%>%
  filter(lcl_max_fac == "2" & Host_no_fac == "1")
d1$cum_dt_repro <- dx_cx_avg%>%
  filter(lcl_max_fac == "1" & Host_no_fac == "1")%>%.$cum_dt_med

d2 <- filter(dxyy3, 
           (lcl_max_fac == "3" & Host_no_fac == "2") |
           (lcl_max_fac == "3" & Host_no_fac == "3") 
           )%>%
  group_by(Parasite.species, parasite_phylum)%>%
  mutate(diff_to_nexthost_fit = lead(log_cumdt) - log_cumdt )%>%
  select(lcl_max_fac, Host_no_fac, log_cumdt, diff_to_nexthost_fit)%>%
  filter(lcl_max_fac == "3" & Host_no_fac == "2")
d2$cum_dt_repro <- dx_cx_avg%>%
  filter(lcl_max_fac == "2" & Host_no_fac == "2")%>%.$cum_dt_med

d3 <- filter(dxyy3, 
           (lcl_max_fac == "3+" & Host_no_fac == "3") |
           (lcl_max_fac == "3+" & Host_no_fac == "4") 
           )%>%
  group_by(Parasite.species, parasite_phylum)%>%
  mutate(diff_to_nexthost_fit = lead(log_cumdt) - log_cumdt )%>%
  select(lcl_max_fac, Host_no_fac, log_cumdt, diff_to_nexthost_fit)%>%
  filter(lcl_max_fac == "3+" & Host_no_fac == "3")
d3$cum_dt_repro <- dx_cx_avg%>%
  filter(lcl_max_fac == "3" & Host_no_fac == "3")%>%.$cum_dt_med

dxy_pen <- bind_rows(ungroup(d1), ungroup(d2), ungroup(d3))
dxy_pen <- dxy_pen%>%
  mutate(diff_to_reprod_fit = cum_dt_repro - log_cumdt)
dxy_pen <- dxy_pen%>%
  pivot_longer(cols = starts_with("diff"),
             names_to = "contrast", values_to = "diff")

```

Here is that plot for final worm size. In general, worms spend some time growing in next host, so there is a cost to infecting next host (positive change in age, above dotted line). However, some worms reach ages in their penultimate hosts that are comparable to ages achieved by worms that reproduce in same host number (points falling below line in right panel). The relative costs of suppressing reproduction until the next host are rather consistent or they decrease slightly at the longest life cycles (they need little time to mature in final host). Since the relative benefits of suppressing reproduction decrease with life cycle whereas the relative costs are constant, this suggests that suppressing reproduction gets less beneficial with each additional host.

```{r}
ggplot(dxy_pen, aes(x = Host_no_fac, y = exp(diff), shape = contrast)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  geom_boxplot(outlier.colour = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             position = position_jitterdodge(jitter.width = 0.33, jitter.height = 0)) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  scale_y_log10() +
  geom_pointrange(data = cx, 
                  aes(y = fc, ymin = fc_lwr, ymax = fc_upr,
                      shape = contrast, color = model ),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = cx,
            aes(x = Host_no_fac, y = fc, group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  labs(x = "Penultimate intermediate host, n",
       y = "Fold change in worm age",
       color = NULL,
       shape = "Constrast") +
  guides(shape = F) +
  theme(legend.background = element_rect(color = 'black'),
        legend.position = c(0.2, 0.15),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) +
  facet_grid(~contrast, labeller = labeller(contrast = contrast_labs)) 

```


Putting growth and development time together, we can look at growth rates. 
```{r}
# replace stage means for rgr with NA (could be estimated via 3 traits post dist, but no stages with all 3 traits at this stage)
p_all3 <- mutate(p_all3, rgr.fit = if_else(model == "stage" & Host_no_fac == "3" & lcl_max_fac == "3+", NA_real_, rgr.fit),
       rgr.lwr = if_else(model == "stage" & Host_no_fac == "3" & lcl_max_fac == "3+", NA_real_, rgr.lwr),
       rgr.upr = if_else(model == "stage" & Host_no_fac == "3" & lcl_max_fac == "3+", NA_real_, rgr.upr))
```
```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, rgr.fit, rgr.upr, rgr.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = rgr.fit:rgr.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(rgr.fit_host >= rgr.lwr_stage & rgr.fit_host <= rgr.upr_stage),
         sig2 = !(rgr.fit_stage >= rgr.lwr_host & rgr.fit_stage <= rgr.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = rgr.fit_stage, host = rgr.fit_host, sig)
```
```{r}
f3d <- ggplot(filter(dxy, !is.na(biovolume), !is.na(initial_biov), !is.na(avg_dt), avg_dt>7),
       aes(x = Host_no_fac, y = (log_end - log_start)/avg_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(biovolume)|is.na(initial_biov)|is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Relative growth rate\n(~% size increase per day)",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = rgr.fit,
                      ymin = rgr.lwr, ymax = rgr.upr,
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = rgr.fit, group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%
               mutate(y = -0.2), #min( ((dxy$log_end - dxy$log_start)/dxy$avg_dt), na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) +
  coord_cartesian(ylim = c(-0.21, 1.2))
f3d
```

Growth rates are relatively consistent among stages. Here's the table. Growth was slower than expected in the definitive hosts in four-host cycles. It was faster in the initial stages of long cycles.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3),
       diff_btw_predictions2 = round(log(`stage`) - log(`host`), 3))%>%
  mutate(fold_change = round((abs(diff_btw_predictions2)), 2))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

And here are the differences in growth rates among stages. It varies 3-fold but the CIs are wide. Early life stages tend to have faster growth than later life stages. 

```{r}
select(p_all3, Host_no_fac, lcl_max_fac, model, rgr.fit, rgr.upr, rgr.lwr)%>%
  filter(model == "stage")%>%
  arrange(rgr.fit)%>%
  mutate(across(starts_with("rgr"), ~round(.x, 2)))
```

Adult growth rates were lower in longer life cycles.

```{r}
ggplot(filter(dxy, !is.na(biovolume), !is.na(initial_biov), !is.na(avg_dt), avg_dt>7, Stage == "adult"),
       aes(x = lcl_max_fac, y = (log_end - log_start)/avg_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(biovolume)|is.na(initial_biov)|is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Relative growth rate",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = lcl_max_fac, y = rgr.fit,
                      ymin = rgr.lwr, ymax = rgr.upr,
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = lcl_max_fac, y = rgr.fit, group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Here are those adult growth rates above in a table.

```{r}
filter(p_all3, model == "stage",
       (lcl_max_fac == "1" & Host_no_fac == "1") | 
         (lcl_max_fac == "2" & Host_no_fac == "2") | 
         (lcl_max_fac == "3" & Host_no_fac == "3") | 
         (lcl_max_fac == "3+" & Host_no_fac == "4"))%>%
  select(Host_no_fac, lcl_max_fac, rgr.fit, rgr.upr, rgr.lwr)
```

We combined these figures for export...

```{r}
f3a2 <- f3a + 
  theme(legend.position = c(0.9, 0.175),
        axis.title.x = element_blank(), 
        axis.text.x = element_blank())

f3b2 <- f3b +
  theme(legend.position = "none",
        axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        strip.background = element_blank(),
        strip.text.x = element_blank())

f3c2 <- f3c +
  theme(legend.position = "none",
        axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        strip.background = element_blank(),
        strip.text.x = element_blank())

f3d2 <- f3d +
  theme(legend.position = "none",
        strip.background = element_blank(),
        strip.text.x = element_blank())
```
```{r}
f3 <- plot_grid(f3a2, f3b2, f3c2, f3d2, align="hv", ncol = 1, labels = c('(a)', '(b)', '(c)', '(d)'))
f3dd <- plot_grid(f3c, f3d, align="hv", ncol = 1, labels = c('(c)', '(d)'))
```
```{r}
title <- ggdraw() +
  draw_label("Not Imputed",
    fontface = 'bold',
    size = 20
  ) 

f3gif <- plot_grid(title, 
                   plot_grid(f3a2, f3b2, f3c2, f3d2, align="v", ncol = 1, labels = c('(a)', '(b)', '(c)', '(d)')),
                   ncol = 1, 
                   rel_heights = c(0.1, 1))
```
```{r}
title <- ggdraw() +
  draw_label("Not imputed, days",
    fontface = 'bold',
    size = 20
  ) 

f3dd <- plot_grid(title, 
                  f3dd,
                  ncol = 1, 
                  rel_heights = c(0.1, 1))
```
```{r}
ggsave(f3, filename = "../../figs/fig4_noimp.png",
       width = 8, height =  3.5*4)
ggsave(f3, filename = "../../figs/fig4_noimp.svg",
       width = 8, height = 3.5*4)
# move closer together in inkscape, adjust labels
ggsave(f3gif, filename = "../../figs/gif_imp_vs_noimp/fig4_noimp.png",
       width = 8, height = 3.5*4)
ggsave(f3dd, filename = "../../figs/gif_dd_vs_nodd/fig4_noimp.png",
       width = 10, height = 3.5*2)
rm(f3gif, f3a2, f3b2, f3c2, f3d2, f3dd)
```

# Size by age

Another way to look at these model predictions are with growth curves. Let's plot the model predictions from host traits vs stages as growth curves, i.e. size vs time. We take propagule size as size at t = 0.

```{r}
eggies <- select(p_all3, Host_no_fac, lcl_max_fac, model, log_dt_p.fit, 
                 log_end_p.fit = log_start_p.fit,
                 log_end_p.lwr = log_start_p.lwr,
                 log_end_p.upr = log_start_p.upr)%>%
  filter(Host_no_fac == '1')%>%
  mutate(Host_no_fac = '0',
         log_dt_p.fit = 0,
         log_dt_p.lwr = 0,
         log_dt_p.upr = 0,
         cum_dt.fit = 0,
         cum_dt.lwr = 0,
         cum_dt.upr = 0)

p_all3_cum <- bind_rows(p_all3, eggies)
```

```{r}
p_all3_cum <- group_by(p_all3_cum, lcl_max_fac, model)%>%
  arrange(lcl_max_fac, model, Host_no_fac)%>%
  mutate(grp = paste(lcl_max_fac,model))
```

This plot shows the predicted increase in parasite size with each host as a function of time. The colors represent different life cycle lengths and the predictions from host traits vs stages are separated. Differences between the models are a little hard to see here.

```{r}
ggplot(p_all3_cum,
       aes(x = exp(cum_dt.fit), y = exp(log_end_p.fit), color = lcl_max_fac)) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr), xmax = exp(cum_dt.upr))) +
  geom_line(aes(group = lcl_max_fac)) + 
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
  facet_wrap(~model) +
  labs(x = 'Cumulative time developing', 
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

Maybe these differences are easier to see if we compare the models within each life cycle length. For one-host life cycles, parasites infect hosts at a smaller size and grow less than expected from their hosts.

```{r}
ggplot(filter(p_all3_cum, lcl_max_fac == '1'),
       aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit))) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1)) +
  geom_line(aes(linetype = model)) +
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  # scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
  labs(x = 'Cumulative time developing', 
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

Two-host cycles are the most common in the dataset, so they have an outsized affect on the parameters of the host trait model. That may explain why expectations and observation align well. If anything, parasites grow slower than expected in both hosts.

```{r}
ggplot(filter(p_all3_cum, lcl_max_fac == '2'),
       aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit))) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1)) +
  geom_line(aes(group = grp, linetype = model)) + 
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  labs(x = 'Cumulative time developing', 
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

Parasites with three host cycles grow less than expected in second hosts, but then a bit longer in the 3rd hosts.

```{r}
ggplot(filter(p_all3_cum, lcl_max_fac == '3'),
       aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit))) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1)) +
  geom_line(aes(group = grp, linetype = model)) + 
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  labs(x = 'Cumulative time developing',
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

Parasites with the longest life cycles from faster at the beginning of their cycles and then slower at the end. In particular, they forgo growth in the third host.

```{r}
ggplot(filter(p_all3_cum, lcl_max_fac == '3+'),
       aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit))) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1)) +
  geom_line(aes(group = grp, linetype = model)) + 
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  labs(x = 'Cumulative time developing', 
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

```{r}
p_all3_wide <- select(p_all3_cum, Host_no_fac, lcl_max_fac, model, log_end_p.fit, cum_dt.fit)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_end_p.fit:cum_dt.fit)
p_all3_cumx <- left_join(p_all3_cum, p_all3_wide)
```

Here's another attempt to visualize these model comps. Arrows show how the stage-only means deviate from expectations based on the host traits only model. Arrows towards the left (shorter devo) or up (more growth) imply parasite are overachieving relative to host-trait expectations. Parasites growing faster than expected appears rare, though worms with long cycles seem to shorten developmental time, relative to expectations.

```{r}
ggplot(filter(p_all3_cumx, model == 'stage'),
        aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), color = lcl_max_fac)) +
  geom_line(aes(group = grp), alpha = 0.5) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1), alpha = 0.3) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr)), alpha = 0.3) + 
  geom_segment(data = filter(p_all3_cumx, model == 'host'),
               aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit),
                   yend = exp(`log_end_p.fit_stage`),
                   xend = exp(`cum_dt.fit_stage`)-1 ),
               arrow = arrow(angle = 10,
                             type = 'closed', length = unit(0.15, 'inches')),
               linetype = 'dashed') +
  geom_label(aes(label = Host_no_fac),alpha = 0.5) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
  guides(color = F) +
  labs(x = 'Cumulative time developing (days)',
       y = bquote("Worm size "(~mm^3)))  +
  theme(panel.grid.minor = element_blank()) +
  facet_grid(~lcl_max_fac)
```

Model predictions are "adjusted" for taxonomy, but for some groups this might be misleading. For example, direct life cycle worms are all related, so when we account for taxonomy, their expected adult size is shifted up towards the overall mean. Let's also make the above plot using observed data. However, when we use observed data, we cannot put errors around the means, given that they ignore variability due to missingness.

```{r}
# Calculate cumulative devo time
cum_dd_sp <- mutate(dat, avg_dt_p = if_else(is_paratenic == 1, 3, avg_dt))
# make sp level df with cum dt
cum_dd_sp <- cum_dd_sp%>%
  group_by(Parasite.species)%>%
  mutate(cum_dt = if_else(!Parasite.species %in% nspp & !Parasite.species %in% incomp_spp, cumsum(avg_dt_p), NA_real_))

eggies <- select(cum_dd_sp, Parasite.species, parasite_genus, parasite_family, parasite_order, parasite_class, parasite_phylum,
                 Host_no_fac, lcl_max_fac,  
                 cum_dt,
                 log_end = log_start,
                 biovolume = initial_biov,
                 biovolume = initial_biov)%>%
  filter(Host_no_fac == '1')%>%
  mutate(Host_no_fac = '0',
         cum_dt = 0 )

cum_dd_sp <- bind_rows(cum_dd_sp, eggies)%>%
  arrange(Parasite.species, lcl_max_fac, Host_no_fac)

```
```{r}
# make group level df for cum dt
p1 <- 0.75
p2 <- 0.25
cum_dd <- ungroup(cum_dd_sp)%>%
  filter(Host_no_fac != "0")%>%
  group_by(lcl_max_fac, Host_no_fac)%>%
  summarise(log_start_p.fit = median(log_start, na.rm=T),
            # log_start_p.upr = quantile(log_start, probs = p1, na.rm=T),
            # log_start_p.lwr = quantile(log_start, probs = p2, na.rm=T),
            log_end_p.fit = median(log_end, na.rm=T),
            # log_end_p.upr = quantile(log_end, probs = p1, na.rm=T),
            # log_end_p.lwr = quantile(log_end, probs = p2, na.rm=T),
            log_dt_p.fit = median(log_dt, na.rm=T),
            # log_dt_p.upr = quantile(log(cum_dt), probs = p1, na.rm=T),
            # log_dt_p.lwr = quantile(log(cum_dt), probs = p2, na.rm=T),
            cum_dt.fit = median(log(cum_dt), na.rm=T),
            )%>%
  filter(!is.na(lcl_max_fac))

eggies <- select(cum_dd, Host_no_fac, lcl_max_fac, log_dt_p.fit, 
                 log_end_p.fit = log_start_p.fit
                 )%>%
  filter(Host_no_fac == '1')%>%
  mutate(Host_no_fac = '0',
         log_dt_p.fit = 0,
         cum_dt.fit = 0,
         )

cum_dd <- bind_rows(cum_dd, eggies)%>%
  arrange(lcl_max_fac, Host_no_fac)

cum_dd$model <- "observed"
cum_dd <- bind_rows(cum_dd, p_all3_cum)
cum_dd <- mutate(cum_dd, grp = paste(lcl_max_fac,model))

cum_dd_wide <- select(cum_dd, Host_no_fac, lcl_max_fac, model, log_end_p.fit, cum_dt.fit)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_end_p.fit:cum_dt.fit)
cum_dd <- left_join(cum_dd, cum_dd_wide)
cum_dd <- cum_dd%>%
  mutate(model = forcats::fct_relevel(model, c("host", "stage", "observed")))
```

Here is the median cumulative development time for direct vs complex life cycles...

```{r}
cum_dd_sp%>%
  filter(Stage == "adult", !Parasite.species %in% nspp)%>%
  group_by(lcl_max_fac==1)%>%
  summarize(n_imp = sum(!is.na(cum_dt)),
            med_cum_dt = median(cum_dt, na.rm = T),
            sd_cum_dt = sd(cum_dt, na.rm = T))
```

...and among life cycle lengths.

```{r}
cum_dd_sp%>%
  filter(Stage == "adult")%>%
  group_by(lcl_max_fac, Host_no_fac)%>%
  summarize(n_imp = sum(!is.na(cum_dt)),
            med_cum_dt = median(cum_dt, na.rm = T),
            sd_cum_dt = sd(cum_dt, na.rm = T))
```

Here is how the stage medians differ from host-derived expectations. Overall, the pattern is similar, but the reduction in growth for 1-host cycles is more conspicuous.

```{r}
lc_labs <- c(
  `1` = "1",
  `2` = "2",
  `3` = "3",
  `3+` = "4 or 5"
)

ggplot(filter(cum_dd, model == 'observed'),
        aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), color = lcl_max_fac)) +
  geom_line(aes(group = grp), alpha = 0.5) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1), alpha = 0.3) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr)), alpha = 0.3) + 
  geom_segment(
    # data = filter(p_all3_cumx, model == 'host'),
               aes(x = exp(cum_dt.fit_host)-1, y = exp(log_end_p.fit_host),
                   yend = exp(`log_end_p.fit`),
                   xend = exp(`cum_dt.fit`)-1 ),
               arrow = arrow(angle = 10,
                             type = 'closed', length = unit(0.15, 'inches')),
               linetype = 'dashed') +
  geom_label(aes(label = Host_no_fac),alpha = 0.5) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
  guides(color = F) +
  labs(x = 'Cumulative time developing (days)',
       y = bquote("Worm size "(~mm^3)))  +
  theme(panel.grid.minor = element_blank()) +
  facet_grid(~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs))
```

Given that observed and model means differed, it is probably worth plotting them over the actual data.

```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(1, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt)|is.na(biovolume)), 
             alpha = 0.4, size = 0.8) + 
  # geom_smooth(method = , se = F, aes(group = NA), linetype = "dotted", color = "black") +
  geom_line(data = cum_dd, 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = cum_dd, 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = cum_dd, 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = cum_dd, aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  facet_grid(model~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', y = 'Final worm size', color = 'LCL') 
```

Obviously, the observed means match the data best, especially for one-host cycles. It might be easier to compare the models with an "average" growth curve. Therefore, I fit non-linear asymptotic and Weibull growth models to the full dataset. In neither case do I account for phylogeny, i.e. curve parameters do not vary among taxa.

The Weibull regression has an extra parameter compared to the asymptotic model. A likelihood ratio test suggests this model is a bit better.

```{r}
iPar <- list(Asym = max(cum_dd_sp$log_end, na.rm = T), lrc = 0.02, R0 = min(cum_dd_sp$log_end, na.rm = T))
tl_asy <- nls(log_end ~ Asym - (Asym - R0) * exp(-lrc*cum_dt), # for this parameterization of VBLG, see here: https://derekogle.com/NCNRS349/modules/Growth/BKG
          start = iPar,
          data = cum_dd_sp)

iPar <- getInitial(log(biovolume) ~ SSasymp(cum_dt, Asym, R0, lrc), data = cum_dd_sp)
tl_asy2 <- nls(log(biovolume) ~ Asym+(R0-Asym)*exp(-exp(lrc)*cum_dt),
          start = iPar,
          data = filter(cum_dd_sp, !is.na(biovolume), !is.na(cum_dt)))
# summary(tl_asy)
# summary(tl_asy2) # exactly the same, just different parameterizations


iPar <- getInitial(log(biovolume) ~ SSweibull(cum_dt, Asym, Drop, lrc, pwr), data = cum_dd_sp)
tl_w <- nls(log(biovolume) ~ Asym-Drop*exp(-exp(lrc)*cum_dt^pwr),
          start = iPar,
          data = filter(cum_dd_sp, !is.na(biovolume), !is.na(cum_dt)))
# summary(tl_w)
anova(tl_asy2, tl_w)
```

The curve is also a better fit than a line, as the residual standard errors are much lower than for a line. The residual plot also looks much better for the curve than for the line (not shown).

```{r}
tl_lm <- lm(log(biovolume) ~ cum_dt, data = filter(cum_dd_sp, !is.na(biovolume), !is.na(cum_dt)))
data.frame(line_res_se = summary(tl_lm)$sigma, curve_res_se = summary(tl_asy)$sigma)
```

Here are the parameters of the curve:

```{r}
summary(tl_asy)
```

Let's add this curve to the above plot. The median values for different life stages follow the curve rather well.

```{r}
x<-0:150
lg <- data.frame(x = x, y = exp( predict(tl_asy, newdata = data.frame(cum_dt = x)) ),
                 y2 = exp( predict(tl_w, newdata = data.frame(cum_dt = x)) ) )
```
```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(0, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt)|is.na(biovolume)), 
             alpha = 0.4, size = 0.8) + 
  geom_line(data = lg, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = cum_dd, 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = cum_dd, 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = cum_dd, 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = cum_dd, aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  facet_grid(model~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', y = 'Final worm size', color = 'LCL') 
```

We can also focus on just the observed means and not the model predictions.

```{r}
f5 <- ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(0, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt)|is.na(biovolume)), 
             alpha = 0.8, size = 0.5) + 
  geom_line(data = lg, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = filter(cum_dd, model == "observed"), 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = filter(cum_dd, model == "observed"), aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 2) +
  facet_grid(~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', 
       y = bquote("Worm size "(~mm^3))) +
  theme(panel.grid.minor = element_blank()) 
f5
ggsave(f5, filename = "../../figs/fig5d_noimp.png", width = 8, height = 3)
ggsave(f5, filename = "../../figs/fig5d_noimp.svg", width = 8, height = 3)
```

How far are the observed medians from the curve? The first host in 2-host cycles was furthest below the curve while the second host in 4-host cycles was the furthest above the curve.

```{r}
cum_dd$pred_size <- predict(tl_asy, newdata = mutate(cum_dd, cum_dt = exp(cum_dt.fit)))
mutate(cum_dd, residual = (log_end_p.fit - pred_size))%>%
  filter(model == "observed")%>%
  select(lcl_max_fac, Host_no_fac, residual)%>%
  arrange(residual)
```

Here is the sum of squares for the stage medians (for comparing to the degree day curve).

```{r}
mutate(cum_dd, res = (log_end_p.fit - pred_size)^2)%>%
  filter(model == "observed")%>%
  ungroup()%>%
  summarise(sum_se = sum(res))
```

We could also make the plot above, but connecting the points for each species with a line. This is too hectic.

```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(0, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  # geom_point(aes(shape = is.na(cum_dt_ni)|is.na(biovolume)), 
  #            alpha = 0.6, size = 0.8) + 
  geom_line(aes(group = Parasite.species), alpha = 0.25) +
  geom_line(data = lg, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = filter(cum_dd, model == "observed"), 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = filter(cum_dd, model == "observed"), aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  facet_grid(~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', 
       y = bquote("Worm size "(~mm^3))) 
```

Maybe it is easier to compare life cycle lengths when they are on the same plot. I think it is better separate.

```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(0, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt)|is.na(biovolume)), 
             alpha = 0.4, size = 0.8) + 
  geom_line(data = lg, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = filter(cum_dd, model == "observed"), 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = filter(cum_dd, model == "observed"), aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  labs(x = 'Cumulative time developing (days)', y = 'Final worm size', color = 'LCL') 
```


# Covariation among the traits determining growth rate

The multivariate model allows us to examine the covariance among traits and whether this is affected by the model predictors. First, let's look at the residual covariance, the covariance among parasite traits after accounting for fixed predictors and parasite taxonomy.

```{r}
r1 <- posterior.cor(chains0$VCV[,grepl(colnames(chains0$VCV), pattern = '.units')])
r2 <- posterior.cor(chains3.0$VCV[,grepl(colnames(chains3.0$VCV), pattern = '.units')])
r3 <- posterior.cor(chains3.1$VCV[,grepl(colnames(chains3.1$VCV), pattern = '.units')])


r_start_end <- r1[,2]
r_start_dt <- r1[,3]
r_end_dt <- r1[,6]
r2_start_end <- r2[,2]
r2_start_dt <- r2[,3]
r2_end_dt <- r2[,6]
r3_start_end <- r3[,2]
r3_start_dt <- r3[,3]
r3_end_dt <- r3[,6]

tax_corr <- data.frame(model = rep(factor(c('intercept', 'host traits', 'stages'),
                                          levels = c('intercept', 'host traits', 'stages')), each = 3),
                       trait = rep(c("Initial x Final Size", "Initial Size x Devo Time", "Final Size x Devo Time"), 3),
                       tax_cor = c(posterior.mode(r_start_end),
                                   posterior.mode(r_start_dt),
                                   posterior.mode(r_end_dt),
                                   posterior.mode(r2_start_end),
                                   posterior.mode(r2_start_dt),
                                   posterior.mode(r2_end_dt),
                                   posterior.mode(r3_start_end),
                                   posterior.mode(r3_start_dt),
                                   posterior.mode(r3_end_dt)
                                   ),
                       tax_cor_lwr = c(quantile(r_start_end, probs = 0.025),
                                   quantile(r_start_dt, probs = 0.025),
                                   quantile(r_end_dt, probs = 0.025),
                                   quantile(r2_start_end, probs = 0.025),
                                   quantile(r2_start_dt, probs = 0.025),
                                   quantile(r2_end_dt, probs = 0.025),
                                   quantile(r3_start_end, probs = 0.025),
                                   quantile(r3_start_dt, probs = 0.025),
                                   quantile(r3_end_dt, probs = 0.025)
                                   ),
                       tax_cor_upr = c(quantile(r_start_end, probs = 0.975),
                                   quantile(r_start_dt, probs = 0.975),
                                   quantile(r_end_dt, probs = 0.975),
                                   quantile(r2_start_end, probs = 0.975),
                                   quantile(r2_start_dt, probs = 0.975),
                                   quantile(r2_end_dt, probs = 0.975),
                                   quantile(r3_start_end, probs = 0.975),
                                   quantile(r3_start_dt, probs = 0.975),
                                   quantile(r3_end_dt, probs = 0.975)
                                   )
                       )
```

Regardless of fixed effects, residual covariance is positive between final size and devo time. Worm stages that reach a large size relative to their host or their stage have longer development. There is a negative correlation between initial size and devo time after accounting for host traits or stages. That is, worm stages that enter a host at a large size often have shorter development times, at least after accounting for host or stage. Interestingly, the residual correlation between initial and final size went different directions. If we do not account for host traits or parasite stages, it is positive, but if we account for parasite stages it is negative. This makes sense, an adult worm has a big initial and final size compared to larval worms, but once we correct for stage, we might see that adult worms that start large reproduce earlier and have smaller final sizes.

```{r}
ggplot(tax_corr, aes(x = model, y = tax_cor)) +
  geom_pointrange(aes(ymin = tax_cor_lwr, ymax = tax_cor_upr)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  facet_wrap(~trait) +
  labs(x = NULL, y = 'Correlation', title = 'Residual correlations for different models') +
  guides(color = F) +
  coord_flip() +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

We can also explore taxonomic correlations among stages. We'll refit the model, but allowing unstructured covariance for two of the taxonomic random effects: family and order. There was significant variance at these taxonomic levels, and there is enough replication within them to estimate covariances. To understand these covariances, we fit three models, each with host traits and worm stages: model 1) no taxonomic effects, 2) with taxonomic effects (fam by stage), 3) with taxonomic covariance. We also tweaked the random effect structure slightly. We swapped family and order for the combinations of family-stage and order-stage. This is easier to interpret. For example positive family-stage covariance between devo time and end size, suggests that when families are larger than expected at a given stage, they also develop longer.

```{r}
# first filter to just data including fixed predictors
dxy <- filter(dat, !(is.na(avg_dt) & is.na(biovolume) & is.na(initial_biov)))
dxy <- filter(dat, Facultative != 'postcyclic',
              !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
dxy <- mutate(dxy, gen_by_stage = paste0(parasite_genus, stage_lcl),
              fam_by_stage = paste0(parasite_family, stage_lcl),
              ord_by_stage = paste0(parasite_order, stage_lcl))
```

```{r}
# first model without tax ran eff
modx <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                    trait:host_bm + trait:host_tl + trait:prop_endo +
                    trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo +
                    trait:stage_lcl, 
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          nitt = 40000, thin = 30, burnin = 1000,
                          data = dxy,
                          family = c("gaussian", "gaussian", "gaussian"), pr=T, 
                          verbose = F)
# second model with tax ran eff
mody <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                    trait:host_bm + trait:host_tl + trait:prop_endo +
                    trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo +
                    trait:stage_lcl, 
                  random = ~ idh(trait):Parasite.species +
                   idh(trait):parasite_genus +
                   idh(trait):fam_by_stage + 
                   idh(trait):parasite_order + 
                   idh(trait):parasite_class + 
                   idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 40000, thin = 30, burnin = 1000,
                          data = dxy,
                          family = c("gaussian", "gaussian", "gaussian"), pr=T, 
                          verbose = F)
# third model with tax ran eff and tax cov
modz <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                    trait:host_bm + trait:host_tl + trait:prop_endo +
                    trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo +
                    trait:stage_lcl, 
                  random = ~ idh(trait):Parasite.species +
                    idh(trait):parasite_genus +
                    us(trait):fam_by_stage + 
                    us(trait):ord_by_stage + 
                    idh(trait):parasite_class + 
                    idh(trait):parasite_phylum, # taxonomic tree as random effect
                  rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 40000, thin = 30, burnin = 1000,
                          data = dxy,
                          family = c("gaussian", "gaussian", "gaussian"), pr=T, 
                          verbose = F)
```

Here is variance explained in the previous model...

```{r}
r2_multiv(chains3.2)
```

...and here is how much it goes up by letting family effects differ for each life stage.

```{r}
r2_multiv(mody)
# r2_multiv(modz) # similar
```
Furthermore, taxon-level covariance among also improves the model, at least judged simply on DIC. This is not surprising, given their strong phylogenetic signals.

```{r}
mody$DIC
modz$DIC
```

Since the family x stage effect is important, let's check which families grow more (or less) than expected at a given stage.

```{r}
# family random effects for each trait
fam_re <- which(grepl(".fam_by_stage.", colnames(mody$Sol)))
sx <- summary(mody$Sol[, fam_re])
sxx <- data.frame(sx$quantiles[,c(1,3,5)])
names(sxx) <- c("re_lwr", "re", "re_upr")
sxx$re_name <- row.names(sxx)

sxx <- sxx%>%mutate(trait = if_else(grepl("log_start", re_name), "log_start",
                             if_else(grepl("log_end", re_name), "log_end", "log_dt")),
             fam_stage = gsub("trait.*fam_by_stage.", "", re_name))

# family random effects for relative growth
fam_s <- which(grepl("traitlog_start.fam_by_stage.", colnames(mody$Sol)))
fam_e <- which(grepl("traitlog_end.fam_by_stage.", colnames(mody$Sol)))
sx <- summary(mody$Sol[, fam_e] - mody$Sol[, fam_s])
sxy <- data.frame(sx$quantiles[,c(1,3,5)])
names(sxy) <- c("re_lwr", "re", "re_upr")
sxy$re_name <- row.names(sxy)
sxy <- sxy%>%mutate(trait = "rg", fam_stage = gsub("trait.*fam_by_stage.", "", re_name))

sxx <- bind_rows(sxx, sxy)
sxx <- arrange(sxx, trait, re)
# sx_wide <- sxx%>%
#   pivot_wider(id = fam_stage, names_from=trait, values_from = re)
```

Here are the 15 combinations of family and stage that grow the most...

```{r}
filter(sxx, trait == "rg")%>%
  arrange(desc(re))%>%
  select(fam_stage, re_lwr, re, re_upr)%>%
  slice_head(n=15)
```

...and the least.

```{r}
filter(sxx, trait == "rg")%>%
  select(fam_stage, re_lwr, re, re_upr)%>%
  slice_head(n=15)
```

We make the same two tables for devo time. Here are the families that spend more time in the host than expected.

```{r}
filter(sxx, trait == "log_dt")%>%
  arrange(desc(re))%>%
  select(fam_stage, re_lwr, re, re_upr)%>%
  slice_head(n=15)
```

...and those that spend less time than expected. In general, the devo time random effects are more likely to overlap zero.

```{r}
filter(sxx, trait == "log_dt")%>%
  select(fam_stage, re_lwr, re, re_upr)%>%
  slice_head(n=15)
```

Our models estimate covariance among parasite starting size, ending size, and devo time at different levels (e.g. with and without taxonomy, among families, etc.). We calculate those correlations.

```{r}
x <- c("traitlog_start:traitlog_start.units", "traitlog_start:traitlog_end.units", 
       "traitlog_end:traitlog_start.units", "traitlog_end:traitlog_end.units")
sx <- summary(posterior.cor(modx$VCV[,colnames(modx$VCV) %in% x]))
sxx <- summary(posterior.cor(mody$VCV[,colnames(mody$VCV) %in% x]))
sy <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% x]))
syy <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% 
                                        gsub(x, pattern = "units", replacement = "fam_by_stage")]))
sz <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% 
                                        gsub(x, pattern = "units", replacement = "ord_by_stage")]))
dc1 <- data.frame(trait_cor = "ini_fin", 
           model = c("res, no tax", "res, tax", "res, tax2", "fam_cov", "ord_cov"),
           cor_lwr = c(sx$quantiles[2,1], sxx$quantiles[2,1], sy$quantiles[2,1], syy$quantiles[2,1], sz$quantiles[2,1]),
           cor = c(sx$quantiles[2,3], sxx$quantiles[2,3], sy$quantiles[2,3], syy$quantiles[2,3], sz$quantiles[2,3]),
           cor_upr = c(sx$quantiles[2,5], sxx$quantiles[2,5], sy$quantiles[2,5], syy$quantiles[2,5], sz$quantiles[2,5]))


x <- gsub(x, pattern = "log_end", replacement = "log_dt")
sx <- summary(posterior.cor(modx$VCV[,colnames(modx$VCV) %in% x]))
sxx <- summary(posterior.cor(mody$VCV[,colnames(mody$VCV) %in% x]))
sy <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% x]))
syy <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% 
                                        gsub(x, pattern = "units", replacement = "fam_by_stage")]))
sz <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% 
                                        gsub(x, pattern = "units", replacement = "ord_by_stage")]))
dc2 <- data.frame(trait_cor = "ini_dt", 
           model = c("res, no tax", "res, tax", "res, tax2", "fam_cov", "ord_cov"),
           cor_lwr = c(sx$quantiles[2,1], sxx$quantiles[2,1], sy$quantiles[2,1], syy$quantiles[2,1], sz$quantiles[2,1]),
           cor = c(sx$quantiles[2,3], sxx$quantiles[2,3], sy$quantiles[2,3], syy$quantiles[2,3], sz$quantiles[2,3]),
           cor_upr = c(sx$quantiles[2,5], sxx$quantiles[2,5], sy$quantiles[2,5], syy$quantiles[2,5], sz$quantiles[2,5]))

x <- gsub(x, pattern = "log_start", replacement = "log_end")
sx <- summary(posterior.cor(modx$VCV[,colnames(modx$VCV) %in% x]))
sxx <- summary(posterior.cor(mody$VCV[,colnames(mody$VCV) %in% x]))
sy <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% x]))
syy <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% 
                                        gsub(x, pattern = "units", replacement = "fam_by_stage")]))
sz <- summary(posterior.cor(modz$VCV[,colnames(modz$VCV) %in% 
                                        gsub(x, pattern = "units", replacement = "ord_by_stage")]))
dc3 <- data.frame(trait_cor = "dt_end", 
           model = c("res, no tax", "res, tax", "res, tax2", "fam_cov", "ord_cov"),
           cor_lwr = c(sx$quantiles[2,1], sxx$quantiles[2,1], sy$quantiles[2,1], syy$quantiles[2,1], sz$quantiles[2,1]),
           cor = c(sx$quantiles[2,3], sxx$quantiles[2,3], sy$quantiles[2,3], syy$quantiles[2,3], sz$quantiles[2,3]),
           cor_upr = c(sx$quantiles[2,5], sxx$quantiles[2,5], sy$quantiles[2,5], syy$quantiles[2,5], sz$quantiles[2,5]))

dc <- bind_rows(dc1, dc2, dc3)
rm(dc1, dc2, dc3, x, sx, sxx, sy, syy, sz)
dc <- dc%>%
  mutate(txt = paste0(round(cor, 2), " [", round(cor_lwr, 2), " to ",round(cor_upr, 2),"]"))
```

Since covariances were estimated in the models after accounting for host traits and stage identities, we extracted residuals from the models. Moreover, residual covariances were estimated with taxonomic effects (when taxonomy was not included in the model) or without them (when taxonomic random effects were included).

```{r}
# get residuals
l <- length(dxy$Parasite.species)
# multiv model without taxonomy, glm
p_stg <- predict.MCMCglmm(modx,
                          interval = "none")
p_stg <- data.frame(log_start_pred = p_stg[1:l,],
                log_end_pred = p_stg[(l+1):(l*2),],
                log_dt_pred = p_stg[(l*2+1):(l*3),]
                )

# multiv model with taxonomy, marginal residuals (no tax)
p_stg2 <- predict.MCMCglmm(mody,
                          interval = "none")
p_stg2 <- data.frame(log_start_pred2 = p_stg2[1:l,],
                log_end_pred2 = p_stg2[(l+1):(l*2),],
                log_dt_pred2 = p_stg2[(l*2+1):(l*3),]
                )

# multiv model with taxonomy, conditional residuals (yes tax)
p_stg3 <- predict.MCMCglmm(mody,
                          interval = "none",
                          marginal = NULL)
p_stg3 <- data.frame(log_start_pred3 = p_stg3[1:l,],
                log_end_pred3 = p_stg3[(l+1):(l*2),],
                log_dt_pred3 = p_stg3[(l*2+1):(l*3),]
                )

# multiv model with taxo cov, marginal residuals (no tax)
p_stg4 <- predict.MCMCglmm(modz,
                          interval = "none")
p_stg4 <- data.frame(log_start_pred4 = p_stg4[1:l,],
                log_end_pred4 = p_stg4[(l+1):(l*2),],
                log_dt_pred4 = p_stg4[(l*2+1):(l*3),]
                )

# multiv model with tax cov, conditional residuals (yes tax)
p_stg5 <- predict.MCMCglmm(modz,
                          interval = "none",
                          marginal = NULL)
p_stg5 <- data.frame(log_start_pred5 = p_stg5[1:l,],
                log_end_pred5 = p_stg5[(l+1):(l*2),],
                log_dt_pred5 = p_stg5[(l*2+1):(l*3),]
                )
dxy_p <- bind_cols(dxy, p_stg, p_stg2, p_stg3, p_stg4, p_stg5)%>%
  mutate(log_start_res_lm = log_start - log_start_pred,
         log_end_res_lm = log_end - log_end_pred,
         log_dt_res_lm = log_dt - log_dt_pred,
         log_start_res_notax1 = log_start - log_start_pred2,
         log_end_res_notax1 = log_end - log_end_pred2,
         log_dt_res_notax1 = log_dt - log_dt_pred2,
         log_start_res_tax1 = log_start - log_start_pred3,
         log_end_res_tax1 = log_end - log_end_pred3,
         log_dt_res_tax1 = log_dt - log_dt_pred3,
         log_start_res_notax2 = log_start - log_start_pred4,
         log_end_res_notax2 = log_end - log_end_pred4,
         log_dt_res_notax2 = log_dt - log_dt_pred4,
         log_start_res_tax2 = log_start - log_start_pred5,
         log_end_res_tax2 = log_end - log_end_pred5,
         log_dt_res_tax2 = log_dt - log_dt_pred5
         )
# no tax resid from different models tightly correlated, same for tax resid
```

To visualize covariances, we calculate confidence ellipses. The width of the ellipses represent variance, whereas the tilt represents covariance.

```{r}
# function to calculate CI ellipse
ci_ellipse <- function(cm, meanx, meany){ # take in 2x2 cov matrix, return 95% CI ellipsoid
  
  eigVal  <- eigen(cm)$values
  eigVec  <- eigen(cm)$vectors
  eigScl  <- eigVec %*% diag(sqrt(eigVal))  # scale eigenvectors to length = square-root
  angles <- seq(0, 2*pi, length.out = 300)
  ellBase <- cbind(sqrt(eigVal[1])*cos(angles), sqrt(eigVal[2])*sin(angles)) # normal ellipse
  xcrs <- which(ellBase[,1] == max(ellBase[,1]) | ellBase[,1] == min(ellBase[,1])) # id major axis
  ycrs <- which(ellBase[,2] == max(ellBase[,2]) | ellBase[,2] == min(ellBase[,2])) # id minor axis
  ellRot  <- eigVec %*% t(ellBase) # rotated ellipse
  ellRot <- data.frame(t(ellRot))
  ellRot <- cbind(angles, ellRot)
  names(ellRot) <- c("angles", "x", "y")
  ellRot <- mutate(ellRot, x = x + meanx, y = y + meany)
  ellRot$axes[xcrs] <- "major"
  ellRot$axes[ycrs] <- "minor"
  
  return(ellRot) # dataframe for ellipse
}

# function to extract cov matrixes from post dist
post_cov_matrices_df <- function(mod1, trait1, trait2, cv_level1, num_ps){
  
  ps <- sample(1:length(mod1$VCV[,1]), size = num_ps) # random posterior samples
  
  # trait names for extracting cov matrix from post dist
  v1x <- paste0("trait",trait1,":","trait",trait1,cv_level1)
  v2x <- paste0("trait",trait2,":","trait",trait2,cv_level1)
  cv12x <- paste0("trait",trait1,":","trait",trait2,cv_level1)
  cv21x <- paste0("trait",trait2,":","trait",trait1,cv_level1)

  # loop around to take sample
  for(i in ps){
    ell_i <- ci_ellipse(
      cm = matrix(6 * (mod1$VCV[i, c(v1x, cv12x, cv21x, v2x)]), 2,2),
      meanx = 0, #mod1$Sol[i, paste0("trait",trait1)]
      meany = 0 #mod1$Sol[i, paste0("trait",trait2)]
  )
    ell_i$p_samp <- as.character(i)
    if(i == ps[1]){
      ell_many <- ell_i
    } else {
      ell_many <- bind_rows(ell_many, ell_i)
    }
  }
  
  return(ell_many)

}
```


```{r}
# cov matrices from glm
ell_s_e <- post_cov_matrices_df(modx, "log_start", "log_end", ".units", 50)
ell_s_d <- post_cov_matrices_df(modx, "log_start", "log_dt", ".units", 50)
ell_d_e <- post_cov_matrices_df(modx, "log_dt", "log_end", ".units", 50)

# cov matrices from tax model
ell_s_e2 <- post_cov_matrices_df(mody, "log_start", "log_end", ".units", 50)
ell_s_d2 <- post_cov_matrices_df(mody, "log_start", "log_dt", ".units", 50)
ell_d_e2 <- post_cov_matrices_df(mody, "log_dt", "log_end", ".units", 50)

# cov matrices from tax model
ell_s_e3 <- post_cov_matrices_df(modz, "log_start", "log_end", ".units", 50)
ell_s_d3 <- post_cov_matrices_df(modz, "log_start", "log_dt", ".units", 50)
ell_d_e3 <- post_cov_matrices_df(modz, "log_dt", "log_end", ".units", 50)

# cov matrices from tax model
ell_s_e4 <- post_cov_matrices_df(modz, "log_start", "log_end", ".fam_by_stage", 50)
ell_s_d4 <- post_cov_matrices_df(modz, "log_start", "log_dt", ".fam_by_stage", 50)
ell_d_e4 <- post_cov_matrices_df(modz, "log_dt", "log_end", ".fam_by_stage", 50)

# cov matrices from tax model
ell_s_e5 <- post_cov_matrices_df(modz, "log_start", "log_end", ".ord_by_stage", 50)
ell_s_d5 <- post_cov_matrices_df(modz, "log_start", "log_dt", ".ord_by_stage", 50)
ell_d_e5 <- post_cov_matrices_df(modz, "log_dt", "log_end", ".ord_by_stage", 50)
```

```{r}
dp1 <- dxy_p%>%
  select(Parasite.species, stage_lcl, fam_by_stage, ord_by_stage, starts_with("log_start_res"))%>%
  pivot_longer(starts_with("log_start_res"), names_to = "model", values_to = "log_start_res")%>%
  mutate(model = gsub(x = model, pattern = "log_start_", replacement = ""))
dp2 <- dxy_p%>%
  select(starts_with("log_end_res"))%>%
  pivot_longer(starts_with("log_end_res"), names_to = "model", values_to = "log_end_res")%>%
  select(-model)
dp3 <- dxy_p%>%
  select(starts_with("log_dt_res"))%>%
  pivot_longer(starts_with("log_dt_res"), names_to = "model", values_to = "log_dt_res")%>%
  select(-model)
dp <- bind_cols(dp1, dp2, dp3)
dp <- mutate(dp, n = 1)

dp4 <- dp%>%
  filter(model == "res_notax2")%>%
  group_by(fam_by_stage)%>%
  summarize(n = n(),
            log_start_res = mean(log_start_res, na.rm = T),
            log_end_res = mean(log_end_res, na.rm = T),
            log_dt_res = mean(log_dt_res, na.rm = T))%>%
  ungroup()%>%
  mutate(model = "marg_fam")

dp5 <- dp%>%
  filter(model == "res_notax2")%>%
  group_by(ord_by_stage)%>%
  summarize(n = n(),
            log_start_res = mean(log_start_res, na.rm = T),
            log_end_res = mean(log_end_res, na.rm = T),
            log_dt_res = mean(log_dt_res, na.rm = T))%>%
  ungroup()%>%
  mutate(model = "marg_ord")

dp <- bind_rows(dp, dp4, dp5)
dp <- dp%>%
  mutate(model = fct_relevel(model, c("res_lm", "res_notax1", "res_notax2", "marg_ord", "marg_fam", "res_tax1", "res_tax2")))
rm(dp1, dp2, dp3, dp4, dp5)
```
We plot the covariances for each of the three trait correlations. And we plot four covariances: without taxonomic effects (marginal residuals), with taxonomic effects (conditional residuals), and at the order and family levels.

We start with the starting and end size correlation. Overall, worms that enter a host relatively large grow to be relatively large (a positive covariance). This is at least partially driven by order-level differences and therefore reflect differences in body plans between parasites. Interestingly, once we exclude taxonomy, we get negative covariance (conditional residuals). This suggests that worms that enter the host big, tend to grow less than we would expect given their host size, their own taxonomy, etc.
```{r}
pal <- RColorBrewer::brewer.pal(4, name = "Set1")
```

```{r}
fe3a <- ggplot(dp%>%
         filter(model %in% c("res_notax2", "res_tax2", "marg_fam", "marg_ord")),
       aes(x = log_start_res, y = log_end_res)) +
  geom_hline(yintercept = 0, linetype = "dashed") + geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(color = model, size = n),
             alpha = 0.2) +
  scale_color_manual(values = pal,
                     labels = c("Marginal residuals",
                                "Marginal residuals,\norder averages",
                                "Marginal residuals,\nfamily averages",
                                "Conditional residuals")
                     ) +
  geom_path(data = arrange(ell_s_e,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[1]) +
  geom_path(data = arrange(ell_s_e3,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[4]) +
  geom_path(data = arrange(ell_s_e4,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[3]) +
  geom_path(data = arrange(ell_s_e5,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[2]) +
  guides(size = F) +
  labs(x = "Residuals, initial size", y = "Residuals, final size", color = NULL) +
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = filter(dc, trait_cor == "ini_fin", model == "res, no tax")$txt,
           x = 10, y = -5, color = pal[1], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_fin", model == "ord_cov")$txt,
           x = 10, y = -6, color = pal[2], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_fin", model == "fam_cov")$txt,
           x = 10, y = -7, color = pal[3], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_fin", model == "res, tax2")$txt,
           x = 10, y = -8, color = pal[4], size = 2)
fe3a
```
Next, find the expected negative covariance between starting size and developmental time. This also seems to be driven by deep (order-level) phylogenetic differences.

```{r}
fe3b <- ggplot(dp%>%
         filter(model %in% c("res_notax2", "res_tax2", "marg_fam", "marg_ord")),
       aes(x = log_start_res, y = log_dt_res)) +
  geom_hline(yintercept = 0, linetype = "dashed") + geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(color = model, size = n),
             alpha = 0.2) +
  scale_color_manual(values = pal, 
                     labels = c("Marginal residuals",
                                "Marginal residuals,\norder averages",
                                "Marginal residuals,\nfamily averages",
                                "Conditional residuals")
                     ) +
  geom_path(data = arrange(ell_s_d,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[1]) +
  geom_path(data = arrange(ell_s_d3,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[4]) +
  geom_path(data = arrange(ell_s_d4,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[3]) +
  geom_path(data = arrange(ell_s_d5,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[2]) +
  guides(size = F,
         color = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = "Residuals, initial size", y = "Residuals, devo time", color = NULL) +
  theme(panel.grid.minor = element_blank(),
        legend.background = element_rect(color = "black")) +
  annotate("text", label = filter(dc, trait_cor == "ini_dt", model == "res, no tax")$txt,
           x = -4, y = -2.2, color = pal[1], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_dt", model == "ord_cov")$txt,
           x = -4, y = -2.5, color = pal[2], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_dt", model == "fam_cov")$txt,
           x = -4, y = -2.8, color = pal[3], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_dt", model == "res, tax2")$txt,
           x = -4, y = -3.1, color = pal[4], size = 2) 
fe3b
```
Finally, there is a positive correlation between final size and devo time, as expected. This may be driven more by lower-level stages.

```{r}
fe3c <- ggplot(dp%>%
         filter(model %in% c("res_notax2", "res_tax2", "marg_fam", "marg_ord")),
       aes(x = log_dt_res, y = log_end_res)) +
  geom_hline(yintercept = 0, linetype = "dashed") + geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(color = model, size = n),
             alpha = 0.2) +
  scale_color_manual(values = pal, 
                     labels = c("Marginal residuals",
                                "Marginal residuals,\norder averages",
                                "Marginal residuals,\nfamily averages",
                                "Conditional residuals")
                     ) +
  geom_path(data = arrange(ell_d_e,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[1]) +
  geom_path(data = arrange(ell_d_e3,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[4]) +
  geom_path(data = arrange(ell_d_e4,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[3]) +
  geom_path(data = arrange(ell_d_e5,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[2]) +
  guides(size = F,
         color = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = "Residuals, initial size", y = "Residuals, devo time", color = NULL) +
  theme(panel.grid.minor = element_blank(),
        legend.background = element_rect(color = "black")) +
  labs(x = "Residuals, devo time", y = "Residuals, final size", color = NULL) +
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = filter(dc, trait_cor == "dt_end", model == "res, no tax")$txt,
           x = -2, y = 10, color = pal[1], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "dt_end", model == "ord_cov")$txt,
           x = -2, y = 8.5, color = pal[2], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "dt_end", model == "fam_cov")$txt,
           x = -2, y = 9, color = pal[3], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "dt_end", model == "res, tax2")$txt,
           x = -2, y = 8, color = pal[4], size = 2)
fe3c
```




```{r}
save.image(file = "after_noimp_models.RData")
```

