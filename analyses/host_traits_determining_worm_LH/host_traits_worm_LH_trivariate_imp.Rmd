---
title: "Host traits determining worm LH,  multivariate"
output: 
  github_document:
    toc: true
    df_print: kable
---

Worm parasites have different life cycles - some infect more hosts in succession, others fewer. Lengthening the life cycle (more consecutive hosts) is costly because it increases the chances of not being transmitted to the next host and it delays reproduction. Do long cycles have other advantages? In other notebooks, we examined the relationship between [life cycle length and adult worm life history](../lcl_adult_worm_traits/adult_worm_traits_vs_lcl.Rmd) and how [host trais vary across life cycles](../kinds_of_hosts/host_traits_across_clc.Rmd). In this notebook, we examine how host traits affect parasite life history traits.

```{r setup, include=FALSE}
library(tidyverse)
library(MCMCglmm)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
options(stringsAsFactors = FALSE)
theme_set(new = theme_bw())
```
```{r}
dat <- read.csv(file = "../../data/imputed_stage_level_tables/stage_level_combined_bestimputed.csv", header = T)
dat <- mutate(dat, Host_no_fac = factor(Host_no_fac),
              obs = factor(1:length(Parasite.species)))%>%
  mutate(stage_lcl = paste0("lc", lcl_max_fac, "_", Host_no_fac),
         is_paratenic = if_else(Facultative == "paratenic", 1, 0))%>%
  mutate(log_end = log(imp_biovolume), log_start = log(imp_initial_biov), 
         log_dt = log(imp_avg_dt), log_dd = log(imp_avg_dd))%>%
  mutate(rg = log_end - log_start, rgr = (log_end - log_start)/imp_avg_dt)%>%
  mutate(rgr_doubles = (log(imp_biovolume, base = 2) - log(imp_initial_biov, base = 2))/imp_avg_dt)%>%
  mutate(doubling_time = 1/rgr_doubles
         # doubling_time2 = log(2)/rgr # different way to calculate doubling time
         )%>%
  mutate(host_bm = log(10^(host_bm)))
```

We'll examine 3 parasite traits: initial size, final size, and development time. Together, they determine how long and how fast parasites grow. Fast growth is advantageous, so we are looking for the host traits that favor large size and short devo time. We'll examine each of these simultaneously in a multivariate model.

# Relative growth rate - multivariate

The three parasite traits combine to determine how fast parasites grow. Let's put them into a multivariate model to see how growth rate varies with host traits. This is better than explicitly modeling growth rate, because it accounts for variability in each variable when calculating the composite variable growth rate. We fit the multivariate models with `MCMCglmm`. We also include 'empty' data in the model, so that it will return predictions for parasite traits, holding either host mass or trophic level constant.

```{r}
# first filter to just data including fixed predictors
dxy <- filter(dat, !(is.na(imp_avg_dt) | is.na(imp_biovolume) | is.na(imp_initial_biov)))
dxy <- filter(dxy, Facultative != 'postcyclic',
              !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
dxy$pred <- 'no'

# then make data that want marginal predicions for
dx_avg <- group_by(dxy, endo_ecto)%>%
  summarize(min_bm = min(host_bm, na.rm = T),
            max_bm = max(host_bm, na.rm = T),
            min_tl = min(host_tl, na.rm = T),
            max_tl = max(host_tl, na.rm = T))

nd_bm <- bind_rows( data.frame(endo_ecto = 'ecto',
                            host_bm = seq(dx_avg$min_bm[1], dx_avg$max_bm[1], length.out = 50),
                            host_tl = median(dxy$host_tl, na.rm = T),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy$parasite_genus)[1],
                            parasite_family = unique(dxy$parasite_family)[1],
                            parasite_order = unique(dxy$parasite_order)[1],
                            parasite_class = unique(dxy$parasite_class)[1],
                            parasite_phylum = unique(dxy$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo',
                            host_bm = seq(dx_avg$min_bm[2], dx_avg$max_bm[2], length.out = 50),
                            host_tl = median(dxy$host_tl, na.rm = T),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy$parasite_genus)[1],
                            parasite_family = unique(dxy$parasite_family)[1],
                            parasite_order = unique(dxy$parasite_order)[1],
                            parasite_class = unique(dxy$parasite_class)[1],
                            parasite_phylum = unique(dxy$parasite_phylum)[1])
                 )


nd_tl <- bind_rows( data.frame(endo_ecto = 'ecto',
                            host_bm = median(dxy$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[1], dx_avg$max_tl[1], length.out = 50),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy$parasite_genus)[1],
                            parasite_family = unique(dxy$parasite_family)[1],
                            parasite_order = unique(dxy$parasite_order)[1],
                            parasite_class = unique(dxy$parasite_class)[1],
                            parasite_phylum = unique(dxy$parasite_phylum)[1]),
                 data.frame(endo_ecto = 'endo',
                            host_bm = median(dxy$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[2], dx_avg$max_tl[2], length.out = 50),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy$parasite_genus)[1],
                            parasite_family = unique(dxy$parasite_family)[1],
                            parasite_order = unique(dxy$parasite_order)[1],
                            parasite_class = unique(dxy$parasite_class)[1],
                            parasite_phylum = unique(dxy$parasite_phylum)[1])
                 )
nd_bm$pred <- 'yes, bm'
nd_tl$pred <- 'yes, tl'

dxy <- bind_rows(dxy, nd_bm, nd_tl)

# observations with at least 1 wk devo on average; better estimate of growth rate?
obs_for_rg <- dxy%>%
  filter(imp_avg_dt>6)%>%
  .$obs

dxy2 <- filter(dxy, obs %in% obs_for_rg | pred != "no")
```

As for model structure, we allow the residuals to be correlated. For example, if a worm stage has a large final size relative to its host, it probably started large or developed longer, i.e. positive residual correlations. Parasite taxonomy is treated as nested random effects. We fit the same series of models as in univariate analyses: (i) intercept only, (ii) host trait main effects, (iii) host trait interactions (2nd order). 

To account for missingness in both host and parasite traits, we created [100 imputed datasets](../make_stage_level_df_randimputedvals.Rmd). We iterate through these datasets; with each iteration, we fit the models, sample the posterior distributions, and then move to the next imputed data. We combine the chains to have results that reflect the variability due to missingness.

Here is the number of stages and species included in the model:

```{r}
filter(dxy, pred == "no", !is.na(SpSt))%>%
  summarize(n_stages = sum(!is.na(host_tl)),
            n_spp = n_distinct(Parasite.species))
```

```{r}
prior <- list(R = list(V = diag(3)/6, n = 2),
              G = list(G1 = list(V = diag(3)/6, n = 2),
                       G2 = list(V = diag(3)/6, n = 2),
                       G3 = list(V = diag(3)/6, n = 2),                       
                       G4 = list(V = diag(3)/6, n = 2),
                       G5 = list(V = diag(3)/6, n = 2),
                       G6 = list(V = diag(3)/6, n = 2)
                        )
               )
startc <- list(G = list(G1 = diag(3)/6,
                        G2 = diag(3)/6,
                        G3 = diag(3)/6,
                        G4 = diag(3)/6,
                        G5 = diag(3)/6,
                        G6 = diag(3)/6),
              R = diag(3)/6
              )
```

```{r}
chains0 = list()
chains1 = list()
chains2 = list()
chains2rg = list()

for(i in 1:100){

  iname <- ifelse(i < 10, paste0('00',i), 
                  ifelse(i < 100, paste0('0',i),i))
  fname_p <- paste0('../../data/imputed_stage_level_tables/stage_level_imputed',iname,'.csv')
  
  dat_imp <- read.csv(file = fname_p, header = T)
  
  dat_imp <- mutate(dat_imp, Host_no_fac = factor(Host_no_fac),
                obs = factor(1:length(Parasite.species)))%>%
    mutate(log_end = log(imp_biovolume), log_start = log(imp_initial_biov), 
           log_dt = log(imp_avg_dt), log_dd = log(imp_avg_dd),
           stage_lcl = paste0("lc", lcl_max_fac, "_", Host_no_fac))%>%
    mutate(rg = log_end - log_start, rgr = (log_end - log_start)/imp_avg_dt)%>%
    mutate(host_bm = log(10^(host_bm)))
  
  
  # first filter to just data including fixed predictors
  dxy_imp <- filter(dat_imp, !(is.na(log_start) | is.na(log_end) | is.na(log_dt)))
  dxy_imp <- filter(dxy_imp, Facultative != 'postcyclic',
                !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
  dxy_imp$pred <- 'no'
  
  # then make data that want marginal predicions for
  dx_avg <- group_by(dxy_imp, endo_ecto)%>%
    summarize(min_bm = min(host_bm, na.rm = T),
            max_bm = max(host_bm, na.rm = T),
            min_tl = min(host_tl, na.rm = T),
            max_tl = max(host_tl, na.rm = T))

  nd_bm <- bind_rows( data.frame(endo_ecto = 'ecto',
                            host_bm = seq(dx_avg$min_bm[1], dx_avg$max_bm[1], length.out = 50),
                            host_tl = median(dxy_imp$host_tl, na.rm = T),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy_imp$parasite_genus)[1],
                            parasite_family = unique(dxy_imp$parasite_family)[1],
                            parasite_order = unique(dxy_imp$parasite_order)[1],
                            parasite_class = unique(dxy_imp$parasite_class)[1],
                            parasite_phylum = unique(dxy_imp$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo',
                            host_bm = seq(dx_avg$min_bm[2], dx_avg$max_bm[2], length.out = 50),
                            host_tl = median(dxy_imp$host_tl, na.rm = T),
                            Parasite.species = unique(dxy$Parasite.species)[1],
                            parasite_genus = unique(dxy_imp$parasite_genus)[1],
                            parasite_family = unique(dxy_imp$parasite_family)[1],
                            parasite_order = unique(dxy_imp$parasite_order)[1],
                            parasite_class = unique(dxy_imp$parasite_class)[1],
                            parasite_phylum = unique(dxy_imp$parasite_phylum)[1])
                 )
  
  
  nd_tl <- bind_rows( data.frame(endo_ecto = 'ecto',
                              host_bm = median(dxy_imp$host_bm, na.rm = T),
                              host_tl = seq(dx_avg$min_tl[1], dx_avg$max_tl[1], length.out = 50),
                              Parasite.species = unique(dxy$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1]),
                   data.frame(endo_ecto = 'endo',
                              host_bm = median(dxy_imp$host_bm, na.rm = T),
                              host_tl = seq(dx_avg$min_tl[2], dx_avg$max_tl[2], length.out = 50),
                              Parasite.species = unique(dxy$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1])
                   )
  nd_bm$pred <- 'yes, bm'
  nd_tl$pred <- 'yes, tl'
  
  dxy_imp <- bind_rows(dxy_imp, nd_bm, nd_tl)
  dxy_imp2 <- filter(dxy_imp, obs %in% obs_for_rg | pred != "no" )
  
    
  # base model
  chains0[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1,
                        random = ~ idh(trait):Parasite.species +
                          idh(trait):parasite_genus +
                          idh(trait):parasite_family +
                          idh(trait):parasite_order +
                          idh(trait):parasite_class +
                          idh(trait):parasite_phylum, # taxonomic tree as random effect
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        nitt = 800, thin = 30, burnin = 500,
                        prior = prior,
                        start = startc,
                        data = dxy_imp,
                        family = c("gaussian", "gaussian", "gaussian"), pr=F,
                        verbose = F)

  # model with host traits, main effx
  chains1[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 +
                            trait:host_bm + trait:host_tl + trait:endo_ecto,
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family +
                            idh(trait):parasite_order +
                            idh(trait):parasite_class +
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxy_imp,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F,
                          verbose = F)
  # model with host traits, main and second order effx
  chains2[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                            trait:host_bm + trait:host_tl + trait:endo_ecto +
                             trait:host_bm:host_tl + trait:host_bm:endo_ecto + trait:host_tl:endo_ecto, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxy_imp,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
  # model for looking at growth, excluding stages with very short devo times
  chains2rg[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                            trait:host_bm + trait:host_tl + trait:endo_ecto +
                             trait:host_bm:host_tl + trait:host_bm:endo_ecto + trait:host_tl:endo_ecto, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxy_imp2,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)

  # extract starting values for next iteration
  s <- round(runif(1, min = 1, max = dim(chains2[[i]]$VCV)[1]),0)
  startc <- list(G = list(G1 = diag(round(chains2[[i]]$VCV[s,1:3],6)),
                         G2 = diag(round(chains2[[i]]$VCV[s,4:6],6)),
                         G3 = diag(round(chains2[[i]]$VCV[s,7:9],6)),
                         G4 = diag(round(chains2[[i]]$VCV[s,10:12],6)),
                         G5 = diag(round(chains2[[i]]$VCV[s,13:15],6)),
                         G6 = diag(round(chains2[[i]]$VCV[s,16:18],6))
                        ),
                R = matrix(round(chains2[[i]]$VCV[s,19:27],6), nrow = 3, ncol = 3)
               )
  
  print(paste('iteration', i, 'finished'))
}
```

We'll start by comparing model fits. Here is the trace for deviance (similar to the model likelihood) for the three models. The colored lines are those including host traits. They are far better than the intercept-only model, but the difference between the two models with host traits is not large, suggesting interactions might not be that important.

```{r}
name_dev_var <- function(x){
  dev <- x$Deviance
  dim(dev) <- c(length(dev),1)
  dimnames(dev) <- list(NULL, 'deviance')
  return(dev)
}

mod_comb_dev0 <- runjags::combine.mcmc(mcmc.list(lapply(chains0, name_dev_var)))
mod_comb_dev1 <- runjags::combine.mcmc(mcmc.list(lapply(chains1, name_dev_var)))
mod_comb_dev2 <- runjags::combine.mcmc(mcmc.list(lapply(chains2, name_dev_var)))
plot(mcmc.list(mod_comb_dev0, mod_comb_dev1,mod_comb_dev2), density = F)
```

Here are the DIC values of the three models:

```{r}
cat('Int-only:', 
    mean(unlist(lapply(chains0, function(x){x$DIC}))))
```
```{r}
cat('Host traits (main):', 
    mean(unlist(lapply(chains1, function(x){x$DIC}))))
```
```{r}
cat('Host traits (interactions):',
    mean(unlist(lapply(chains2, function(x){x$DIC}))))
```

The comparison of DIC values also shows that the model with host traits is a vast improvement over the intercept only model.

```{r}
cat('Delta DIC, int-only vs host traits main:', 
    mean(unlist(lapply(chains0, function(x){x$DIC}))) - mean(unlist(lapply(chains1, function(x){x$DIC}))), '(higher is better)')
```

The model with host trait interaction is also an improvement.

```{r}
cat('Delta DIC, host traits main vs host traits interactions:', 
    mean(unlist(lapply(chains1, function(x){x$DIC}))) - mean(unlist(lapply(chains2, function(x){x$DIC}))), '(higher is better)')
```

Now we combine the chains for the fixed parameters and variance componenets.

```{r}
# combine the chains
mod_comb_sol0 <- runjags::combine.mcmc(mcmc.list(lapply(chains0, function(x) {x$Sol})))
mod_comb_vcv0 <- runjags::combine.mcmc(mcmc.list(lapply(chains0, function(x) {x$VCV})))
mod_comb_sol1 <- runjags::combine.mcmc(mcmc.list(lapply(chains1, function(x) {x$Sol})))
mod_comb_vcv1 <- runjags::combine.mcmc(mcmc.list(lapply(chains1, function(x) {x$VCV})))
mod_comb_sol2 <- runjags::combine.mcmc(mcmc.list(lapply(chains2, function(x) {x$Sol})))
mod_comb_vcv2 <- runjags::combine.mcmc(mcmc.list(lapply(chains2, function(x) {x$VCV})))
mod_comb_sol2rg <- runjags::combine.mcmc(mcmc.list(lapply(chains2rg, function(x) {x$Sol})))
```

```{r}
# with log-log regression, we need to interpret this coefficient with regards to proportional change. A change in 1 log unit corresponds to a exp(1) or 2.72-fold increase in host mass. We can express this with more intuitive percents. Here is the predicted percent increase in the odds of infection with a 100% (log(2)) increase in worm size.

lcl_effect <- exp(mod_comb_sol1[,'traitlog_end:host_bm'] * log(2)) - 1 # beta x "log of fold change corresponding to 100% incr in host mass"
```

Here is the predicted increase in final worm size with host mass. A doubling of host mass results in a `r round(mean(lcl_effect), 2)*100`% increase in parasite size. This was was much larger than...

```{r}
summary(lcl_effect)
```
```{r}
lcl_effect <- exp(mod_comb_sol1[,'traitlog_start:host_bm'] * log(2)) - 1 # beta x "log of fold change corresponding to 100% incr in host mass"
```

...the increase in initial worm size with host mass, which was `r round(mean(lcl_effect), 2)*100`%.

```{r}
summary(lcl_effect)
```

```{r}
lcl_effect <- exp(mod_comb_sol1[,'traitlog_dt:host_bm'] * log(2)) - 1
```

Development time increased with host mass as well. This slope is not comparable to the parasite size slopes, since devo time had a more limited range than size. Devo time increased `r round(mean(lcl_effect), 2)*100`% with a 100% increase in host mass.

```{r}
summary(lcl_effect)
```

Initial worm size increased more than 10-fold with each unit increase in host trophic level.

```{r}
lcl_effect <- exp(mod_comb_sol1[,'traitlog_start:host_tl'])
summary(lcl_effect)
```

```{r}
lcl_effect <- exp(mod_comb_sol1[,'traitlog_end:endo_ectoendo'])
```

Here is the effect of endothermy on worm final size. Final size was ~`r round(mean(lcl_effect), 0)` fold higher in an endotherm. To properly interpret this, though, host mass and trophic level would need to be standardized.

```{r}
summary(lcl_effect)
```

Here are the parameters for the host traits model with just main effects.

```{r}
s <- data.frame(quant = summary(mod_comb_sol1)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

Here are the parameters for the host traits interaction model.

```{r}
s <- data.frame(quant = summary(mod_comb_sol2)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

Here are the parameters for the host traits interaction model, but excluding stages with devo times less than a week.

```{r}
s <- data.frame(quant = summary(mod_comb_sol2rg)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

Perhaps the best way to gauge model fit is by looking at the R^2^ table.

```{r}
# function to return R2 from models
r2_multiv <- function(m){
  
  sol <- runjags::combine.mcmc(mcmc.list(lapply(m, function(x) {x$Sol}))) # fix param
  vcv <- runjags::combine.mcmc(mcmc.list(lapply(m, function(x) {x$VCV}))) # vc
  X <- m[[1]]$X # design matrix
  num_fe <- m[[1]]$Fixed$nfl # fixed effects
  l <- dim(X)[1]/3 # number of data points in model


  # calculate fixed effects var
  p_all <- as.matrix(X) %*% t(sol[,1:num_fe]) # predicteds for every post sample
  p1 <- p_all[1:l,] # preds for start size
  p2 <- p_all[(l+1):(l*2),] # preds for end size
  p3 <- p_all[(l*2 + 1):(l*3),] # preds for dt
  
  f1 <- apply(p1, MARGIN = 2, FUN = var)
  f2 <- apply(p2, MARGIN = 2, FUN = var)
  f3 <- apply(p3, MARGIN = 2, FUN = var)

  
  # random effects var
  resi <- which(grepl(colnames(vcv), pattern = '.units')) # remove resid variance from variance components
  randVar <- vcv[,-resi]
  ran1 <- randVar[, grepl(colnames(randVar), pattern = 'traitlog_start.')] # RE for start size
  ran1 <- rowSums(ran1)
  ran2 <- randVar[, grepl(colnames(randVar), pattern = 'traitlog_end.')] # RE for start size
  ran2 <- rowSums(ran2)
  ran3 <- randVar[, grepl(colnames(randVar), pattern = 'traitlog_dt.')] # RE for devo time
  ran3 <- rowSums(ran3)
  
  
  # resid var
  res1 <- vcv[, "traitlog_start:traitlog_start.units"]
  res2 <- vcv[, "traitlog_end:traitlog_end.units"]
  res3 <- vcv[, "traitlog_dt:traitlog_dt.units"]
  
  # calculate R2 marginal
  r2m1 <- f1/(f1 + ran1 + res1)
  r2m2 <- f2/(f2 + ran2 + res2)
  r2m3 <- f3/(f3 + ran3 + res3)
  # for output...
  r2m1 <- paste0(round(median(r2m1),3), ' [', 
         round(quantile(r2m1, probs = 0.025), 3), '-', 
         round(quantile(r2m1, probs = 0.975), 3), ']')
  r2m2 <- paste0(round(median(r2m2),3), ' [', 
         round(quantile(r2m2, probs = 0.025), 3), '-', 
         round(quantile(r2m2, probs = 0.975), 3), ']')
  r2m3 <- paste0(round(median(r2m3),3), ' [', 
         round(quantile(r2m3, probs = 0.025), 3), '-', 
         round(quantile(r2m3, probs = 0.975), 3), ']')
  
  # calculate R2 conditional
  r2c1 <- (f1 + ran1)/(f1 + ran1 + res1)
  r2c2 <- (f2 + ran2)/(f2 + ran2 + res2)
  r2c3 <- (f3 + ran3)/(f3 + ran3 + res3)
  r2c1 <- paste0(round(median(r2c1),3), ' [', 
         round(quantile(r2c1, probs = 0.025), 3), '-', 
         round(quantile(r2c1, probs = 0.975), 3), ']')
  r2c2 <- paste0(round(median(r2c2),3), ' [', 
         round(quantile(r2c2, probs = 0.025), 3), '-', 
         round(quantile(r2c2, probs = 0.975), 3), ']')
  r2c3 <- paste0(round(median(r2c3),3), ' [', 
         round(quantile(r2c3, probs = 0.025), 3), '-', 
         round(quantile(r2c3, probs = 0.975), 3), ']')
  

  out_d <- data.frame(trait = c('start_size', 'end_size', 'dt'),
                      r2m = c(r2m1, r2m2, r2m3),
                      r2c = c(r2c1, r2c2, r2c3))
  return(out_d)
}
```

The addition of host trait interactions only explain a few additional percentage points of the variation in worm traits, indicating that the main effects are more important. Host traits accounted for ~50% of the variation in final size and ~30% in starting size. But host traits only explained a few percent of the variation in worm development time. This differed from analyses of unimputed data, where host traits accounted for about 20% of the variation in development time. The likely reason for this was the imputation of development times in paratenic hosts. In similar hosts, parasites can have very different development times depending on whether they treat the host as paratenic or not.

```{r}
m1 <- r2_multiv(chains0)
m2 <- r2_multiv(chains1)
m3 <- r2_multiv(chains2)

m1$model <- 'int-only'
m2$model <- 'host traits, main effects'
m3$model <- 'host traits, second-order interactions'

r2_table <- bind_rows(m1, m2, m3)%>%
  arrange(trait)%>%
  select(model, trait, r2m, r2c)
r2_table
```

We can see this by fitting a model with a fixed effect paratenic term. The marginal R2 value goes way up, because 'paratenic' vs 'not paratenic' explains a lot of the differences in development time.

```{r}
mod_dtf0 <- lme4::lmer(log_dt ~ host_bm + host_tl + endo_ecto +
                       (host_bm + host_tl + endo_ecto)^2 + 
                       (1|Parasite.species) + (1|parasite_genus) + (1|parasite_family) + 
                       (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
             data = filter(dxy, pred == "no"),
             )
mod_dtf1 <- lme4::lmer(log_dt ~ host_bm + host_tl + endo_ecto +
                       (host_bm + host_tl + endo_ecto)^2 + 
                       Facultative +
                       (1|Parasite.species) + (1|parasite_genus) + (1|parasite_family) + 
                       (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
             data = filter(dxy, pred == "no"),
             )
round(MuMIn::r.squaredGLMM(mod_dtf0),3)
round(MuMIn::r.squaredGLMM(mod_dtf1),3)
```

For all traits, there was substantial taxonomic variation. Let's look at the breakdown of taxonomic effects, after accounting for host traits. Here is the plot for initial size...

```{r}
# initial size
resi <- which( grepl(colnames(mod_comb_vcv2), pattern = ".units")) # res var-cov
st_re <- which( grepl(colnames(mod_comb_vcv2), pattern = "traitlog_start")) # var comp for ini size
st_re <- st_re[!st_re %in% resi] # just tax var comp
st_re <- c(st_re, 
           which(grepl(colnames(mod_comb_vcv2), 
                       pattern = "traitlog_start:traitlog_start.units"))) # tax vc + resid vc

tax_eff_st <- rbind(
  quantile(mod_comb_vcv2[,"traitlog_start.Parasite.species"]/
      rowSums(mod_comb_vcv2[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_start.parasite_genus"]/
             rowSums(mod_comb_vcv2[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_start.parasite_family"]/
             rowSums(mod_comb_vcv2[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_start.parasite_order"]/
             rowSums(mod_comb_vcv2[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_start.parasite_class"]/
             rowSums(mod_comb_vcv2[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_start.parasite_phylum"]/
             rowSums(mod_comb_vcv2[,st_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(rowSums(mod_comb_vcv2[,st_re[1:6]])/
             rowSums(mod_comb_vcv2[,st_re]), probs = c(0.025, 0.5, 0.975))
)
tax_eff_st <- data.frame(tax_eff_st)
names(tax_eff_st) <- c('vc.lwr', 'vc.fit', 'vc.upr')
tax_eff_st$t_level <- factor(c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'),
                          levels = c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'))

ggplot(tax_eff_st, aes(x = t_level, y = vc.fit)) +
  geom_pointrange(aes(ymin = vc.lwr, ymax = vc.upr)) +
  labs(x = NULL, y = 'Taxonomic effect on initial size', 
       title = 'Prop. variance explained after accounting for host traits' ) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

...final size...

```{r}
# final size
resi <- which( grepl(colnames(mod_comb_vcv2), pattern = ".units")) # res var-cov
fs_re <- which( grepl(colnames(mod_comb_vcv2), pattern = "traitlog_end")) # var comp for final size
fs_re <- fs_re[!fs_re %in% resi] # just tax var comp
fs_re <- c(fs_re, 
           which(grepl(colnames(mod_comb_vcv2), 
                       pattern = "traitlog_end:traitlog_end.units"))) # tax vc + resid vc

tax_eff_fs <- rbind(
  quantile(mod_comb_vcv2[,"traitlog_end.Parasite.species"]/
      rowSums(mod_comb_vcv2[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_end.parasite_genus"]/
             rowSums(mod_comb_vcv2[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_end.parasite_family"]/
             rowSums(mod_comb_vcv2[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_end.parasite_order"]/
             rowSums(mod_comb_vcv2[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_end.parasite_class"]/
             rowSums(mod_comb_vcv2[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_end.parasite_phylum"]/
             rowSums(mod_comb_vcv2[,fs_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(rowSums(mod_comb_vcv2[,fs_re[1:6]])/
             rowSums(mod_comb_vcv2[,fs_re]), probs = c(0.025, 0.5, 0.975))
)
tax_eff_fs <- data.frame(tax_eff_fs)
names(tax_eff_fs) <- c('vc.lwr', 'vc.fit', 'vc.upr')
tax_eff_fs$t_level <- factor(c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'),
                          levels = c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'))

ggplot(tax_eff_fs, aes(x = t_level, y = vc.fit)) +
  geom_pointrange(aes(ymin = vc.lwr, ymax = vc.upr)) +
  labs(x = NULL, y = 'Taxonomic effect on final size', 
       title = 'Prop. variance explained after accounting for host traits' ) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

...and development time.

```{r}
# devo time
resi <- which( grepl(colnames(mod_comb_vcv2), pattern = ".units")) # res var-cov
dt_re <- which( grepl(colnames(mod_comb_vcv2), pattern = "traitlog_dt")) # var comp for dt
dt_re <- dt_re[!dt_re %in% resi] # just tax var comp
dt_re <- c(dt_re, 
           which(grepl(colnames(mod_comb_vcv2), 
                       pattern = "traitlog_dt:traitlog_dt.units"))) # tax vc + resid vc

tax_eff_dt <- rbind(
  quantile(mod_comb_vcv2[,"traitlog_dt.Parasite.species"]/
      rowSums(mod_comb_vcv2[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_dt.parasite_genus"]/
             rowSums(mod_comb_vcv2[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_dt.parasite_family"]/
             rowSums(mod_comb_vcv2[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_dt.parasite_order"]/
             rowSums(mod_comb_vcv2[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_dt.parasite_class"]/
             rowSums(mod_comb_vcv2[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(mod_comb_vcv2[,"traitlog_dt.parasite_phylum"]/
             rowSums(mod_comb_vcv2[,dt_re]), probs = c(0.025, 0.5, 0.975)),
  quantile(rowSums(mod_comb_vcv2[,dt_re[1:6]])/
             rowSums(mod_comb_vcv2[,dt_re]), probs = c(0.025, 0.5, 0.975))
)
tax_eff_dt <- data.frame(tax_eff_dt)
names(tax_eff_dt) <- c('vc.lwr', 'vc.fit', 'vc.upr')
tax_eff_dt$t_level <- factor(c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'),
                          levels = c('species', 'genus', 'family', 'order', 'class', 'phylum', 'total'))

ggplot(tax_eff_dt, aes(x = t_level, y = vc.fit)) +
  geom_pointrange(aes(ymin = vc.lwr, ymax = vc.upr)) +
  labs(x = NULL, y = 'Taxonomic effect on devo time', 
       title = 'Prop. variance explained after accounting for host traits' ) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

For size variables, there is both a phyla effect (nematodes are smaller) and a order/family effect. Devo time seems to differ more among higher taxonomic groups.

# Panels for Fig 3

Let's now make some plots using the predictions and credible intervals from the model including host trait interactions.

```{r}
# full host trait model
pdx <- chains2[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all <- as.matrix(pdx) %*% t(mod_comb_sol2[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate derived traits (not modeled) like relative growth and relative growth rate from every iteration
p_allrg <- 
  ( p_all[(p_n+1):(p_n*2),] - # end size
     p_all[1:p_n,] ) # start size
p_allrgr <- 
  ( p_all[(p_n+1):(p_n*2),] - # end size
     p_all[1:p_n,] ) / # start size
  ( exp(p_all[(p_n*2 + 1):(p_n*3),])) # devo time



# calculate relative growth rate excluding short devo times
pdx <- chains2rg[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy2$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n2 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2rg[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all2 <- as.matrix(pdx) %*% t(mod_comb_sol2rg[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx


p_allrg2 <- 
  ( p_all2[(p_n2+1):(p_n2*2),] - # end size
     p_all2[1:p_n2,] ) / # start size
  ( exp(p_all2[(p_n2*2 + 1):(p_n2*3),])) # devo time


# predicted means for every iteration for every trait
px <- data.frame(filter(dxy, pred != "no")%>%
                   select(pred, host_bm, host_tl, endo_ecto),
                 log_start_p = p_all[1:p_n,],
                 log_end_p = p_all[(p_n+1):(p_n*2),],
                 log_dt_p = p_all[(p_n*2 + 1):(p_n*3),],
                 log_dt_overaweek = p_all2[(p_n2*2 + 1):(p_n2*3),],
                 rg = p_allrg,
                 rgr = p_allrgr,
                 rgr_overaweek = p_allrg2)

# reshape predicted vals for all iter, calc fit and quantiles
p_all <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, host_bm, host_tl, endo_ecto, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

p_all$group <- 'group'
rm(px,pdx, n, nt, p_i, p_n, num_fe, p_allrg, p_allrgr, p_allrg2)
```

The points in each plot are observed values and the 'best' estimate for imputed values. One could also plot just the observed data. First final size...

```{r}
f2a <- ggplot(dxy,
              aes(x = exp(host_bm), y = imp_biovolume, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(biovolume))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "log_end_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "log_end_p"),
            aes(x = exp(host_bm), y = exp(fit),
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', 
       y = bquote("Final worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(a)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max(dxy$imp_biovolume, na.rm = T))
f2a
# ggsave(f2a, filename = "../../figs/fig2a.png", width = 4, height = 3)
```



```{r}
f2b <- ggplot(dxy,
              aes(x = host_tl, y = imp_biovolume, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(biovolume))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "log_end_p"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "log_end_p"),
            aes(x = host_tl, y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', 
       y = bquote("Final worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(b)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max(dxy$imp_biovolume, na.rm = T))

f2b
```

...then initial size.

```{r}
f2c <- ggplot(dxy,
              aes(x = exp(host_bm), y = imp_initial_biov, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "log_start_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "log_start_p"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', 
       y = bquote("Initial worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(c)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max(dxy$imp_initial_biov, na.rm = T))
f2c
```

```{r}
f2d <- ggplot(dxy,
              aes(x = host_tl, y = imp_initial_biov, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "log_start_p"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "log_start_p"),
            aes(x = host_tl, y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', 
       y = bquote("Initial worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(d)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max(dxy$imp_initial_biov, na.rm = T))
f2d
```

Instead of plotting final and initial size separately, we could plot relative growth, i.e. the difference between final and initial size. It increases with host mass.

```{r}
f2c_rg <- ggplot(dxy,
              aes(x = exp(host_bm), y = exp(log(imp_biovolume) - log(imp_initial_biov)), color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "rg"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "rg"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', 
       y = "Relative growth\n(fold increase in size)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(c)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max( exp(dxy$log_end - dxy$log_start), na.rm = T))
f2c_rg
```

and decreases with trophic level.

```{r}
f2d_rg <- ggplot(dxy,
              aes(x = host_tl, y = exp(log(imp_biovolume) - log(imp_initial_biov)), color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "rg"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "rg"),
            aes(x = host_tl, y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', 
       y = "Relative growth\n(fold increase in size)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(d)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max( exp(dxy$log_end - dxy$log_start), na.rm = T))
f2d_rg
```

Here's how relative growth changed with host size. This is relative growth in a 1 mg host...

```{r}
# 1 mg
filter(p_all, pred == "yes, bm", trait == "rg", endo_ecto == "ecto")%>%
  mutate(diff_from_wanted = abs(host_bm-log(1/1000)))%>%
  arrange(diff_from_wanted)%>%
  ungroup()%>%slice(1)%>%
  select(rg_1mg = fit, rg_1mg_upr = upr, rg_1mg_lwr = lwr)%>%
  mutate(fold_change = exp(rg_1mg), fold_change_lwr = exp(rg_1mg_lwr), fold_change_upr = exp(rg_1mg_upr))
```

...a 1 g host...

```{r}
# 1 g
filter(p_all, pred == "yes, bm", trait == "rg", endo_ecto == "ecto")%>%
  mutate(diff_from_wanted = abs(host_bm-log(1)))%>%
  arrange(diff_from_wanted)%>%
  ungroup()%>%slice(1)%>%
  select(rg_1g = fit, rg_1g_upr = upr, rg_1g_lwr = lwr)%>%
  mutate(fold_change = exp(rg_1g), fold_change_lwr = exp(rg_1g_lwr), fold_change_upr = exp(rg_1g_upr))
```

...and a 10 kg host.

```{r}
# 10 kg
filter(p_all, pred == "yes, bm", trait == "rg", endo_ecto == "ecto")%>%
  mutate(diff_from_wanted = abs(host_bm-log(10*1000)))%>%
  arrange(diff_from_wanted)%>%
  ungroup()%>%slice(1)%>%
  select(rg_10kg = fit, rg_10kg_upr = upr, rg_10kg_lwr = lwr)%>%
  mutate(fold_change = exp(rg_10kg), fold_change_lwr = exp(rg_10kg_lwr), fold_change_upr = exp(rg_10kg_upr))
```

And here is the relative growth difference between an average sized (10 g) endotherm and ectotherm.

```{r}
# 10 g host
filter(p_all, host_tl == 2.7, trait == "rg")%>%
  mutate(diff_from_wanted = abs(host_bm - log(10)))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(rg_10g = fit, rg_10g_lwr = lwr, rg_10g_upr = upr)%>%
  mutate(fold_change = exp(rg_10g), fold_change_lwr = exp(rg_10g_lwr), fold_change_upr = exp(rg_10g_upr))
```

Moving onto development time, the solid and dashed lines represent trends including or excluding short devo times (< 1 week).

```{r}
f2e <- ggplot(dxy,
              aes(x = exp(host_bm), y = imp_avg_dt, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "log_dt_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "log_dt_p"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "log_dt_overaweek"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            linetype = "dashed", size = 1.5) +
  # geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "log_dt_overaweek"),
  #           aes(x = exp(host_bm), y = exp(fit), 
  #               color = endo_ecto, fill = endo_ecto,
  #               ymin = exp(lwr), ymax = exp(upr)),
  #             alpha = 0.2, color = NA) +
  scale_y_log10() + 
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', y = 'Development time (days)') +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(e)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max(dxy$imp_avg_dt, na.rm = T))
f2e
```

```{r}
f2f <- ggplot(dxy,
              aes(x = host_tl, y = imp_avg_dt, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "log_dt_p"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "log_dt_p"),
            aes(x = host_tl, y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "log_dt_overaweek"),
            aes(x = host_tl, y = exp(fit), color = endo_ecto),
            linetype = "dashed", size = 1.5) +
  scale_y_log10() + 
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', y = 'Development time (days)') +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(f)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max(dxy$imp_avg_dt, na.rm = T))

f2f
```

Growth rate is only plotted for species that spent at least 1 week developing.

```{r}
# # plot for rgr including paratenics
# f2g <- ggplot(dxy,
#               aes(x = exp(host_bm), y = (log_end-log_start)/imp_avg_dt, color = endo_ecto)) + 
#   geom_point(alpha = 0.2,
#              aes(shape = is.na(initial_biov)|is.na(biovolume)|is.na(avg_dt))
#              ) + 
#   geom_line(data = filter(p_all, pred == 'yes, bm', trait == "rgr"),
#             aes(x = exp(host_bm), y = fit, color = endo_ecto),
#             size = 1.5) +
#   geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "rgr"),
#             aes(x = exp(host_bm), y = fit, 
#                 color = endo_ecto, fill = endo_ecto,
#                 ymin = lwr, ymax = upr),
#               alpha = 0.2, color = NA) +
#   scale_x_log10() +
#   scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
#   scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
#   scale_shape_manual(values = c(19,4)) +
#   guides(shape = F) +
#   labs(x = 'Host mass (g)', 
#        y = "Relative growth rate\n(~% size increase per day)") +
#   theme(legend.title = element_blank(),
#         panel.grid.minor = element_blank()) +
#   annotate('text', label = "(g)", 
#            x = min(exp(dxy$host_bm), na.rm = T),
#            y = max( (dxy$log_end-dxy$log_start)/dxy$imp_avg_dt, na.rm = T))
# f2g
```
```{r}
f2g <- ggplot(filter(dxy, imp_avg_dt>6),
              aes(x = exp(host_bm), y = (log_end-log_start)/imp_avg_dt, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume)|is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, bm', trait == "rgr_overaweek"),
            aes(x = exp(host_bm), y = fit, color = endo_ecto),
            linetype = "dashed", size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, bm', trait == "rgr_overaweek"),
            aes(x = exp(host_bm), y = fit, 
                color = endo_ecto, fill = endo_ecto,
                ymin = lwr, ymax = upr),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host mass (g)', 
       y = "Relative growth rate\n(~% size increase per day)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(g)", 
           x = min(exp(dxy$host_bm), na.rm = T),
           y = max(filter(dxy, imp_avg_dt>6)$rgr, na.rm = T))
f2g
```

Growth varies little with trophic level. 

```{r}
# # plot for rgr including paratenics
# f2h <- ggplot(dxy,
#               aes(x = host_tl, y = (log_end-log_start)/imp_avg_dt, color = endo_ecto)) + 
#   geom_point(alpha = 0.2,
#              aes(shape = is.na(initial_biov)|is.na(biovolume)|is.na(avg_dt))
#              ) + 
#   geom_line(data = filter(p_all, pred == 'yes, tl', trait == "rgr"),
#             aes(x = host_tl, y = fit, color = endo_ecto),
#             size = 1.5) +
#   geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "rgr"),
#             aes(x = host_tl, y = fit, 
#                 color = endo_ecto, fill = endo_ecto,
#                 ymin = lwr, ymax = upr),
#               alpha = 0.2, color = NA) +
#   scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
#   scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
#   scale_shape_manual(values = c(19,4)) +
#   guides(shape = F) +
#   labs(x = 'Host trophic level', 
#        y = "Relative growth rate\n(~% size increase per day)") +
#   theme(legend.title = element_blank(),
#         panel.grid.minor = element_blank()) +
#   annotate('text', label = "(h)", 
#            x = min(dxy$host_tl, na.rm = T),
#            y = max( (dxy$log_end-dxy$log_start)/dxy$imp_avg_dt, na.rm = T))
# f2h
```
```{r}
f2h <- ggplot(filter(dxy, imp_avg_dt>6),
              aes(x = host_tl, y = (log_end-log_start)/imp_avg_dt, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume)|is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all, pred == 'yes, tl', trait == "rgr"),
            aes(x = host_tl, y = fit, color = endo_ecto),
            linetype = "dashed", size = 1.5) +
  geom_ribbon(data = filter(p_all, pred == 'yes, tl', trait == "rgr"),
            aes(x = host_tl, y = fit, 
                color = endo_ecto, fill = endo_ecto,
                ymin = lwr, ymax = upr),
              alpha = 0.2, color = NA) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  labs(x = 'Host trophic level', 
       y = "Relative growth rate\n(~% size increase per day)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  annotate('text', label = "(h)", 
           x = min(dxy$host_tl, na.rm = T),
           y = max(filter(dxy, imp_avg_dt>6)$rgr, na.rm = T) )
f2h
```

Worms grow slightly faster in endotherms than ectotherms. Here is the difference for an average sized host (10 g).

```{r}
# 10 g host
filter(p_all, host_tl == 2.7, trait == "rgr_overaweek")%>%
  mutate(diff_from_wanted = abs(host_bm - log(10)))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(rgr_10g = fit, rgr_10g_upr = upr, rgr_10g_lwr = lwr)
```

We combined these plots into a single figure.

```{r}
library(cowplot)
```
```{r}
f2a2 <- f2a + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        legend.position = 'none')
f2c2 <- f2c + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        legend.position = c(0.05,0.9),
        legend.justification = c(0,1),
        legend.text = element_text(face = 'bold', size = 10),
        legend.background = element_rect(color = 'black'))
f2e2 <- f2e + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        legend.position = 'none')
f2g2 <- f2g + 
  theme(legend.position = 'none')

f2b2 <- f2b + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        legend.position = 'none')
f2d2 <- f2d + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        legend.position = 'none')
f2f2 <- f2f + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        legend.position = 'none')
f2h2 <- f2h + 
  theme(axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        legend.position = 'none')


f2 <- plot_grid(f2a2, f2b2, f2c2, f2d2, f2e2, f2f2, f2g2, f2h2,
          # labels = 'auto', hjust = -3, label_fontface = 'plain',
          align = 'hv', ncol = 2)
f2dd <- plot_grid(f2e2, f2f2, f2g2, f2h2,
                  align = 'hv', ncol = 2)
rm(f2a2, f2b2, f2c2, f2d2, f2e2, f2f2, f2g2, f2h2)
```
```{r}
title <- ggdraw() +
  draw_label("Imputed",
    fontface = 'bold',
    size = 20
  ) 

f2gif <- plot_grid(title, 
                   f2,
                   ncol = 1, 
                   rel_heights = c(0.1, 1))
```
```{r}
title <- ggdraw() +
  draw_label("Imputed, days",
    fontface = 'bold',
    size = 20
  ) 

f2dd <- plot_grid(title, 
                   f2dd,
                   ncol = 1, 
                   rel_heights = c(0.1, 1))
```

```{r}
ggsave(f2, filename = "../../figs/fig3_imp.png", width = 8, height = 12)
ggsave(f2, filename = "../../figs/fig3_imp.svg", width = 8, height = 12)
# move plots closer together, fix legend pos
ggsave(f2gif, filename = "../../figs/gif_imp_vs_noimp/fig3_imp.png", width = 8, height = 12)
ggsave(f2dd, filename = "../../figs/gif_dd_vs_nodd/fig3_imp.png", width = 8, height = 6)
rm(f2gif, f2dd)
```

# Host trait effects driven by intermediate vs definitive host distinction?

Since definitive hosts are mostly endotherms and intermediate hosts are mostly ectotherms, it is possible that growth differences are exaggerated by limited growth in some intermediate hosts, e.g. in paratenic hosts.  To check this, we re-fit the model with the distinction between intermediate vs definitive host, as well as its interactions with the other host traits.

```{r}
# first filter to just data including fixed predictors
dxy_dh <- filter(dat, !(is.na(imp_avg_dt) & is.na(imp_biovolume) & is.na(imp_initial_biov)))
dxy_dh <- filter(dat, Facultative != 'postcyclic',
              !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
dxy_dh$pred <- 'no'

# then make data that want marginal predicions for
dx_avg <- group_by(dxy_dh, endo_ecto, Def.int)%>%
  summarize(min_bm = min(host_bm, na.rm = T),
            max_bm = max(host_bm, na.rm = T),
            min_tl = min(host_tl, na.rm = T),
            max_tl = max(host_tl, na.rm = T))

nd_bm <- bind_rows( data.frame(endo_ecto = 'ecto', Def.int = "def",
                            host_bm = seq(dx_avg$min_bm[1], dx_avg$max_bm[1], length.out = 50),
                            host_tl = median(dxy_dh$host_tl, na.rm = T),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'ecto', Def.int = "int",
                            host_bm = seq(dx_avg$min_bm[2], dx_avg$max_bm[2], length.out = 50),
                            host_tl = median(dxy_dh$host_tl, na.rm = T),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo', Def.int = "def",
                            host_bm = seq(dx_avg$min_bm[3], dx_avg$max_bm[3], length.out = 50),
                            host_tl = median(dxy_dh$host_tl, na.rm = T),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo', Def.int = "int",
                            host_bm = seq(dx_avg$min_bm[4], dx_avg$max_bm[4], length.out = 50),
                            host_tl = median(dxy_dh$host_tl, na.rm = T),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1])
                 )

nd_tl <- bind_rows( data.frame(endo_ecto = 'ecto', Def.int = "def",
                            host_bm = median(dxy_dh$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[1], dx_avg$max_tl[1], length.out = 50),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'ecto', Def.int = "int",
                            host_bm = median(dxy_dh$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[2], dx_avg$max_tl[2], length.out = 50),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo', Def.int = "def",
                            host_bm = median(dxy_dh$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[3], dx_avg$max_tl[3], length.out = 50),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1]),
                    data.frame(endo_ecto = 'endo', Def.int = "int",
                            host_bm = median(dxy_dh$host_bm, na.rm = T),
                            host_tl = seq(dx_avg$min_tl[4], dx_avg$max_tl[4], length.out = 50),
                            Parasite.species = unique(dxy_dh$Parasite.species)[1],
                            parasite_genus = unique(dxy_dh$parasite_genus)[1],
                            parasite_family = unique(dxy_dh$parasite_family)[1],
                            parasite_order = unique(dxy_dh$parasite_order)[1],
                            parasite_class = unique(dxy_dh$parasite_class)[1],
                            parasite_phylum = unique(dxy_dh$parasite_phylum)[1])
                 )

nd_bm$pred <- 'yes, bm'
nd_tl$pred <- 'yes, tl'

dxy_dh <- bind_rows(dxy_dh, nd_bm, nd_tl)

# observations with at least 1 wk devo on average; better estimate of growth rate?
obs_for_rg <- dxy_dh%>%
  filter(imp_avg_dt>6)%>%
  .$obs

dxy_dh2 <- filter(dxy_dh, obs %in% obs_for_rg | pred != "no")
```



```{r}
chains2_dh = list()
chains2_dhrg = list()

for(i in 1:100){

  iname <- ifelse(i < 10, paste0('00',i), 
                  ifelse(i < 100, paste0('0',i),i))
  fname_p <- paste0('../../data/imputed_stage_level_tables/stage_level_imputed',iname,'.csv')
  
  dat_imp <- read.csv(file = fname_p, header = T)
  
  dat_imp <- mutate(dat_imp, Host_no_fac = factor(Host_no_fac),
                obs = factor(1:length(Parasite.species)))%>%
    mutate(log_end = log(imp_biovolume), log_start = log(imp_initial_biov), 
           log_dt = log(imp_avg_dt), log_dd = log(imp_avg_dd),
           stage_lcl = paste0("lc", lcl_max_fac, "_", Host_no_fac))%>%
    mutate(rg = log_end - log_start, rgr = (log_end - log_start)/imp_avg_dt)%>%
    mutate(host_bm = log(10^(host_bm)))
  
  
  # first filter to just data including fixed predictors
  dxy_imp <- filter(dat_imp, !(is.na(log_start) | is.na(log_end) | is.na(log_dt)))
  dxy_imp <- filter(dxy_imp, Facultative != 'postcyclic',
                !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
  dxy_imp$pred <- 'no'
  
  # then make data that want marginal predicions for
  dx_avg <- group_by(dxy_imp, endo_ecto, Def.int)%>%
    summarize(min_bm = min(host_bm, na.rm = T),
              max_bm = max(host_bm, na.rm = T),
              min_tl = min(host_tl, na.rm = T),
              max_tl = max(host_tl, na.rm = T))
  
  nd_bm <- bind_rows( data.frame(endo_ecto = 'ecto', Def.int = "def",
                              host_bm = seq(dx_avg$min_bm[1], dx_avg$max_bm[1], length.out = 50),
                              host_tl = median(dxy_imp$host_tl, na.rm = T),
                              Parasite.species = unique(dxy_imp$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1]),
                      data.frame(endo_ecto = 'ecto', Def.int = "int",
                              host_bm = seq(dx_avg$min_bm[2], dx_avg$max_bm[2], length.out = 50),
                              host_tl = median(dxy_imp$host_tl, na.rm = T),
                              Parasite.species = unique(dxy_imp$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1]),
                      data.frame(endo_ecto = 'endo', Def.int = "def",
                              host_bm = seq(dx_avg$min_bm[3], dx_avg$max_bm[3], length.out = 50),
                              host_tl = median(dxy_imp$host_tl, na.rm = T),
                              Parasite.species = unique(dxy_imp$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1]),
                      data.frame(endo_ecto = 'endo', Def.int = "int",
                              host_bm = seq(dx_avg$min_bm[4], dx_avg$max_bm[4], length.out = 50),
                              host_tl = median(dxy_imp$host_tl, na.rm = T),
                              Parasite.species = unique(dxy_imp$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1])
                   )
  
  nd_tl <- bind_rows( data.frame(endo_ecto = 'ecto', Def.int = "def",
                              host_bm = median(dxy_imp$host_bm, na.rm = T),
                              host_tl = seq(dx_avg$min_tl[1], dx_avg$max_tl[1], length.out = 50),
                              Parasite.species = unique(dxy_imp$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1]),
                      data.frame(endo_ecto = 'ecto', Def.int = "int",
                              host_bm = median(dxy_imp$host_bm, na.rm = T),
                              host_tl = seq(dx_avg$min_tl[2], dx_avg$max_tl[2], length.out = 50),
                              Parasite.species = unique(dxy_imp$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1]),
                      data.frame(endo_ecto = 'endo', Def.int = "def",
                              host_bm = median(dxy_imp$host_bm, na.rm = T),
                              host_tl = seq(dx_avg$min_tl[3], dx_avg$max_tl[3], length.out = 50),
                              Parasite.species = unique(dxy_imp$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1]),
                      data.frame(endo_ecto = 'endo', Def.int = "int",
                              host_bm = median(dxy_imp$host_bm, na.rm = T),
                              host_tl = seq(dx_avg$min_tl[4], dx_avg$max_tl[4], length.out = 50),
                              Parasite.species = unique(dxy_imp$Parasite.species)[1],
                              parasite_genus = unique(dxy_imp$parasite_genus)[1],
                              parasite_family = unique(dxy_imp$parasite_family)[1],
                              parasite_order = unique(dxy_imp$parasite_order)[1],
                              parasite_class = unique(dxy_imp$parasite_class)[1],
                              parasite_phylum = unique(dxy_imp$parasite_phylum)[1])
                   )
  
  nd_bm$pred <- 'yes, bm'
  nd_tl$pred <- 'yes, tl'
  
  dxy_imp <- bind_rows(dxy_imp, nd_bm, nd_tl)
  dxy_imp2 <- filter(dxy_imp, obs %in% obs_for_rg | pred != "no" )
  
    
  # model with all host trait 2nd order interactions, but just definitive hosts
  chains2_dh[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                               trait:host_bm + trait:host_tl + trait:endo_ecto + trait:Def.int +
                               trait:host_bm:host_tl + trait:host_bm:endo_ecto + trait:host_tl:endo_ecto +
                                 trait:host_bm:Def.int + trait:endo_ecto:Def.int + trait:host_tl:Def.int +
                           trait:host_bm:endo_ecto:Def.int + trait:host_tl:endo_ecto:Def.int, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxy_imp,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
  # model with all host trait 2nd order interactions, but just definitive hosts
  chains2_dhrg[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                               trait:host_bm + trait:host_tl + trait:endo_ecto + trait:Def.int +
                               trait:host_bm:host_tl + trait:host_bm:endo_ecto + trait:host_tl:endo_ecto +
                             trait:host_bm:Def.int + trait:endo_ecto:Def.int + trait:host_tl:Def.int +
                             trait:host_bm:endo_ecto:Def.int + trait:host_tl:endo_ecto:Def.int, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxy_imp2,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)

  # extract starting values for next iteration
  s <- round(runif(1, min = 1, max = dim(chains2_dh[[i]]$VCV)[1]),0)
  startc <- list(G = list(G1 = diag(round(chains2_dh[[i]]$VCV[s,1:3],6)),
                         G2 = diag(round(chains2_dh[[i]]$VCV[s,4:6],6)),
                         G3 = diag(round(chains2_dh[[i]]$VCV[s,7:9],6)),
                         G4 = diag(round(chains2_dh[[i]]$VCV[s,10:12],6)),
                         G5 = diag(round(chains2_dh[[i]]$VCV[s,13:15],6)),
                         G6 = diag(round(chains2_dh[[i]]$VCV[s,16:18],6))
                        ),
                R = matrix(round(chains2_dh[[i]]$VCV[s,19:27],6), nrow = 3, ncol = 3)
               )
  
  print(paste('iteration', i, 'finished'))
}
```
```{r}
# combine chains
mod_comb_sol2_dh <- runjags::combine.mcmc(mcmc.list(lapply(chains2_dh, function(x) {x$Sol})))
mod_comb_sol2_dhrg <- runjags::combine.mcmc(mcmc.list(lapply(chains2_dhrg, function(x) {x$Sol})))
```

The resulting model did not explain much more variation in final size, but it did account for some additional variation in start size and devo time. It clearly accounted for variation in devo time due to paratenesis.

```{r}
m1 <- r2_multiv(chains2)
m2 <- r2_multiv(chains2_dh)

m1$model <- 'host traits, second-order interactions'
m2$model <- 'host traits + def vs int interactions'

r2_table <- bind_rows(m1, m2)%>%
  arrange(trait)%>%
  select(model, trait, r2m, r2c)
r2_table
```

What about the predictions for growth in definitive hosts?

```{r}
# full host trait model
pdx <- chains2_dh[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy_dh$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2_dh[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all_dh <- as.matrix(pdx) %*% t(mod_comb_sol2_dh[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate derived traits (not modeled) like relative growth and relative growth rate from every iteration
p_allrg <- 
  ( p_all_dh[(p_n+1):(p_n*2),] - # end size
     p_all_dh[1:p_n,] ) # start size
p_allrgr <- 
  ( p_all_dh[(p_n+1):(p_n*2),] - # end size
     p_all_dh[1:p_n,] ) / # start size
  ( exp(p_all_dh[(p_n*2 + 1):(p_n*3),])) # devo time


# calculate relative growth rate excluding short devo times
pdx <- chains2_dhrg[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxy_dh2$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n2 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains2_dhrg[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_all2 <- as.matrix(pdx) %*% t(mod_comb_sol2_dhrg[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx


p_allrg2 <- 
  ( p_all2[(p_n2+1):(p_n2*2),] - # end size
     p_all2[1:p_n2,] ) / # start size
  ( exp(p_all2[(p_n2*2 + 1):(p_n2*3),])) # devo time


# predicted means for every iteration for every trait
px <- data.frame(filter(dxy_dh, pred != "no")%>%
                   select(pred, host_bm, host_tl, Def.int, endo_ecto),
                 log_start_p = p_all_dh[1:p_n,],
                 log_end_p = p_all_dh[(p_n+1):(p_n*2),],
                 log_dt_p = p_all_dh[(p_n*2 + 1):(p_n*3),],
                 log_dt_overaweek = p_all2[(p_n2*2 + 1):(p_n2*3),],
                 rg = p_allrg,
                 rgr = p_allrgr,
                 rgr_overaweek = p_allrg2)

# reshape predicted vals for all iter, calc fit and quantiles
p_all_dh <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  group_by(pred, host_bm, host_tl, endo_ecto, Def.int, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

p_all_dh$group <- 'group'
rm(px,pdx, n, nt, p_i, p_n, num_fe, p_allrg, p_allrgr, p_allrg2)
```

Here is the predicted growth in endo vs ectotherm for an average sized definitive host. It is higher for endotherms, but the CIs are wide and nearly overlapping.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "def")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm", 
       Def.int == "def", trait == "rg")%>%
  mutate(diff_from_wanted = abs(host_bm - dx_dh$median_bm))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rg_avg = fit, rg_avg_lwr = lwr, rg_avg_upr = upr)%>%
  mutate(fold_change = exp(rg_avg), fold_change_lwr = exp(rg_avg_lwr), fold_change_upr = exp(rg_avg_upr))
```

```{r}
# the predicted means and actual means match nicely - taxonomic effects are not changing them much
# filter(dxy, pred == "no", Def.int == "def")%>%
#   group_by(endo_ecto)%>%
#   summarize(n = sum(!is.na(rg)), rg = median(rg, na.rm = T))
```

Here is the predicted relative growth in 10g intermediate host. We chose 10g because this is whether endotherm and ectotherm body sizes overlap; the average endotherm intermediate host is much bigger than the average ectotherm intermediate host. The CI for endotherms is very wide, because there were few endotherm intermediate hosts. Consequently, the CIs overlap and it is not clear that endothermy affects total growth in intermediate hosts.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "int")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm",
       Def.int == "int", trait == "rg")%>%
  mutate(diff_from_wanted = abs(host_bm - log(10)))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rg_avg = fit, rg_avg_lwr = lwr, rg_avg_upr = upr)%>%
  mutate(fold_change = exp(rg_avg), fold_change_lwr = exp(rg_avg_lwr), fold_change_upr = exp(rg_avg_upr))
```
Here is growth in an average-sized ectotherm intermediate host. The predicted growth was than in an average-sized ectotherm definitive host, though not significantly so.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "int", endo_ecto == "ecto")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm", endo_ecto == "ecto",
       Def.int == "int", trait == "rg")%>%
  mutate(diff_from_wanted = abs(host_bm - dx_dh$median_bm))%>%
  arrange(diff_from_wanted)%>%
  ungroup()%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rg_avg = fit, rg_avg_lwr = lwr, rg_avg_upr = upr)%>%
  mutate(fold_change = exp(rg_avg), fold_change_lwr = exp(rg_avg_lwr), fold_change_upr = exp(rg_avg_upr))
```

Growth *rates* are faster in endotherm definitive hosts.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "def")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm", 
       Def.int == "def", trait == "rgr_overaweek")%>%
  mutate(diff_from_wanted = abs(host_bm - dx_dh$median_bm))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rgr_avg = fit, rgr_avg_lwr = lwr, rgr_avg_upr = upr)
```
We can't make the same comparison in intermediate hosts, given the lack of data.

```{r}
dx_dh <- filter(dxy_dh, pred == "no", Def.int == "int")%>%
  summarize(median_bm = median(host_bm, na.rm = T),
            median_tl = median(host_tl, na.rm = T))

filter(p_all_dh, pred == "yes, bm",
       Def.int == "int", trait == "rgr_overaweek")%>%
  mutate(diff_from_wanted = abs(host_bm - log(10)))%>%
  arrange(diff_from_wanted)%>%
  group_by(endo_ecto)%>%slice(1)%>%
  select(host_bm, host_tl, Def.int, rgr_avg = fit, rgr_avg_lwr = lwr, rgr_avg_upr = upr)
```

Let's plot the model output. Intermediate vs definitive hosts are distinguished by dotted and solid lines, respectively.

End size tends to be a bit larger in definitive hosts than comparable intermediate hosts, especially if they are endotherms.

```{r}
f2a_dh <- ggplot(dxy_dh,
              aes(x = exp(host_bm), y = imp_biovolume, color = endo_ecto, linetype = Def.int)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(biovolume))
             ) + 
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_end_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_end_p"),
            aes(x = exp(host_bm), y = exp(fit),
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)', 
       y = bquote("Final worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2a_dh
```
Starting size is a little bit lower for endotherms than for ectotherms, but the difference is small.

```{r}
f2c_dh <- ggplot(dxy_dh,
              aes(x = exp(host_bm), y = imp_initial_biov, color = endo_ecto, linetype = Def.int)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov))
             ) + 
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_start_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_start_p"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)', 
       y = bquote("Initial worm size "(~mm^3))) +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2c_dh
```
The combination of smaller initial sizes and larger final sizes indicates more growth in endothermic definitive hosts.

```{r}
f2c_rg_dh <- ggplot(dxy,
              aes(x = exp(host_bm), y = exp(log(imp_biovolume) - log(imp_initial_biov)), 
                  color = endo_ecto, linetype = Def.int)) +
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume))
             ) +
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "rg"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "rg"),
            aes(x = exp(host_bm), y = exp(fit),
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)',
       y = "Relative growth\n(fold increase in size)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2c_rg_dh
```
However, although they growth more in endotherm definitive hosts, the average prepatent period is shorter. The large CI for endotherm intermediate hosts reflects little data.

```{r}
f2e_dh <- ggplot(filter(dxy, imp_avg_dt>6),
              aes(x = exp(host_bm), y = imp_avg_dt, color = endo_ecto,
                  linetype = Def.int)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_dt_p"),
            aes(x = exp(host_bm), y = exp(fit), color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "log_dt_p"),
            aes(x = exp(host_bm), y = exp(fit), 
                color = endo_ecto, fill = endo_ecto,
                ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.2, color = NA) +
  scale_y_log10() + 
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)', y = 'Devo time (days)') +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2e_dh
```
In endothermic definitive hosts, worms grow more in a shorter period, resulting in faster growth.

```{r}
f2g_dh <- ggplot(filter(dxy, imp_avg_dt>6),
              aes(x = exp(host_bm), y = (log_end-log_start)/imp_avg_dt, 
                  linetype = Def.int, color = endo_ecto)) + 
  geom_point(alpha = 0.4, size = 0.65,
             aes(shape = is.na(initial_biov)|is.na(biovolume)|is.na(avg_dt))
             ) + 
  geom_line(data = filter(p_all_dh, pred == 'yes, bm', trait == "rgr_overaweek"),
            aes(x = exp(host_bm), y = fit, color = endo_ecto),
            size = 1.5) +
  geom_ribbon(data = filter(p_all_dh, pred == 'yes, bm', trait == "rgr_overaweek"),
            aes(x = exp(host_bm), y = fit, 
                color = endo_ecto, fill = endo_ecto,
                ymin = lwr, ymax = upr),
              alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_fill_brewer(type = 'qual', palette = 'Set1', direction = -1, labels = c("Ectotherm", "Endotherm")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F, color = F, fill = F, linetype = F) +
  labs(x = 'Host mass (g)', 
       y = "Relative growth rate\n(~% size increase per day)") +
  theme(legend.title = element_blank(),
        panel.grid.minor = element_blank())
f2g_dh
```

Overall, adding a definitive vs intermediate host distinction does not change the results much. Worms still grow more in endotherm than ectotherm hosts. However, when we restrict the data to just definitive hosts and refit the model, then the estimated difference is much smaller (and marginally significant).

```{r}
library(lme4)
```
```{r}
l0 <- lmer(rg ~ host_bm_c + host_tl_c + host_bm_c:host_tl_c + (1|parasite_genus) + (1|parasite_family) +
             (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
           data = filter(dxy, Def.int == "def")%>%
             mutate(host_bm_c = host_bm - mean(dxy$host_bm, na.rm = T),
                    host_tl_c = host_tl - mean(dxy$host_tl, na.rm = T))
           )
l1 <- update(l0, . ~ . + endo_ecto)
# anova(l0,l1)
fe <- fixef(l1)
fe <- fe[c("(Intercept)","endo_ectoendo")]
fe<-c(fe[1], fe[1]+fe[2])

cat("Fold change, ecto vs endo def host:", round(exp(fe),0))

```

I think this is caused by larger taxonomic effects. When restricted to a single stage (def host), the model considers more of the differences to be taxonomic. That is, a taxon may not grow consistently more (or less) than expected from host size across the full life cycle. But when restricted to just one stage, more variation is considered taxonomic.

The differences between definitive and intermediate hosts are also part of the next modeling step: adding life stage to the model.

# Overachieving worms?

Now that we have estimated the relationship between host and parasite traits, we can ask whether certain parasite life stages grow faster or larger than expected. In particular, we are interested in the possibility that parasites with long cycles overperform at particular stages as a way to compensate. A quick way to test this is to add parasite stage into models with the host traits. Does stage account for additional variation beyond that accounted for by host traits? Let's do a few quick likelihood ratio tests with our "best" imputed datasets.

Stage explains additional variation in final size...

```{r}
library(lme4)
```

```{r}
modfs1.1 <- lmer(log_end ~ 1 + host_bm + host_tl + endo_ecto +
                 (host_bm + host_tl + endo_ecto)^2 +
                 (1|Parasite.species) + (1|parasite_genus) + (1|parasite_family) + 
                 (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
             data = filter(dxy, pred == "no"))
modfs3.1 <- update(modfs1.1, . ~ . + stage_lcl) # 2nd-order interaction effects
anova(modfs1.1, modfs3.1)
```

and initial size...

```{r}
modis1.1 <- lmer(log_start ~ 1 + host_bm + host_tl + endo_ecto +
                 (host_bm + host_tl + endo_ecto)^2 +
                 (1|Parasite.species) + (1|parasite_genus) + (1|parasite_family) + 
                 (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
             data = filter(dxy, pred == "no"))
modis3.1 <- update(modis1.1, . ~ . + stage_lcl) # 2nd-order interaction effects
anova(modis1.1, modis3.1)
```

and devo time (different from unimputed analysis, due to paratenics).

```{r}
moddt1.1 <- lmer(log_dt ~ 1 + host_bm + host_tl + endo_ecto +
                 (host_bm + host_tl + endo_ecto)^2 +
                 (1|Parasite.species) + (1|parasite_genus) + (1|parasite_family) + 
                 (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum),
             data = filter(dxy, pred == "no"))
moddt3.1 <- update(moddt1.1, . ~ . + stage_lcl) # 2nd-order interaction effects
anova(moddt1.1, moddt3.1)
```

So, parasite life stages seem to explain additional variation, even after accounting for host traits. Now let's again fit multivariate models and then we'll compare stage means predicted from just host traits or just stages, both adjusted for taxonomic effects. When the predictions diverge it suggests parasites grow more (or less) in particular stages than expected from their hosts.

I need to tweek the host-trait model compared to above. I want to get predicted values for each stage, and stages do not infect either endotherms or ectotherms. Rather, some proportion of species infect endotherms or ectotherms. Therefore, I replaced endothermy as a category with endothermy as a proportion in the model, so that I can predict stage means for a given level of endothermy. This does not change the number of model parameters.

```{r}
# first filter to just data including fixed predictors
dxyz <- filter(dat, !(is.na(imp_avg_dt) | is.na(imp_biovolume) | is.na(imp_initial_biov)))
dxyz <- filter(dxyz, Facultative != 'postcyclic',
              !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
dxyz$pred <- 'no'

# Calculate cumulative devo time
# spp where full dt not available, because partial life cycle
nspp <- dxyz%>%
  group_by(Parasite.species)%>%
  summarise(n = n(), lcl = max(lcl_max))%>%
  filter(n != lcl)%>%
  .$Parasite.species
nspp <- unique(nspp)
# id spp without complete dt data or paratenic stage
incomp_spp <- dxyz%>%
  filter(is.na(avg_dt), is_paratenic != 1)%>%
  select(Parasite.species)%>%
  .$Parasite.species
incomp_spp <- unique( incomp_spp )

# make sp level df with cum dt
dxyz <- dxyz%>%
  group_by(Parasite.species)%>%
  mutate(cum_dt = if_else(!Parasite.species %in% nspp, cumsum(imp_avg_dt), NA_real_),
         cum_dt_ni = if_else(!Parasite.species %in% incomp_spp, cumsum(imp_avg_dt), NA_real_))%>%
  mutate(log_cumdt = log(cum_dt))%>%
  ungroup()

# then make data that want marginal predicions for, first for just host traits
nd_stage <- group_by(dxyz, Host_no_fac, lcl_max_fac, stage_lcl)%>%
  summarize(host_bm = mean(host_bm, na.rm = T),
            host_tl = mean(host_tl, na.rm = T),
            prop_endo = sum(endo_ecto == 'endo')/sum(!is.na(endo_ecto)))
nd_stage$Parasite.species <- unique(dxy$Parasite.species)[1]
nd_stage$parasite_genus <- unique(dxy$parasite_genus)[1]
nd_stage$parasite_family <- unique(dxy$parasite_family)[1]
nd_stage$parasite_order <- unique(dxy$parasite_order)[1]
nd_stage$parasite_class <- unique(dxy$parasite_class)[1]
nd_stage$parasite_phylum <- unique(dxy$parasite_phylum)[1]

nd_stage$pred <- 'yes, host traits'

dxyy <- dxyz # make same df, but for stage-only model

dxyz <- bind_rows(dxyz, nd_stage)

nd_stage$pred <- 'yes, stage'

dxyy <- bind_rows(dxyy, nd_stage)

# restrict to observations where a week of growth
dxyz2 <- filter(dxyz, obs %in% obs_for_rg | pred != "no")
dxyy2 <- filter(dxyy, obs %in% obs_for_rg | pred != "no")

obs_for_cdt <- dxyz%>%
  filter(!is.na(cum_dt))%>%
  .$obs

dxyz3 <- filter(dxyz, obs %in% obs_for_cdt | pred != "no")
dxyy3 <- filter(dxyy, obs %in% obs_for_cdt | pred != "no")
```

I also fit the same models with cumulative development time instead of stage development time. When we summed mean developmental times across stages within a life cycle length (e.g. devo time in first host and devo time in second host), mean cumulative devo times were lower than the observed values. One reason for this is that we removed species with partial life cycles (e.g. 2 of 3 hosts known). Several of these species had imputed values for their paratenic stages, but not earlier ones, resulting in cumulative development being too low. Additionally, summing stage means underestimated total development time, because mean development times are negatively correlated across stages (i.e. if you grow a lot now, there is less need to grow later).

```{r}
# # cum devo time too low
# filter(dxy, pred == "no")%>%
#   select(Parasite.species, Host_no_fac, lcl_max_fac, avg_dt, imp_avg_dt)%>%
#   mutate(removed = Parasite.species %in% nspp)%>%
#   group_by(Parasite.species)%>%
#   mutate(cum_dt = cumsum(imp_avg_dt))%>%
#   ggplot(., aes(x = Host_no_fac, y = cum_dt, color = removed)) +
#   geom_boxplot(outlier.color = NA) +
#   geom_point(alpha = 0.2, position = position_jitterdodge(jitter.width = 0.3)) +
#   scale_y_log10() +
#   facet_grid(~lcl_max_fac, space = "free_x", scales = "free_x",
#              labeller = labeller(lcl_max_fac = lc_labs))
```

I fit both models with the same imputation approach as above: loop through imputed datasets, fit model, sample post dist, repeat with next imputed dataset.

```{r}
prior <- list(R = list(V = diag(3)/6, n = 2),
              G = list(G1 = list(V = diag(3)/6, n = 2),
                       G2 = list(V = diag(3)/6, n = 2),
                       G3 = list(V = diag(3)/6, n = 2),                       
                       G4 = list(V = diag(3)/6, n = 2),
                       G5 = list(V = diag(3)/6, n = 2),
                       G6 = list(V = diag(3)/6, n = 2)
                        )
               )
startc <- list(G = list(G1 = diag(3)/6,
                        G2 = diag(3)/6,
                        G3 = diag(3)/6,
                        G4 = diag(3)/6,
                        G5 = diag(3)/6,
                        G6 = diag(3)/6),
              R = diag(3)/6
              )
```
```{r}
chains3.0 = list()
chains3.0rg = list()
chains3.1 = list()
chains3.1rg = list()
chains3.2 = list()
chains4 = list()
chains4.1 = list()

for(i in 1:100){
  iname <- ifelse(i < 10, paste0('00',i), 
                  ifelse(i < 100, paste0('0',i),i))
  fname_p <- paste0('../../data/imputed_stage_level_tables/stage_level_imputed',iname,'.csv')
  
  dat_imp <- read.csv(file = fname_p, header = T)
  
  dat_imp <- mutate(dat_imp, Host_no_fac = factor(Host_no_fac),
                obs = factor(1:length(Parasite.species)))%>%
    mutate(log_end = log(imp_biovolume), log_start = log(imp_initial_biov), 
           log_dt = log(imp_avg_dt), log_dd = log(imp_avg_dd),
           stage_lcl = paste0("lc", lcl_max_fac, "_", Host_no_fac))%>%
    mutate(rg = log_end - log_start, rgr = (log_end - log_start)/imp_avg_dt)%>%
    mutate(host_bm = log(10^(host_bm)))
  
  # first filter to just data including fixed predictors
  dxyz_imp <- filter(dat_imp, !(is.na(imp_avg_dt) | is.na(imp_biovolume) | is.na(imp_initial_biov)))
  dxyz_imp <- filter(dxyz_imp, Facultative != 'postcyclic',
                !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
  dxyz_imp$pred <- 'no'
  # make sp level df with cum dt
  dxyz_imp <- dxyz_imp%>%
    group_by(Parasite.species)%>%
    mutate(cum_dt = if_else(!Parasite.species %in% nspp, cumsum(imp_avg_dt), NA_real_),
           cum_dt_ni = if_else(!Parasite.species %in% incomp_spp, cumsum(imp_avg_dt), NA_real_))%>%
    mutate(log_cumdt = log(cum_dt))%>%
    ungroup()
  
  # then make data that want marginal predicions for, first for just host traits
  nd_stage <- group_by(dxyz_imp, Host_no_fac, lcl_max_fac, stage_lcl)%>%
    summarize(host_bm = mean(host_bm, na.rm = T),
              host_tl = mean(host_tl, na.rm = T),
              prop_endo = sum(endo_ecto == 'endo')/sum(!is.na(endo_ecto)))
  nd_stage$Parasite.species <- unique(dxy$Parasite.species)[1]
  nd_stage$parasite_genus <- unique(dxy$parasite_genus)[1]
  nd_stage$parasite_family <- unique(dxy$parasite_family)[1]
  nd_stage$parasite_order <- unique(dxy$parasite_order)[1]
  nd_stage$parasite_class <- unique(dxy$parasite_class)[1]
  nd_stage$parasite_phylum <- unique(dxy$parasite_phylum)[1]
  
  nd_stage$pred <- 'yes, host traits'
  
  dxyy_imp <- dxyz_imp # make same df, but for stage-only model
  
  dxyz_imp <- bind_rows(dxyz_imp, nd_stage)
  
  nd_stage$pred <- 'yes, stage'
  
  dxyy_imp <- bind_rows(dxyy_imp, nd_stage)
  
  dxyz_imp2 <- filter(dxyz_imp, obs %in% obs_for_rg | pred != "no")
  dxyy_imp2 <- filter(dxyy_imp, obs %in% obs_for_rg | pred != "no")
  dxyz_imp3 <- filter(dxyz_imp, obs %in% obs_for_cdt | pred != "no")
  dxyy_imp3 <- filter(dxyy_imp, obs %in% obs_for_cdt | pred != "no")
  dxyz_imp <- as.data.frame(dxyz_imp)
  dxyy_imp <- as.data.frame(dxyy_imp)
  dxyz_imp2 <- as.data.frame(dxyz_imp2)
  dxyy_imp2 <- as.data.frame(dxyy_imp2)
  dxyz_imp3 <- as.data.frame(dxyz_imp3)
  dxyy_imp3 <- as.data.frame(dxyy_imp3)
  
  # model with just host traits
  chains3.0[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                             trait:host_bm + trait:host_tl + trait:prop_endo +
                             trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxyz_imp,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
  # host traits model, but just with growing stages
  chains3.0rg[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                             trait:host_bm + trait:host_tl + trait:prop_endo +
                             trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxyz_imp2,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
  # model with just stage means
  chains3.1[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                             trait:stage_lcl, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxyy_imp,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
  chains3.1rg[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                             trait:stage_lcl, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxyy_imp2,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
  # model with stage means and host traits
  chains3.2[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                             trait:host_bm + trait:host_tl + trait:prop_endo +
                             trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo +
                               trait:stage_lcl, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxyz_imp,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
  # model with cum dt instead of dt, stages
  chains4[[i]] <- MCMCglmm(cbind(log_start, log_end, log_cumdt) ~ trait-1 + 
                             trait:stage_lcl, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxyy_imp3,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)
  # model with cum dt instead of dt, host traits
  chains4.1[[i]] <- MCMCglmm(cbind(log_start, log_end, log_cumdt) ~ trait-1 + 
                             trait:host_bm + trait:host_tl + trait:prop_endo +
                             trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo, 
                          random = ~ idh(trait):Parasite.species +
                            idh(trait):parasite_genus +
                            idh(trait):parasite_family + 
                            idh(trait):parasite_order + 
                            idh(trait):parasite_class + 
                            idh(trait):parasite_phylum, # taxonomic tree as random effect
                          rcov = ~us(trait):units, # residual var-covar unstructured
                          prior = prior,
                          start = startc,
                          nitt = 800, thin = 30, burnin = 500,
                          data = dxyz_imp3,
                          family = c("gaussian", "gaussian", "gaussian"), pr=F, 
                          verbose = F)


  # extract starting values for next iteration
  s <- round(runif(1, min = 1, max = dim(chains3.1[[i]]$VCV)[1]),0)
  startc <- list(G = list(G1 = diag(round(chains3.1[[i]]$VCV[s,1:3],6)),
                         G2 = diag(round(chains3.1[[i]]$VCV[s,4:6],6)),
                         G3 = diag(round(chains3.1[[i]]$VCV[s,7:9],6)),
                         G4 = diag(round(chains3.1[[i]]$VCV[s,10:12],6)),
                         G5 = diag(round(chains3.1[[i]]$VCV[s,13:15],6)),
                         G6 = diag(round(chains3.1[[i]]$VCV[s,16:18],6))
                        ),
                R = matrix(round(chains3.1[[i]]$VCV[s,19:27],6), nrow = 3, ncol = 3)
               )
  
  print(paste('iteration', i, 'finished'))
}
```

```{r}
# combine chains
mod_comb_sol3.0 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.0, function(x) {x$Sol})))
mod_comb_vcv3.0 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.0, function(x) {x$VCV})))
mod_comb_sol3.0rg <- runjags::combine.mcmc(mcmc.list(lapply(chains3.0rg, function(x) {x$Sol})))
mod_comb_sol3.1 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.1, function(x) {x$Sol})))
mod_comb_vcv3.1 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.1, function(x) {x$VCV})))
mod_comb_sol3.1rg <- runjags::combine.mcmc(mcmc.list(lapply(chains3.1rg, function(x) {x$Sol})))
mod_comb_sol3.2 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.2, function(x) {x$Sol})))
mod_comb_vcv3.2 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.2, function(x) {x$VCV})))
mod_comb_sol4 <- runjags::combine.mcmc(mcmc.list(lapply(chains4, function(x) {x$Sol})))
mod_comb_sol4.1 <- runjags::combine.mcmc(mcmc.list(lapply(chains4.1, function(x) {x$Sol})))
```

The deviance is lower for the life-stage model (red) compared to the host-traits model (black). Deviance goes down even further with both host traits and parasite stages in the model (green)

```{r}
name_dev_var <- function(x){
  dev <- x$Deviance
  dim(dev) <- c(length(dev),1)
  dimnames(dev) <- list(NULL, 'deviance')
  return(dev)
}
mod_comb_dev3.0 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.0, name_dev_var)))
mod_comb_dev3.1 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.1, name_dev_var)))
mod_comb_dev3.2 <- runjags::combine.mcmc(mcmc.list(lapply(chains3.2, name_dev_var)))
plot(mcmc.list(mod_comb_dev3.0, mod_comb_dev3.1, mod_comb_dev3.2), density = F)
```

Here are the DIC values of the three models:

```{r}
cat('Host traits only:', 
    mean(unlist(lapply(chains3.0, function(x){x$DIC}))))
```
```{r}
cat('Stages only:', 
    mean(unlist(lapply(chains3.1, function(x){x$DIC}))))
```
```{r}
cat('Host traits and stages:',
    mean(unlist(lapply(chains3.2, function(x){x$DIC}))))
```

The stage model is clearly better than the host traits model.

```{r}
cat('Delta DIC, host traits only vs life stage only:', 
    mean(unlist(lapply(chains3.0, function(x){x$DIC}))) - mean(unlist(lapply(chains3.1, function(x){x$DIC}))), '(higher is better)')
```

Both together is an even better model, suggesting that host traits explain variation within stages (e.g. worm size may covary with host size at a given stage).

```{r}
cat('Delta DIC, stage only vs stage and host traits:', 
    mean(unlist(lapply(chains3.1, function(x){x$DIC}))) - mean(unlist(lapply(chains3.2, function(x){x$DIC}))), '(higher is better)')
```

Here are the model parameters and credible intervals for the stage-only model:

```{r}
s <- data.frame(quant = summary(mod_comb_sol3.1)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

Here is a comparison of final worm size in the definitive host...

```{r}
sx <- s[c("traitlog_end", "traitlog_end:stage_lcllc2_2", "traitlog_end:stage_lcllc3_3",  
          "traitlog_end:stage_lcllc3+_4"), "quant.50."]
sx <- data.frame(lcl = 1:4,
                 final_ws_avg = c(sx[1],
                                         sx[1]+sx[2],
                                         sx[1]+sx[3],
                                         sx[1]+sx[4]))
sx <- mutate(sx, prev_ws_avg = lag(final_ws_avg))%>%
  mutate(ord_mag_change = final_ws_avg - prev_ws_avg)%>%
  mutate(untransformed_mass = exp(final_ws_avg))%>%
  mutate(nh = lag(untransformed_mass))%>%
  mutate(fold_change = untransformed_mass/nh, 
         perc_increase = ((untransformed_mass-nh)/nh) * 100)
sx <- select(sx, lcl, final_ws_avg, untransformed_mass, ord_mag_change, fold_change, perc_increase)
sx
```

...it does not increase as much as initial size in definitive host: 

```{r}
sx <- s[c("traitlog_start", "traitlog_start:stage_lcllc2_2", "traitlog_start:stage_lcllc3_3", 
          "traitlog_start:stage_lcllc3+_4"), "quant.50."]
sx <- data.frame(lcl = 1:4,
                 initial_ws_avg = c(sx[1],
                                         sx[1]+sx[2],
                                         sx[1]+sx[3],
                                         sx[1]+sx[4]))
sx <- mutate(sx, prev_ws_avg = lag(initial_ws_avg))%>%
  mutate(ord_mag_change = initial_ws_avg - prev_ws_avg)%>%
  mutate(untransformed_mass = exp(initial_ws_avg))%>%
  mutate(nh = lag(untransformed_mass))%>%
  mutate(fold_change = untransformed_mass/nh, 
         perc_increase = ((untransformed_mass-nh)/nh) * 100)
sx <- select(sx, lcl, initial_ws_avg, untransformed_mass, ord_mag_change, fold_change, perc_increase)
sx
rm(sx)
```

And here are the parameters for the stage and host traits model:

```{r}
s <- data.frame(quant = summary(mod_comb_sol3.2)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%arrange(param)
```

In the R^2^ table, the stages model explains more variation for initial size and devo time, but not end size. The joint stage and host traits model does not explain that much more variation in life history than stages alone.

```{r}
m1 <- r2_multiv(chains3.0)
m2 <- r2_multiv(chains3.1)
m3 <- r2_multiv(chains3.2)

m1$model <- 'host traits'
m2$model <- 'parasite stages'
m3$model <- 'host traits & parasite stages'

r2_table <- bind_rows(m1, m2, m3)%>%
  arrange(trait)%>%
  select(model, trait, r2m, r2c)
r2_table
```

Now let's extract the predicted marginal means and credible intervals for each parasite life stage from these two models.

```{r}
# predicted and CI from model with all stages
pdx <- chains3.1[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyy$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains3.1[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_stg <- as.matrix(pdx) %*% t(mod_comb_sol3.1[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth from every iteration
p_stgrg <- 
  ( p_stg[(p_n+1):(p_n*2),] - # end size
     p_stg[1:p_n,] ) # start size


# predicted and CI from model excluding stages that grow little
pdx <- chains3.1rg[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyy2$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n2 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains3.1rg[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_stg2 <- as.matrix(pdx) %*% t(mod_comb_sol3.1rg[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth rate from every iteration
p_stgrgr <- 
  ( p_stg2[(p_n2+1):(p_n2*2),] - # end size
     p_stg2[1:p_n2,] ) / # start size
  (exp(p_stg2[(p_n2*2 + 1):(p_n2*3),])) # devo time

# predicted and CI from cumulative dt model
pdx <- chains4[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyy3$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n3 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains4[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_stg3 <- as.matrix(pdx) %*% t(mod_comb_sol4[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

p_cdt <- (p_stg3[(p_n3*2 + 1):(p_n3*3),]) # cum dt

# predicted means for every iteration for every trait
px <- data.frame(filter(dxyy, pred != "no")%>%
                   select(pred, Host_no_fac, lcl_max_fac, prop_endo),
                 log_start_p = p_stg[1:p_n,],
                 log_end_p = p_stg[(p_n+1):(p_n*2),],
                 log_dt_p = p_stg[(p_n*2 + 1):(p_n*3),],
                 # log_start_p2 = p_stg3[1:p_n3,],
                 # log_end_p2 = p_stg3[(p_n3+1):(p_n3*2),],
                 cum_dt = p_cdt,
                 rg = p_stgrg,
                 rgr = p_stgrgr)

# calculate cumulative development time within lc groups
# px_cum_dt <-px%>%
#   pivot_longer(
#     cols = log_start_p.1:names(px)[length(px)],
#     names_to = c("trait","iter"),
#     names_sep = "\\.",
#     values_to = "mod_pred"
#   )%>%
#   filter(trait == "log_dt_p")%>%
#   arrange(iter, lcl_max_fac, Host_no_fac)%>%
#   group_by(iter, lcl_max_fac)%>%
#   mutate(trait = "cum_dt", cum_dt = cumsum(exp(mod_pred)))%>%
#   select(-mod_pred)%>%rename(mod_pred = cum_dt)%>%
#   ungroup()

# reshape predicted vals for all iter, calc fit and quantiles
p_stg <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  # bind_rows(., px_cum_dt)%>%
  group_by(pred, Host_no_fac, lcl_max_fac, prop_endo, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))
```

```{r}
# predicted and CI from model with all stages
pdx <- chains3.0[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyz$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains3.0[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_ht <- as.matrix(pdx) %*% t(mod_comb_sol3.0[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth from every iteration
p_htrg <- 
  ( p_ht[(p_n+1):(p_n*2),] - # end size
     p_ht[1:p_n,] ) # start size


# predicted and CI from model with just growing stages
pdx <- chains3.0rg[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyz2$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n2 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains3.0rg[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_ht2 <- as.matrix(pdx) %*% t(mod_comb_sol3.0rg[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

# calculate relative growth rate from every iteration
p_htrg2 <- 
  ( p_ht2[(p_n2+1):(p_n2*2),] - # end size
     p_ht2[1:p_n2,] ) / # start size
  (exp(p_ht2[(p_n2*2 + 1):(p_n2*3),])) # devo time

# predicted and CI from cum dt model
pdx <- chains4.1[[1]]$X # model matrix, fixed effx
n <- dim(pdx)[1] # number of data points in model, all traits
nt <- n/3 # number of data points per trait
p_i <- which(dxyz3$pred != "no") # points where we want predicted vals and cred int
pdx <- pdx[c(p_i, nt+p_i, nt*2+p_i),] # restrict to only points where we want preds
p_n3 <- dim(pdx)[1]/3 # number of points for each trait we want to predict
num_fe <- chains4.1[[1]]$Fixed$nfl # number of fixed effx, rand effx marginalized
p_ht3 <- as.matrix(pdx) %*% t(mod_comb_sol4.1[,1:num_fe]) # predicteds via matrix mult for combined model runs, no taxonomic effx

p_htcdt <- (p_ht3[(p_n3*2 + 1):(p_n3*3),]) # cum dt

# predicted means for every iteration for every trait
px <- data.frame(filter(dxyz, pred != "no")%>%
                   select(pred, Host_no_fac, lcl_max_fac, prop_endo),
                 log_start_p = p_ht[1:p_n,],
                 log_end_p = p_ht[(p_n+1):(p_n*2),],
                 log_dt_p = p_ht[(p_n*2 + 1):(p_n*3),],
                 cum_dt = p_htcdt,
                 rg = p_htrg,
                 rgr = p_htrg2)


# # calculate cumulative development time within lc groups
# px_cum_dt <-px%>%
#   pivot_longer(
#     cols = log_start_p.1:names(px)[length(px)],
#     names_to = c("trait","iter"),
#     names_sep = "\\.",
#     values_to = "mod_pred"
#   )%>%
#   filter(trait == "log_dt_p")%>%
#   arrange(iter, lcl_max_fac, Host_no_fac)%>%
#   group_by(iter, lcl_max_fac)%>%
#   mutate(trait = "cum_dt", cum_dt = cumsum(exp(mod_pred)))%>%
#   select(-mod_pred)%>%rename(mod_pred = cum_dt)%>%
#   ungroup()

# reshape predicted vals for all iter, calc fit and quantiles
p_ht <- px%>%
  pivot_longer(
    cols = log_start_p.1:names(px)[length(px)],
    names_to = c("trait","iter"),
    names_sep = "\\.",
    values_to = "mod_pred"
  )%>%
  # bind_rows(., px_cum_dt)%>%
  group_by(pred, Host_no_fac, lcl_max_fac, prop_endo, trait)%>%
  summarise(fit = median(mod_pred),
            lwr = quantile(mod_pred, probs = 0.025),
            upr = quantile(mod_pred, probs = 0.975))

rm(px, pdx, n, nt, p_i, p_n, p_n2, num_fe, p_htrg, p_stgrg, p_htrg2, p_stgrg2, px_cum_dt)
```
```{r}
p_ht2 <- p_ht%>%
  pivot_wider(names_from = trait, values_from = fit:upr)%>%
  ungroup()
names(p_ht2) <- c("pred","Host_no_fac","lcl_max_fac","prop_endo",
                  "cum_dt.fit", "log_dt_p.fit", "log_end_p.fit", "log_start_p.fit", "rg.fit", "rgr.fit",
                  "cum_dt.lwr", "log_dt_p.lwr", "log_end_p.lwr", "log_start_p.lwr", "rg.lwr", "rgr.lwr",
                  "cum_dt.upr", "log_dt_p.upr", "log_end_p.upr", "log_start_p.upr", "rg.upr", "rgr.upr")
p_stg2 <- p_stg%>%
  pivot_wider(names_from = trait, values_from = fit:upr)%>%
  ungroup()
names(p_stg2) <- c("pred","Host_no_fac","lcl_max_fac","prop_endo",
                  "cum_dt.fit", "log_dt_p.fit", "log_end_p.fit", "log_start_p.fit", "rg.fit", "rgr.fit",
                  "cum_dt.lwr", "log_dt_p.lwr", "log_end_p.lwr", "log_start_p.lwr", "rg.lwr", "rgr.lwr",
                  "cum_dt.upr", "log_dt_p.upr", "log_end_p.upr", "log_start_p.upr", "rg.upr", "rgr.upr")
```
```{r}
p_ht2$model <- 'host'
p_stg2$model <- 'stage'
p_all3 <- bind_rows(p_ht2, p_stg2)

p_all3 <- left_join(p_all3, 
                    select(dxy, lcl_max_fac, Host_no_fac, Stage)%>%filter(Stage!="4larv")%>%distinct()%>%na.omit()
)
```

## Panels of Fig. 4

After calculating predicted stage means and their CI from the posterior distribution, we plot them over boxplots of the observed data, starting with final size.

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, log_end_p.fit, log_end_p.upr, log_end_p.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_end_p.fit:log_end_p.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(log_end_p.fit_host >= log_end_p.lwr_stage & log_end_p.fit_host <= log_end_p.upr_stage),
         sig2 = !(log_end_p.fit_stage >= log_end_p.lwr_host & log_end_p.fit_stage <= log_end_p.upr_host)
           # between(log_end_p.fit_stage, log_end_p.lwr_host, log_end_p.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = log_end_p.fit_stage, host = log_end_p.fit_host, sig)
```
```{r}
lc_labs <- c(
  `1` = "1",
  `2` = "2",
  `3` = "3",
  `3+` = "4 or 5"
)

f3a <- ggplot(filter(dxy, !is.na(imp_biovolume)),
       aes(x = Host_no_fac, y = imp_biovolume)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(biovolume)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = bquote("Final worm size "(~mm^3)),
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) + 
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(log_end_p.fit),
                      ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = exp(log_end_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min(dxy$imp_biovolume, na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black', fill = "white"),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
f3a
# ggsave(f3a, filename = "../../figs/fig3a.png", width = 8, height = 3.5)
```

Relative to host traits, parasites tend to grow to a smaller final size in the second host of three-host cycles. Direct cycle worms are also smaller than expected. The opposite is observed in definitive hosts in complex life cycles; they grow a bit more than expected from their host traits. Here are the differences in a table. The skew towards negative values suggests that the host trait model generally predicts larger worms than the stage model.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 1))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Here is the same plot restricted to adult stages. It suggests adult worm sizes are predicted well by host traits, except in direct life cycles.

```{r}
ggplot(filter(dxy, !is.na(imp_biovolume), Stage == "adult"),
       aes(x = lcl_max_fac, y = imp_biovolume)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(biovolume)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = bquote("Final worm size "(~mm^3)),
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = lcl_max_fac, y = exp(log_end_p.fit),
                      ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = lcl_max_fac, y = exp(log_end_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Here are the differences in adult worm size for different life cycle lengths.

```{r}
filter(p_all3, model == "stage",
       (lcl_max_fac == "1" & Host_no_fac == "1") | 
         (lcl_max_fac == "2" & Host_no_fac == "2") | 
         (lcl_max_fac == "3" & Host_no_fac == "3") | 
         (lcl_max_fac == "3+" & Host_no_fac == "4"))%>%
  select(Host_no_fac, lcl_max_fac, log_end_p.fit)%>%
  mutate(log_size_diff = log_end_p.fit - lag(log_end_p.fit))%>%
  mutate(fold_change = exp(log_size_diff))
```

We can also look at how life cycle truncation would impact reproductive sizes. Here is what would happen if a four-host cycle parasite reproduced in the third host.

```{r}
filter(p_all3, model == "stage",
         (lcl_max_fac == "3" & Host_no_fac == "3") | 
         (lcl_max_fac == "3+" & Host_no_fac == "3"))%>%
  arrange((lcl_max_fac))%>%
  select(Host_no_fac, lcl_max_fac, log_end_p.fit)%>%
  mutate(log_size_diff = lag(log_end_p.fit)-log_end_p.fit)%>%
  mutate(fold_change = exp(log_size_diff), perc_decrease = (log_size_diff/lag(log_end_p.fit)) * 100)
```

Here is what would happen if a three-host cycle parasite reproduced in the second host.

```{r}
filter(p_all3, model == "stage",
         (lcl_max_fac == "2" & Host_no_fac == "2") | 
         (lcl_max_fac == "3" & Host_no_fac == "2"))%>%
  arrange((lcl_max_fac))%>%
  select(Host_no_fac, lcl_max_fac, log_end_p.fit)%>%
  mutate(log_size_diff = lag(log_end_p.fit)-log_end_p.fit)%>%
  mutate(fold_change = exp(log_size_diff), perc_decrease = (log_size_diff/lag(log_end_p.fit)) * 100)
```

Here is what would happen if a two-host cycle parasite reproduced in the first host.

```{r}
filter(p_all3, model == "stage",
         (lcl_max_fac == "1" & Host_no_fac == "1") | 
         (lcl_max_fac == "2" & Host_no_fac == "1"))%>%
  arrange((lcl_max_fac))%>%
  select(Host_no_fac, lcl_max_fac, log_end_p.fit)%>%
  mutate(log_size_diff = lag(log_end_p.fit)-log_end_p.fit)%>%
  mutate(fold_change = exp(log_size_diff), perc_decrease = (log_size_diff/lag(log_end_p.fit)) * 100)
```

Moving onto starting size, direct cycle parasites enter the host at smaller sizes than we would expect. Worms with the longest life cycles stay small initially and then enter their final hosts at a larger size than we would expect.

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, log_start_p.fit, log_start_p.upr, log_start_p.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_start_p.fit:log_start_p.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(log_start_p.fit_host >= log_start_p.lwr_stage & log_start_p.fit_host <= log_start_p.upr_stage),
         sig2 = !(log_start_p.fit_stage >= log_start_p.lwr_host & log_start_p.fit_stage <= log_start_p.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = log_start_p.fit_stage, host = log_start_p.fit_host, sig)
```
```{r}
f3b <- ggplot(filter(dxy, !is.na(imp_initial_biov)),
       aes(x = Host_no_fac, y = imp_initial_biov)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(initial_biov)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = bquote("Initial worm size "(~mm^3)),
       color = 'Model predictions') +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(log_start_p.fit),
                      ymin = exp(log_start_p.lwr), ymax = exp(log_start_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = exp(log_start_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min(dxy$imp_initial_biov, na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
f3b
```

Here's the table. Unlike for final size, stage means for initial size are sometimes overestimated and sometimes underestimated by host traits alone.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 1))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Here is initial size in definitive hosts.

```{r}
ggplot(filter(dxy, !is.na(imp_initial_biov), Stage == "adult"),
       aes(x = lcl_max_fac, y = imp_initial_biov)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(initial_biov)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = bquote("Initial worm size "(~mm^3)),
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = lcl_max_fac, y = exp(log_start_p.fit),
                      ymin = exp(log_start_p.lwr), ymax = exp(log_start_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = lcl_max_fac, y = exp(log_start_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

We can also look at relative growth, the difference between initial and final worm size. 

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, rg.fit, rg.upr, rg.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = rg.fit:rg.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(rg.fit_host >= rg.lwr_stage & rg.fit_host <= rg.upr_stage),
         sig2 = !(rg.fit_stage >= rg.lwr_host & rg.fit_stage <= rg.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = rg.fit_stage, host = rg.fit_host, sig)
```
```{r}
ggplot(filter(dxy, !is.na(imp_initial_biov), !is.na(imp_biovolume)),
       aes(x = Host_no_fac, y = exp(log(imp_biovolume)-log(imp_initial_biov)))
       ) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(initial_biov)|is.na(biovolume)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Relative growth\n(fold increase in size)",
       color = 'Model predictions') +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(rg.fit),
                      ymin = exp(rg.lwr), ymax = exp(rg.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, 
            aes(x = Host_no_fac, y = exp(rg.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min( exp(dxy$log_end - dxy$log_start), na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Relative growth was lower than expected in third and fourth hosts of 4-host cycles and higher in the second hosts of 4-host cycles.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 1))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Relative growth as adults decreased with life cycle length, as worms entered definitive hosts at larger initial sizes with longer life cycles.

```{r}
ggplot(filter(dxy, !is.na(imp_initial_biov), !is.na(imp_biovolume), Stage == "adult"),
       aes(x = Host_no_fac, y = exp(log(imp_biovolume)-log(imp_initial_biov)))
       ) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(initial_biov)|is.na(biovolume)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Relative growth as adult\n(fold increase in size)",
       color = 'Model predictions') +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = Host_no_fac, y = exp(rg.fit),
                      ymin = exp(rg.lwr), ymax = exp(rg.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = Host_no_fac, y = exp(rg.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Next we look at developmental time.

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, log_dt_p.fit, log_dt_p.upr, log_dt_p.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_dt_p.fit:log_dt_p.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(log_dt_p.fit_host >= log_dt_p.lwr_stage & log_dt_p.fit_host <= log_dt_p.upr_stage),
         sig2 = !(log_dt_p.fit_stage >= log_dt_p.lwr_host & log_dt_p.fit_stage <= log_dt_p.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = log_dt_p.fit_stage, host = log_dt_p.fit_host, sig)
```
```{r}
f3c <- ggplot(filter(dxy, !is.na(imp_avg_dt)),
       aes(x = Host_no_fac, y = imp_avg_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10() +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Development time (days)",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(log_dt_p.fit),
                      ymin = exp(log_dt_p.lwr), ymax = exp(log_dt_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = exp(log_dt_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min( exp(dxy$log_dt), na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
f3c
```

Here's the table. Worms rarely developed longer than expected, perhaps in the definitive host of 2-host cycles. Rather, in "middle" life stages like second and third intermediate hosts, parasites developed less than expected (paratenesis).

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 1))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Here is prepatent period for adults. It was quite constant.

```{r}
ggplot(filter(dxy, !is.na(imp_avg_dt), Stage == "adult"),
       aes(x = Host_no_fac, y = imp_avg_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10() +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Development time (days)",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = Host_no_fac, y = exp(log_dt_p.fit),
                      ymin = exp(log_dt_p.lwr), ymax = exp(log_dt_p.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = Host_no_fac, y = exp(log_dt_p.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Instead of stage-level devo time, we can also plot cumulative development time across stages.

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, cum_dt.fit, cum_dt.upr, cum_dt.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = cum_dt.fit:cum_dt.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(cum_dt.fit_host >= cum_dt.lwr_stage & cum_dt.fit_host <= cum_dt.upr_stage),
         sig2 = !(cum_dt.fit_stage >= cum_dt.lwr_host & cum_dt.fit_stage <= cum_dt.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = cum_dt.fit_stage, host = cum_dt.fit_host, sig)
```
```{r}
ggplot(filter(dxyy3, !is.na(cum_dt),
              # !Parasite.species %in% nspp$Parasite.species
              ),
       aes(x = Host_no_fac, y = cum_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10() +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Cumulative development time",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = exp(cum_dt.fit),
                      ymin = exp(cum_dt.lwr), ymax = exp(cum_dt.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = exp(cum_dt.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%mutate(y = min(dxyy3$cum_dt, na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Again, stages tend to spend less time developing than expected, not more, especially in longer life cycles.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3))%>%
  mutate(fold_change = round(exp(abs(diff_btw_predictions)), 2))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

Here is total developmental time to sexual maturity. It increases with life cycle length.

```{r}
ggplot(filter(dxyy3, !is.na(cum_dt), Stage == "adult", 
              # !Parasite.species %in% nspp$Parasite.species
              ),
       aes(x = Host_no_fac, y = cum_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_y_log10() +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Cumulative development time",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = Host_no_fac, y = exp(cum_dt.fit),
                      ymin = exp(cum_dt.lwr), ymax = exp(cum_dt.upr),
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = Host_no_fac, y = exp(cum_dt.fit), group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Here are the predicted differences in total developmental time.
```{r}
filter(p_all3, model == "stage",
       (lcl_max_fac == "1" & Host_no_fac == "1") | 
         (lcl_max_fac == "2" & Host_no_fac == "2") | 
         (lcl_max_fac == "3" & Host_no_fac == "3") | 
         (lcl_max_fac == "3+" & Host_no_fac == "4"))%>%
  select(Host_no_fac, lcl_max_fac, cum_dt.fit, cum_dt.upr, cum_dt.lwr)%>%
  mutate_at(vars(starts_with("cum_dt")), function(x){exp(x)})
```

How much will temperature impact this? We can look at the time worms spend in endotherms vs ectotherms. Here is the proportion of their life spent in endotherms or ectotherms. Species with complex life cycles spend over 50% of their lives on average in ectotherms.

```{r}
cx <- filter(dxyy3, !is.na(cum_dt))%>%
  group_by(Parasite.species)%>%
  mutate(cmax = max(cum_dt, na.rm = T))%>%
  select(Parasite.species, lcl_max_fac, cmax)%>%distinct()

filter(dxyy3, !is.na(cum_dt))%>%
  group_by(Parasite.species, endo_ecto)%>%
  summarise(dt_endo_ecto = sum(imp_avg_dt))%>%
  pivot_wider(., names_from = endo_ecto, values_from = dt_endo_ecto)%>%
  mutate(ecto = if_else(is.na(ecto), 0, ecto), endo = if_else(is.na(endo), 0, endo))%>%
  left_join(., cx)%>%
  mutate(prop_ecto = ecto/cmax, prop_endo = endo/cmax)%>%
  ggplot(., aes(x = lcl_max_fac, y = prop_endo)) + geom_boxplot(outlier.colour = NA) + geom_jitter(alpha = 0.3)
```

Here are the median values from the plot above.

```{r}
filter(dxyy3, !is.na(cum_dt))%>%
  group_by(Parasite.species, endo_ecto)%>%
  summarise(dt_endo_ecto = sum(imp_avg_dt))%>%
  pivot_wider(., names_from = endo_ecto, values_from = dt_endo_ecto)%>%
  mutate(ecto = if_else(is.na(ecto), 0, ecto), endo = if_else(is.na(endo), 0, endo))%>%
  left_join(., cx)%>%
  mutate(prop_ecto = ecto/cmax, prop_endo = endo/cmax)%>%
  group_by(lcl_max_fac)%>%
  summarise(n = n(), prop_ecto = median(prop_ecto), prop_endo = median(prop_endo))
```

And here is the same stat, but split by simple vs complex life cycle.

```{r}
filter(dxyy3, !is.na(cum_dt))%>%
  group_by(Parasite.species, endo_ecto)%>%
  summarise(dt_endo_ecto = sum(imp_avg_dt))%>%
  pivot_wider(., names_from = endo_ecto, values_from = dt_endo_ecto)%>%
  mutate(ecto = if_else(is.na(ecto), 0, ecto), endo = if_else(is.na(endo), 0, endo))%>%
  left_join(., cx)%>%
  mutate(prop_ecto = ecto/cmax, prop_endo = endo/cmax)%>%
  group_by(lcl_max_fac!="1")%>%
  summarise(n = n(), prop_ecto = median(prop_ecto), prop_endo = median(prop_endo))
rm(cx)
```

Putting growth and development time together, we can look at growth rates. 

```{r}
p_all3_wide <- select(p_all3, Host_no_fac, lcl_max_fac, model, rgr.fit, rgr.upr, rgr.lwr)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = rgr.fit:rgr.lwr)
p_all3_wide <- p_all3_wide%>%
  mutate(sig1 = !(rgr.fit_host >= rgr.lwr_stage & rgr.fit_host <= rgr.upr_stage),
         sig2 = !(rgr.fit_stage >= rgr.lwr_host & rgr.fit_stage <= rgr.upr_host)
           )%>%
  mutate(sig = if_else(sig1 & sig2, "sig", "not sig"))%>%
  select(Host_no_fac, lcl_max_fac, stage = rgr.fit_stage, host = rgr.fit_host, sig)
```
```{r}
f3d <- ggplot(filter(dxy, !is.na(imp_biovolume), !is.na(imp_initial_biov), !is.na(imp_avg_dt), imp_avg_dt>7),
       aes(x = Host_no_fac, y = (log_end - log_start)/imp_avg_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(biovolume)|is.na(initial_biov)|is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Relative growth rate\n(~% size increase per day)",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  facet_grid(~lcl_max_fac, scales = 'free_x', space = 'free_x',
             labeller = labeller(lcl_max_fac = lc_labs)) +
  geom_pointrange(data = p_all3, 
                  aes(x = Host_no_fac, y = rgr.fit,
                      ymin = rgr.lwr, ymax = rgr.upr,
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = p_all3, aes(x = Host_no_fac, y = rgr.fit, group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  geom_point(data = filter(p_all3_wide, sig == "sig")%>%
               mutate(y = -0.2), #min( ((dxy$log_end - dxy$log_start)/dxy$imp_avg_dt), na.rm = T)),
             aes(x = Host_no_fac, y = y), 
             shape = 23, size = 3, stroke = 3,
             fill = RColorBrewer::brewer.pal(3, "Pastel1")[1],
             color = RColorBrewer::brewer.pal(3, "Pastel1")[2]) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) +
  coord_cartesian(ylim = c(-0.21, 1.2))
f3d
```

Growth rates are relatively consistent among stages. Here's the table. Growth was slower than expected in the definitive hosts in four-host cycles. It was faster in the initial stages of long cycles.

```{r}
mutate(p_all3_wide, diff_btw_predictions = round(`stage` - `host`, 3),
       diff_btw_predictions2 = round(log(`stage`) - log(`host`), 3))%>%
  mutate(fold_change = round((abs(diff_btw_predictions2)), 2))%>%
  select(lcl_max_fac, Host_no_fac, diff_btw_predictions, fold_change, sig)%>%
  arrange(diff_btw_predictions)
```

And here are the differences in growth rates among stages. It varies 3-fold but the CIs are wide. Early life stages tend to have faster growth than later life stages. 

```{r}
select(p_all3, Host_no_fac, lcl_max_fac, model, rgr.fit, rgr.upr, rgr.lwr)%>%
  filter(model == "stage")%>%
  arrange(rgr.fit)%>%
  mutate(across(starts_with("rgr"), ~round(.x, 2)))
```

Adult growth rates were lower in longer life cycles.

```{r}
ggplot(filter(dxy, !is.na(imp_biovolume), !is.na(imp_initial_biov), !is.na(imp_avg_dt), imp_avg_dt>7, Stage == "adult"),
       aes(x = lcl_max_fac, y = (log_end - log_start)/imp_avg_dt)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.33, size = 0.75,
             aes(shape = is.na(biovolume)|is.na(initial_biov)|is.na(avg_dt)),
             position = position_jitter(width = 0.33, height = 0)) +
  scale_color_brewer(type = "qual", palette = "Pastel1", direction = 1,
                     labels = c('Host traits only', 'Stages only')) +
  labs(x = "Stage (host) in life cycle",
       y = "Relative growth rate",
       color = 'Model predictions') +
  scale_shape_manual(values = c(19,4)) +
  guides(shape = F) +
  scale_x_discrete(labels = c("1", "2", "3", "4 or 5")) +
  geom_pointrange(data = filter(p_all3, Stage == "adult"),
                  aes(x = lcl_max_fac, y = rgr.fit,
                      ymin = rgr.lwr, ymax = rgr.upr,
                      color = model),
                  size = 1.25,
                  position = position_dodge(width = 0.5)) +
  geom_line(data = filter(p_all3, Stage == "adult"),
            aes(x = lcl_max_fac, y = rgr.fit, group = model, color = model), 
            alpha = 1, size = 1.5, linetype = 'dashed',
            position = position_dodge(width = 0.5)) +
  theme(legend.background = element_rect(color = 'black'),
        strip.text = element_text(face = "bold"),
        strip.background = element_rect(fill = 'grey95'),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```

Here are those adult growth rates above in a table.

```{r}
filter(p_all3, model == "stage",
       (lcl_max_fac == "1" & Host_no_fac == "1") | 
         (lcl_max_fac == "2" & Host_no_fac == "2") | 
         (lcl_max_fac == "3" & Host_no_fac == "3") | 
         (lcl_max_fac == "3+" & Host_no_fac == "4"))%>%
  select(Host_no_fac, lcl_max_fac, rgr.fit, rgr.upr, rgr.lwr)
```

We combined these figures for export...

```{r}
f3a2 <- f3a + 
  theme(legend.position = c(0.9, 0.175),
        axis.title.x = element_blank(), 
        axis.text.x = element_blank())

f3b2 <- f3b +
  theme(legend.position = "none",
        axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        strip.background = element_blank(),
        strip.text.x = element_blank())

f3c2 <- f3c +
  theme(legend.position = "none",
        axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        strip.background = element_blank(),
        strip.text.x = element_blank())

f3d2 <- f3d +
  theme(legend.position = "none",
        strip.background = element_blank(),
        strip.text.x = element_blank())
```
```{r}
f3 <- plot_grid(f3a2, f3b2, f3c2, f3d2, align="hv", ncol = 1, labels = c('(a)', '(b)', '(c)', '(d)'))
f3dd <- plot_grid(f3c, f3d, align="hv", ncol = 1, labels = c('(c)', '(d)'))
```
```{r}
title <- ggdraw() +
  draw_label("Imputed",
    fontface = 'bold',
    size = 20
  ) 

f3gif <- plot_grid(title, 
                   plot_grid(f3a2, f3b2, f3c2, f3d2, align="v", ncol = 1, labels = c('(a)', '(b)', '(c)', '(d)')),
                   ncol = 1, 
                   rel_heights = c(0.1, 1))
```
```{r}
title <- ggdraw() +
  draw_label("Imputed, days",
    fontface = 'bold',
    size = 20
  ) 

f3dd <- plot_grid(title, 
                  f3dd,
                  ncol = 1, 
                  rel_heights = c(0.1, 1))
```
```{r}
ggsave(f3, filename = "../../figs/fig4_imp.png",
       width = 8, height =  3.5*4)
ggsave(f3, filename = "../../figs/fig4_imp.svg",
       width = 8, height = 3.5*4)
# move closer together in inkscape, adjust labels
ggsave(f3gif, filename = "../../figs/gif_imp_vs_noimp/fig4_imp.png",
       width = 8, height = 3.5*4)
ggsave(f3dd, filename = "../../figs/gif_dd_vs_nodd/fig4_imp.png",
       width = 10, height = 3.5*2)
rm(f3gif, f3a2, f3b2, f3c2, f3d2, f3dd)
```

# Size by age

Another way to look at these model predictions are with growth curves. Let's plot the model predictions from host traits vs stages as growth curves, i.e. size vs time. We take propagule size as size at t = 0.

```{r}
eggies <- select(p_all3, Host_no_fac, lcl_max_fac, model, log_dt_p.fit, 
                 log_end_p.fit = log_start_p.fit,
                 log_end_p.lwr = log_start_p.lwr,
                 log_end_p.upr = log_start_p.upr)%>%
  filter(Host_no_fac == '1')%>%
  mutate(Host_no_fac = '0',
         log_dt_p.fit = 0,
         log_dt_p.lwr = 0,
         log_dt_p.upr = 0,
         cum_dt.fit = 0,
         cum_dt.lwr = 0,
         cum_dt.upr = 0)

p_all3_cum <- bind_rows(p_all3, eggies)
```

```{r}
p_all3_cum <- group_by(p_all3_cum, lcl_max_fac, model)%>%
  arrange(lcl_max_fac, model, Host_no_fac)%>%
  mutate(grp = paste(lcl_max_fac,model))
```

This plot shows the predicted increase in parasite size with each host as a function of time. The colors represent different life cycle lengths and the predictions from host traits vs stages are separated. Differences between the models are a little hard to see here.

```{r}
# ggplot(filter(p_all3_cum, model == "stage"),
#        aes(x = cum_dt.fit, y = exp(log_end_p.fit), color = lcl_max_fac)) +
#   geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
#   geom_linerange(aes(xmin = cum_dt.lwr, xmax = cum_dt.upr)) +
#   geom_line(aes(group = lcl_max_fac)) + 
#   geom_label(aes(label = Host_no_fac)) +
#   scale_y_log10() +
#   scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
#   labs(x = 'Cumulative time developing', 
#        y = bquote("Worm size "(~mm^3)),
#        color = 'LCL') +
#   theme(panel.grid.minor = element_blank())
```
```{r}
ggplot(p_all3_cum,
       aes(x = exp(cum_dt.fit), y = exp(log_end_p.fit), color = lcl_max_fac)) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr), xmax = exp(cum_dt.upr))) +
  geom_line(aes(group = lcl_max_fac)) + 
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
  facet_wrap(~model) +
  labs(x = 'Cumulative time developing', 
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

Maybe these differences are easier to see if we compare the models within each life cycle length. For one-host life cycles, parasites infect hosts at a smaller size and grow less than expected from their hosts.

```{r}
ggplot(filter(p_all3_cum, lcl_max_fac == '1'),
       aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit))) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1)) +
  geom_line(aes(linetype = model)) +
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  # scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
  labs(x = 'Cumulative time developing', 
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

Two-host cycles are the most common in the dataset, so they have an outsized affect on the parameters of the host trait model. That may explain why expectations and observation align well. If anything, parasites grow slower than expected in both hosts.

```{r}
ggplot(filter(p_all3_cum, lcl_max_fac == '2'),
       aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit))) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1)) +
  geom_line(aes(group = grp, linetype = model)) + 
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  labs(x = 'Cumulative time developing', 
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

Parasites with three host cycles grow less than expected in second hosts, but then a bit longer in the 3rd hosts.

```{r}
ggplot(filter(p_all3_cum, lcl_max_fac == '3'),
       aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit))) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1)) +
  geom_line(aes(group = grp, linetype = model)) + 
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  labs(x = 'Cumulative time developing',
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

Parasites with the longest life cycles from faster at the beginning of their cycles and then slower at the end. In particular, they forgo growth in the third host.

```{r}
ggplot(filter(p_all3_cum, lcl_max_fac == '3+'),
       aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit))) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr))) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1)) +
  geom_line(aes(group = grp, linetype = model)) + 
  geom_label(aes(label = Host_no_fac)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  labs(x = 'Cumulative time developing', 
       y = bquote("Worm size "(~mm^3)),
       color = 'LCL') +
  theme(panel.grid.minor = element_blank())
```

```{r}
p_all3_wide <- select(p_all3_cum, Host_no_fac, lcl_max_fac, model, log_end_p.fit, cum_dt.fit)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_end_p.fit:cum_dt.fit)
p_all3_cumx <- left_join(p_all3_cum, p_all3_wide)
```

Here's another attempt to visualize these model comps. Arrows show how the stage-only means deviate from expectations based on the host traits only model. Arrows towards the left (shorter devo) or up (more growth) imply parasite are overachieving relative to host-trait expectations. Parasites growing faster than expected appears rare, though worms with long cycles seem to shorten developmental time, relative to expectations.

```{r}
# # all on one plot
# ggplot(filter(p_all3_cumx, model == 'stage'),
#         aes(x = cum_dt.fit-1, y = 10^log_end_p.fit, color = lcl_max_fac)) +
#   geom_line(aes(group = grp), alpha = 0.5) + 
#   geom_linerange(aes(xmin = cum_dt.lwr, xmax = cum_dt.upr), alpha = 0.3) +
#   geom_linerange(aes(ymin = 10^log_end_p.lwr, ymax = 10^log_end_p.upr), alpha = 0.3) + 
#   geom_segment(data = filter(p_all3_cumx, model == 'host'),
#                aes(x = cum_dt.fit-1, y = 10^log_end_p.fit,
#                    yend = 10^`log_end_p.fit_stage`, 
#                    xend = `cum_dt.fit_stage`-1 ),
#                arrow = arrow(angle = 10, 
#                              type = 'closed', length = unit(0.15, 'inches')),
#                linetype = 'dashed') +
#   geom_label(aes(label = Host_no_fac),alpha = 0.5) +
#   scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
#   scale_linetype(labels = c('Host traits only', 'Stages only')) +
#   scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
#   guides(color = F) +
#   labs(x = 'Cumulative time developing (days)',
#        y = bquote("Worm size "(~mm^3)))  +
#   theme(panel.grid.minor = element_blank())
```
```{r}
ggplot(filter(p_all3_cumx, model == 'stage'),
        aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), color = lcl_max_fac)) +
  geom_line(aes(group = grp), alpha = 0.5) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1), alpha = 0.3) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr)), alpha = 0.3) + 
  geom_segment(data = filter(p_all3_cumx, model == 'host'),
               aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit),
                   yend = exp(`log_end_p.fit_stage`),
                   xend = exp(`cum_dt.fit_stage`)-1 ),
               arrow = arrow(angle = 10,
                             type = 'closed', length = unit(0.15, 'inches')),
               linetype = 'dashed') +
  geom_label(aes(label = Host_no_fac),alpha = 0.5) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
  guides(color = F) +
  labs(x = 'Cumulative time developing (days)',
       y = bquote("Worm size "(~mm^3)))  +
  theme(panel.grid.minor = element_blank()) +
  facet_grid(~lcl_max_fac)
```

Model predictions are "adjusted" for taxonomy, but for some groups this might be misleading. For example, direct life cycle worms are all related, so when we account for taxonomy, their expected adult size is shifted up towards the overall mean. Let's also make the above plot using observed data. However, when we use observed data, we cannot put errors around the means, given that they ignore variability due to missingness.

```{r}
# id spp without complete dt data or paratenic stage
incomp_spp <- dxy%>%
  filter(pred == "no")%>%
  filter(is.na(avg_dt), is_paratenic != 1)%>%
  select(Parasite.species)%>%
  .$Parasite.species
incomp_spp <- unique( incomp_spp )

# make sp level df with cum dt
cum_dd_sp <- dxy%>%
  filter(pred == "no", 
         !Parasite.species %in% nspp
         )%>% # remove spp where stages are assumed
  group_by(Parasite.species)%>%
  mutate(cum_dt = cumsum(imp_avg_dt),
         cum_dt_ni = if_else(!Parasite.species %in% incomp_spp, cumsum(imp_avg_dt), NA_real_))

eggies <- select(cum_dd_sp, Parasite.species, parasite_genus, parasite_family, parasite_order, parasite_class, parasite_phylum,
                 Host_no_fac, lcl_max_fac,  
                 cum_dt, cum_dt_ni,
                 log_end = log_start,
                 imp_biovolume = imp_initial_biov,
                 biovolume = initial_biov)%>%
  filter(Host_no_fac == '1')%>%
  mutate(Host_no_fac = '0',
         cum_dt = 0,
         cum_dt_ni = if_else(!Parasite.species %in% incomp_spp, 0, NA_real_))

cum_dd_sp <- bind_rows(cum_dd_sp, eggies)%>%
  arrange(Parasite.species, lcl_max_fac, Host_no_fac)

```
```{r}
# make group level df for cum dt
p1 <- 0.75
p2 <- 0.25
cum_dd <- ungroup(cum_dd_sp)%>%
  filter(Host_no_fac != "0")%>%
  group_by(lcl_max_fac, Host_no_fac)%>%
  summarise(log_start_p.fit = median(log_start, na.rm=T),
            # log_start_p.upr = quantile(log_start, probs = p1, na.rm=T),
            # log_start_p.lwr = quantile(log_start, probs = p2, na.rm=T),
            log_start_ni.fit = median(log(initial_biov), na.rm=T),
            # log_start_ni.upr = quantile(log(initial_biov), probs = p1, na.rm=T),
            # log_start_ni.lwr = quantile(log(initial_biov), probs = p2, na.rm=T),
            log_end_p.fit = median(log_end, na.rm=T),
            # log_end_p.upr = quantile(log_end, probs = p1, na.rm=T),
            # log_end_p.lwr = quantile(log_end, probs = p2, na.rm=T),
            log_end_ni.fit = median(log(biovolume), na.rm=T),
            # log_end_ni.upr = quantile(log(biovolume), probs = p1, na.rm=T),
            # log_end_ni.lwr = quantile(log(biovolume), probs = p2, na.rm=T),
            log_dt_p.fit = median(log_dt, na.rm=T),
            log_dt_ni.fit = median(log(avg_dt), na.rm=T),
            # log_dt_p.sd = sd(log10(cum_dt), na.rm=T),
            # log_dt_p.upr = quantile(log(cum_dt), probs = p1, na.rm=T),
            # log_dt_p.lwr = quantile(log(cum_dt), probs = p2, na.rm=T),
            cum_dt.fit = median(log(cum_dt), na.rm=T),
            cum_dt_ni.fit = median(log(cum_dt_ni), na.rm=T),
            # cum_dt_ni.upr = quantile(log(cum_dt_ni), probs = p1, na.rm=T),
            # cum_dt_ni.lwr = quantile(log(cum_dt_ni), probs = p2, na.rm=T),
            # res_ma_p.fit = median(log(res_ma), na.rm=T),
            # res_ma_p.upr = quantile(log(res_ma), probs = p1, na.rm=T),
            # res_ma_p.lwr = quantile(log(res_ma), probs = p2, na.rm=T),
            )%>%
  filter(!is.na(lcl_max_fac))

eggies <- select(cum_dd, Host_no_fac, lcl_max_fac, log_dt_p.fit, 
                 log_end_p.fit = log_start_p.fit,
                 # log_end_p.lwr = log_start_p.lwr,
                 # log_end_p.upr = log_start_p.upr,
                 log_end_ni.fit = log_start_ni.fit,
                 # log_end_ni.lwr = log_start_ni.lwr,
                 # log_end_ni.upr = log_start_ni.upr
                 )%>%
  filter(Host_no_fac == '1')%>%
  mutate(Host_no_fac = '0',
         log_dt_p.fit = 0,
         # log_dt_p.lwr = 0,
         # log_dt_p.upr = 0,
         cum_dt.fit = 0,
         cum_dt_ni.fit = 0,
         # cum_dt_ni.lwr = 0,
         # cum_dt_ni.upr = 0
         )

cum_dd <- bind_rows(cum_dd, eggies)%>%
  arrange(lcl_max_fac, Host_no_fac)

# cum_dd <- mutate(cum_dd,
#                  cum_dt.fit = exp(log_dt_p.fit),
#                  cum_dt.upr = exp(log_dt_p.upr),
#                  cum_dt.lwr = exp(log_dt_p.lwr),
#                  cum_dt_ni.fit = exp(cum_dt_ni.fit),
#                  cum_dt_ni.lwr = exp(cum_dt_ni.lwr),
#                  cum_dt_ni.upr = exp(cum_dt_ni.upr)
#                  )
cum_dd$model <- "observed"
cum_dd <- bind_rows(cum_dd, p_all3_cum)
cum_dd <- mutate(cum_dd, grp = paste(lcl_max_fac,model))

cum_dd_wide <- select(cum_dd, Host_no_fac, lcl_max_fac, model, log_end_p.fit, cum_dt.fit)%>%
  pivot_wider(id_cols = Host_no_fac:model, names_from = model, values_from = log_end_p.fit:cum_dt.fit)
cum_dd <- left_join(cum_dd, cum_dd_wide)
cum_dd <- cum_dd%>%
  mutate(model = forcats::fct_relevel(model, c("host", "stage", "observed")))
```

Here is the median cumulative development time for direct vs complex life cycles...

```{r}
cum_dd_sp%>%
  filter(Stage == "adult", !Parasite.species %in% nspp)%>%
  group_by(lcl_max_fac==1)%>%
  summarize(n_imp = sum(!is.na(cum_dt)),
            med_cum_dt = median(cum_dt, na.rm = T),
            sd_cum_dt = sd(cum_dt, na.rm = T),
            n_noimp = sum(!is.na(cum_dt_ni)),
            med_cum_dt_ni = median(cum_dt_ni, na.rm = T))
```

...and among life cycle lengths.

```{r}
cum_dd_sp%>%
  filter(Stage == "adult")%>%
  group_by(lcl_max_fac, Host_no_fac)%>%
  summarize(n_imp = sum(!is.na(cum_dt)),
            med_cum_dt = median(cum_dt, na.rm = T),
            sd_cum_dt = sd(cum_dt, na.rm = T),
            n_noimp = sum(!is.na(cum_dt_ni)),
            med_cum_dt_ni = median(cum_dt_ni, na.rm = T))
```

Here is how the stage medians differ from host-derived expectations. Overall, the pattern is similar, but the reduction in growth for 1-host cycles is more conspicuous.

```{r}
lc_labs <- c(
  `1` = "1",
  `2` = "2",
  `3` = "3",
  `3+` = "4 or 5"
)

ggplot(filter(cum_dd, model == 'observed'),
        aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), color = lcl_max_fac)) +
  geom_line(aes(group = grp), alpha = 0.5) + 
  geom_linerange(aes(xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1), alpha = 0.3) +
  geom_linerange(aes(ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr)), alpha = 0.3) + 
  geom_segment(
    # data = filter(p_all3_cumx, model == 'host'),
               aes(x = exp(cum_dt.fit_host)-1, y = exp(log_end_p.fit_host),
                   yend = exp(`log_end_p.fit`),
                   xend = exp(`cum_dt.fit`)-1 ),
               arrow = arrow(angle = 10,
                             type = 'closed', length = unit(0.15, 'inches')),
               linetype = 'dashed') +
  geom_label(aes(label = Host_no_fac),alpha = 0.5) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_linetype(labels = c('Host traits only', 'Stages only')) +
  scale_color_brewer(type = "qual", palette = "Dark2", direction = 1) +
  guides(color = F) +
  labs(x = 'Cumulative time developing (days)',
       y = bquote("Worm size "(~mm^3)))  +
  theme(panel.grid.minor = element_blank()) +
  facet_grid(~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs))
```

Given that observed and model means differed, it is probably worth plotting them over the actual data.

```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = imp_biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(1, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt_ni)|is.na(biovolume)), 
             alpha = 0.4, size = 0.8) + 
  # geom_smooth(method = , se = F, aes(group = NA), linetype = "dotted", color = "black") +
  geom_line(data = cum_dd, 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = cum_dd, 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = cum_dd, 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = cum_dd, aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  facet_grid(model~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', y = 'Final worm size', color = 'LCL') 
```

Obviously, the observed means match the data best, especially for one-host cycles. It might be easier to compare the models with an "average" growth curve. Therefore, I fit non-linear asymptotic and Weibull growth models to the full dataset. In neither case do I account for phylogeny, i.e. curve parameters do not vary among taxa.

The Weibull regression has an extra parameter compared to the asymptotic model. A likelihood ratio test suggests this model is not better.

```{r}
iPar <- list(Asym = max(cum_dd_sp$log_end), lrc = 0.02, R0 = min(cum_dd_sp$log_end))
tl_asy <- nls(log_end ~ Asym - (Asym - R0) * exp(-lrc*cum_dt), # for this parameterization of VBLG, see here: https://derekogle.com/NCNRS349/modules/Growth/BKG
          start = iPar,
          data = cum_dd_sp)

iPar <- getInitial(log(imp_biovolume) ~ SSasymp(cum_dt, Asym, R0, lrc), data = cum_dd_sp)
tl_asy2 <- nls(log(imp_biovolume) ~ Asym+(R0-Asym)*exp(-exp(lrc)*cum_dt),
          start = iPar,
          data = cum_dd_sp)
# summary(tl_asy2)
# summary(tl_asy) # exactly the same, just different parameterizations

iPar <- getInitial(log(imp_biovolume) ~ SSweibull(cum_dt, Asym, Drop, lrc, pwr), data = cum_dd_sp)
tl_w <- nls(log(imp_biovolume) ~ Asym-Drop*exp(-exp(lrc)*cum_dt^pwr),
          start = iPar,
          data = filter(cum_dd_sp, !is.na(imp_biovolume)))
# summary(tl_w)
anova(tl_asy2, tl_w)
```

The curve is also a better fit than a line, as the residual standard errors are much lower than for a line. The residual plot also looks much better for the curve than for the line (not shown).

```{r}
tl_lm <- lm(log(imp_biovolume) ~ cum_dt, data = filter(cum_dd_sp,))
data.frame(line_res_se = summary(tl_lm)$sigma, curve_res_se = summary(tl_asy)$sigma)
```

Here are the parameters of the curve:

```{r}
summary(tl_asy)
```

Let's add this curve to the above plot. The median values for different life stages follow the curve rather well.

```{r}
x<-0:150
lg <- data.frame(x = x, y = exp( predict(tl_asy, newdata = data.frame(cum_dt = x)) ),
                 y2 = exp( predict(tl_w, newdata = data.frame(cum_dt = x)) ) )
```
```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = imp_biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(0, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt_ni)|is.na(biovolume)), 
             alpha = 0.4, size = 0.8) + 
  geom_line(data = lg, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = cum_dd, 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = cum_dd, 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = cum_dd, 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = cum_dd, aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  facet_grid(model~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', y = 'Final worm size', color = 'LCL') 
```

We can also focus on just the observed means and not the model predictions.

```{r}
f5 <- ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = imp_biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(0, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt_ni)|is.na(biovolume)), 
             alpha = 0.8, size = 0.5) + 
  geom_line(data = lg, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = filter(cum_dd, model == "observed"), 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = filter(cum_dd, model == "observed"), aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 2) +
  facet_grid(~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', 
       y = bquote("Worm size "(~mm^3))) +
  theme(panel.grid.minor = element_blank()) 
f5
ggsave(f5, filename = "../../figs/fig5d_imp.png", width = 8, height = 3)
# ggsave(f5, filename = "../../figs/fig5d_imp.pdf", width = 8, height = 3)
ggsave(f5, filename = "../../figs/fig5d_imp.svg", width = 8, height = 3)
```

How far are the observed medians from the curve? The first host in 2-host cycles was furthest below the curve while the second host in 4-host cycles was the furthest above the curve.

```{r}
cum_dd$pred_size <- predict(tl_asy, newdata = mutate(cum_dd, cum_dt = exp(cum_dt.fit)))
mutate(cum_dd, residual = (log_end_p.fit - pred_size))%>%
  filter(model == "observed")%>%
  select(lcl_max_fac, Host_no_fac, residual)%>%
  arrange(residual)
```

Here is the sum of squares for the stage medians (for comparing to the degree day curve).

```{r}
mutate(cum_dd, res = (log_end_p.fit - pred_size)^2)%>%
  filter(model == "observed")%>%
  ungroup()%>%
  summarise(sum_se = sum(res))
```

We could also make the plot above, but connecting the points for each species with a line. This is too hectic.

```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = imp_biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(0, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  # geom_point(aes(shape = is.na(cum_dt_ni)|is.na(biovolume)), 
  #            alpha = 0.6, size = 0.8) + 
  geom_line(aes(group = Parasite.species), alpha = 0.25) +
  geom_line(data = lg, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = filter(cum_dd, model == "observed"), 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = filter(cum_dd, model == "observed"), aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  facet_grid(~lcl_max_fac,
             labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', 
       y = bquote("Worm size "(~mm^3))) 
```

Maybe it is easier to compare life cycle lengths when they are on the same plot. I think it is better separate.

```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt, y = imp_biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  coord_cartesian(xlim = c(0, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt_ni)|is.na(biovolume)), 
             alpha = 0.4, size = 0.8) + 
  geom_line(data = lg, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = filter(cum_dd, model == "observed"), 
            aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), group = lcl_max_fac),
            size = 1.5) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), xmin = exp(cum_dt.lwr)-1, xmax = exp(cum_dt.upr)-1),
            alpha = 1, size = 1) +
  geom_linerange(data = filter(cum_dd, model == "observed"), 
                 aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), ymin = exp(log_end_p.lwr), ymax = exp(log_end_p.upr) ),
            alpha = 1, size = 1) +
  geom_label(data = filter(cum_dd, model == "observed"), aes(x = exp(cum_dt.fit)-1, y = exp(log_end_p.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  # facet_grid(~lcl_max_fac,
  #            labeller = labeller(lcl_max_fac = lc_labs)) +
  labs(x = 'Cumulative time developing (days)', y = 'Final worm size', color = 'LCL') 
```

We can also make this plot for just species with devo time at all available stages. The pattern is similar, except for different growth trajectories in the longest life cycles.

```{r}
iPar <- list(Asym = max(cum_dd_sp$log_end), lrc = 0.02, R0 = min(cum_dd_sp$log_end))
tl_asy <- nls(log_end ~ Asym - (Asym - R0) * exp(-lrc*cum_dt), # for this parameterization of VBLG, see here: https://derekogle.com/NCNRS349/modules/Growth/BKG
          start = iPar,
          data = filter(cum_dd_sp, !is.na(cum_dt_ni)))

# iPar <- getInitial(log(imp_biovolume) ~ SSasymp(cum_dt_ni, Asym, R0, lrc), data = filter(cum_dd_sp, !is.na(cum_dt_ni)))
# tl_asy_ni <- nls(log(imp_biovolume) ~ Asym+(R0-Asym)*exp(-exp(lrc)*cum_dt_ni),
#           start = iPar,
#           data = filter(cum_dd_sp, !is.na(cum_dt_ni)))
# summary(tl_asy_ni)

# iPar <- getInitial(log(imp_biovolume) ~ SSweibull(cum_dt_ni, Asym, Drop, lrc, pwr), data = filter(cum_dd_sp, !is.na(cum_dt_ni)))
# tl_w_ni <- nls(log(imp_biovolume) ~ Asym-Drop*exp(-exp(lrc)*cum_dt_ni^pwr),
#           start = iPar,
#           data = filter(cum_dd_sp, !is.na(cum_dt_ni)))
# summary(tl_w_ni)
# anova(tl_asy_ni, tl_w_ni)

x<-0:150
lg2 <- data.frame(x = x, y = exp( predict(tl_asy, newdata = data.frame(cum_dt = x)) )
                 # y2 = exp( predict(tl_w_ni, newdata = data.frame(cum_dt_ni = x)) ) 
                 )
```
```{r}
ggplot(filter(cum_dd_sp, ), 
       aes(x = cum_dt_ni, y = biovolume, color = lcl_max_fac)) +
  scale_shape_manual(values = c(19,4)) +
  # scale_x_log10() +
  coord_cartesian(xlim = c(1, 150)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = 'Set2') +
  guides(shape = F, color = F) +
  geom_point(aes(shape = is.na(cum_dt_ni)|is.na(biovolume)), 
             alpha = 1, size = 0.8) + 
  geom_line(data = lg2, aes(x = x, y = y),
              linetype = "dashed", color = "black", size = 1.5) +
  geom_line(data = filter(cum_dd, model == "observed"), 
            aes(x = exp(cum_dt_ni.fit)-1, y = exp(log_end_ni.fit), group = lcl_max_fac),
            size = 1.5) +
  # geom_linerange(data = filter(cum_dd, model == "observed"), 
  #                aes(x = cum_dt_ni.fit-1, y = exp(log_end_ni.fit), xmin = cum_dt_ni.lwr, xmax = cum_dt_ni.upr ),
  #           alpha = 1, ) +
  # geom_linerange(data = filter(cum_dd, model == "observed"), 
  #                aes(x = cum_dt_ni.fit-1, y = exp(log_end_ni.fit), ymin = exp(log_end_ni.lwr), ymax = exp(log_end_ni.upr) ),
  #           alpha = 1, ) +
  geom_label(data = filter(cum_dd, model == "observed"),
             aes(x = exp(cum_dt_ni.fit)-1, y = exp(log_end_ni.fit), label = Host_no_fac), 
             fill = "white",
             size = 4) +
  labs(x = 'Cumulative time developing (days)', y = 'Final worm size', color = 'LCL') 
```


# Covariation among the traits determining growth rate

The multivariate model allows us to examine the covariance among traits and whether this is affected by the model predictors. First, let's look at the residual covariance, the covariance among parasite traits after accounting for fixed predictors and parasite taxonomy.

```{r}
r1 <- posterior.cor(mod_comb_vcv0[,grepl(colnames(mod_comb_vcv0), pattern = '.units')])
r2 <- posterior.cor(mod_comb_vcv3.0[,grepl(colnames(mod_comb_vcv3.0), pattern = '.units')])
r3 <- posterior.cor(mod_comb_vcv3.1[,grepl(colnames(mod_comb_vcv3.1), pattern = '.units')])


r_start_end <- r1[,2]
r_start_dt <- r1[,3]
r_end_dt <- r1[,6]
r2_start_end <- r2[,2]
r2_start_dt <- r2[,3]
r2_end_dt <- r2[,6]
r3_start_end <- r3[,2]
r3_start_dt <- r3[,3]
r3_end_dt <- r3[,6]

tax_corr <- data.frame(model = rep(factor(c('intercept', 'host traits', 'stages'),
                                          levels = c('intercept', 'host traits', 'stages')), each = 3),
                       trait = rep(c("Initial x Final Size", "Initial Size x Devo Time", "Final Size x Devo Time"), 3),
                       tax_cor = c(posterior.mode(r_start_end),
                                   posterior.mode(r_start_dt),
                                   posterior.mode(r_end_dt),
                                   posterior.mode(r2_start_end),
                                   posterior.mode(r2_start_dt),
                                   posterior.mode(r2_end_dt),
                                   posterior.mode(r3_start_end),
                                   posterior.mode(r3_start_dt),
                                   posterior.mode(r3_end_dt)
                                   ),
                       tax_cor_lwr = c(quantile(r_start_end, probs = 0.025),
                                   quantile(r_start_dt, probs = 0.025),
                                   quantile(r_end_dt, probs = 0.025),
                                   quantile(r2_start_end, probs = 0.025),
                                   quantile(r2_start_dt, probs = 0.025),
                                   quantile(r2_end_dt, probs = 0.025),
                                   quantile(r3_start_end, probs = 0.025),
                                   quantile(r3_start_dt, probs = 0.025),
                                   quantile(r3_end_dt, probs = 0.025)
                                   ),
                       tax_cor_upr = c(quantile(r_start_end, probs = 0.975),
                                   quantile(r_start_dt, probs = 0.975),
                                   quantile(r_end_dt, probs = 0.975),
                                   quantile(r2_start_end, probs = 0.975),
                                   quantile(r2_start_dt, probs = 0.975),
                                   quantile(r2_end_dt, probs = 0.975),
                                   quantile(r3_start_end, probs = 0.975),
                                   quantile(r3_start_dt, probs = 0.975),
                                   quantile(r3_end_dt, probs = 0.975)
                                   )
                       )
```

Regardless of fixed effects, residual covariance is positive between final size and devo time. Worm stages that reach a large size relative to their host or their stage have longer development. There is a negative correlation between initial size and devo time after accounting for host traits or stages. That is, worm stages that enter a host at a large size often have shorter development times, at least after accounting for host or stage. Interestingly, the residual correlation between initial and final size went different directions. If we do not account for host traits or parasite stages, it is positive, but if we account for parasite stages it is negative. This makes sense, an adult worm has a big initial and final size compared to larval worms, but once we correct for stage, we might see that adult worms that start large reproduce earlier and have smaller final sizes.

```{r}
ggplot(tax_corr, aes(x = model, y = tax_cor)) +
  geom_pointrange(aes(ymin = tax_cor_lwr, ymax = tax_cor_upr)) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  facet_wrap(~trait) +
  labs(x = NULL, y = 'Correlation', title = 'Residual correlations for different models') +
  guides(color = F) +
  coord_flip() +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())
```






We can also explore taxonomic correlations among stages. We'll refit the model, but allowing an unstructured covariance structure for two of the taxonomic random effects: family and order. There was significant variance at these taxonomic levels, and there is enough replication within them to estimate covariances. To understand these covariances, we fit three models, each with host traits and worm stages: model 1) no taxonomic effects, 2) with taxonomic effects (fam by stage), 3) with taxonomic covariance. We also tweaked the random effect structure slightly. We swapped family and order for the combinations of family-stage and order-stage. This is easier to interpret. For example positive family-stage covariance between devo time and end size, suggests that when families are larger than expected at a given stage, they also develop longer.

```{r}
modx = list()
mody = list()
modz = list()

for(i in 1:100){
  iname <- ifelse(i < 10, paste0('00',i), 
                  ifelse(i < 100, paste0('0',i),i))
  fname_p <- paste0('../../data/imputed_stage_level_tables/stage_level_imputed',iname,'.csv')
  
  dat_imp <- read.csv(file = fname_p, header = T)
  
  dat_imp <- mutate(dat_imp, Host_no_fac = factor(Host_no_fac),
                obs = factor(1:length(Parasite.species)))%>%
    mutate(log_end = log(imp_biovolume), log_start = log(imp_initial_biov), 
           log_dt = log(imp_avg_dt), log_dd = log(imp_avg_dd),
           stage_lcl = paste0("lc", lcl_max_fac, "_", Host_no_fac))%>%
    mutate(rg = log_end - log_start, rgr = (log_end - log_start)/imp_avg_dt)%>%
    mutate(host_bm = log(10^(host_bm)))%>%
    mutate(gen_by_stage = paste0(parasite_genus, stage_lcl),
           fam_by_stage = paste0(parasite_family, stage_lcl),
           ord_by_stage = paste0(parasite_order, stage_lcl))

  # first filter to just data including fixed predictors
  dxyz_imp <- filter(dat_imp, !(is.na(imp_avg_dt) | is.na(imp_biovolume) | is.na(imp_initial_biov)))
  dxyz_imp <- filter(dxyz_imp, Facultative != 'postcyclic',
                !is.na(host_bm), !is.na(host_tl), !is.na(endo_ecto))
  dxyz_imp$pred <- 'no'
  
  
  # model with stage means and host traits
  # first model without tax ran eff
  modx[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                      trait:host_bm + trait:host_tl + trait:prop_endo +
                      trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo +
                      trait:stage_lcl, 
                            rcov = ~us(trait):units, # residual var-covar unstructured
                            nitt = 650, thin = 30, burnin = 500,
                            data = dxyz_imp,
                            family = c("gaussian", "gaussian", "gaussian"), pr=T, 
                            verbose = F)
  # second model with tax ran eff
  mody[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                      trait:host_bm + trait:host_tl + trait:prop_endo +
                      trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo +
                      trait:stage_lcl, 
                    random = ~ idh(trait):Parasite.species +
                     idh(trait):parasite_genus +
                     idh(trait):fam_by_stage + 
                     idh(trait):parasite_order + 
                     idh(trait):parasite_class + 
                     idh(trait):parasite_phylum, # taxonomic tree as random effect
                            rcov = ~us(trait):units, # residual var-covar unstructured
                            prior = prior,
                            start = startc,
                            nitt = 650, thin = 30, burnin = 500,
                            data = dxyz_imp,
                            family = c("gaussian", "gaussian", "gaussian"), pr=T, 
                            verbose = F)
  # third model with tax ran eff and tax cov
  modz[[i]] <- MCMCglmm(cbind(log_start, log_end, log_dt) ~ trait-1 + 
                      trait:host_bm + trait:host_tl + trait:prop_endo +
                      trait:host_bm:host_tl + trait:host_bm:prop_endo + trait:host_tl:prop_endo +
                      trait:stage_lcl, 
                    random = ~ idh(trait):Parasite.species +
                      idh(trait):parasite_genus +
                      us(trait):fam_by_stage + 
                      us(trait):ord_by_stage + 
                      idh(trait):parasite_class + 
                      idh(trait):parasite_phylum, # taxonomic tree as random effect
                    rcov = ~us(trait):units, # residual var-covar unstructured
                            prior = prior,
                            start = startc,
                            nitt = 650, thin = 30, burnin = 500,
                            data = dxyz_imp,
                            family = c("gaussian", "gaussian", "gaussian"), pr=T, 
                            verbose = F)



  # extract starting values for next iteration
  s <- round(runif(1, min = 1, max = dim(mody[[i]]$VCV)[1]),0)
  startc <- list(G = list(G1 = diag(round(mody[[i]]$VCV[s,1:3],6)),
                         G2 = diag(round(mody[[i]]$VCV[s,4:6],6)),
                         G3 = diag(round(mody[[i]]$VCV[s,7:9],6)),
                         G4 = diag(round(mody[[i]]$VCV[s,10:12],6)),
                         G5 = diag(round(mody[[i]]$VCV[s,13:15],6)),
                         G6 = diag(round(mody[[i]]$VCV[s,16:18],6))
                        ),
                R = matrix(round(mody[[i]]$VCV[s,19:27],6), nrow = 3, ncol = 3)
               )
  
  print(paste('iteration', i, 'finished'))
}
```

```{r}
# combine chains
mod_comb_solx <- runjags::combine.mcmc(mcmc.list(lapply(modx, function(x) {x$Sol})))
mod_comb_vcvx <- runjags::combine.mcmc(mcmc.list(lapply(modx, function(x) {x$VCV})))
mod_comb_soly <- runjags::combine.mcmc(mcmc.list(lapply(mody, function(x) {x$Sol})))
mod_comb_vcvy <- runjags::combine.mcmc(mcmc.list(lapply(mody, function(x) {x$VCV})))
mod_comb_solz <- runjags::combine.mcmc(mcmc.list(lapply(modz, function(x) {x$Sol})))
mod_comb_vcvz <- runjags::combine.mcmc(mcmc.list(lapply(modz, function(x) {x$VCV})))
```

Here is variance explained in the previous model...

```{r}
r2_multiv(chains3.2)
```

...and here is how much it goes up by letting family effects differ for each life stage.

```{r}
r2_multiv(mody)
# r2_multiv(modz) # similar
```
```{r}
# after post distributions extracted, reduce to just one model in list to save space
modx <- modx[[i]]
mody <- mody[[i]]
modz <- modz[[i]]
```


Since the family x stage effect is important, let's check which families grow more (or less) than expected at a given stage.

```{r}
# family random effects for each trait
fam_re <- which(grepl(".fam_by_stage.", colnames(mod_comb_soly)))
sx <- summary(mod_comb_soly[, fam_re])
sxx <- data.frame(sx$quantiles[,c(1,3,5)])
names(sxx) <- c("re_lwr", "re", "re_upr")
sxx$re_name <- row.names(sxx)

sxx <- sxx%>%mutate(trait = if_else(grepl("log_start", re_name), "log_start",
                             if_else(grepl("log_end", re_name), "log_end", "log_dt")),
             fam_stage = gsub("trait.*fam_by_stage.", "", re_name))

# family random effects for relative growth
fam_s <- which(grepl("traitlog_start.fam_by_stage.", colnames(mod_comb_soly)))
fam_e <- which(grepl("traitlog_end.fam_by_stage.", colnames(mod_comb_soly)))
sx <- summary(mod_comb_soly[, fam_e] - mod_comb_soly[, fam_s])
sxy <- data.frame(sx$quantiles[,c(1,3,5)])
names(sxy) <- c("re_lwr", "re", "re_upr")
sxy$re_name <- row.names(sxy)
sxy <- sxy%>%mutate(trait = "rg", fam_stage = gsub("trait.*fam_by_stage.", "", re_name))

sxx <- bind_rows(sxx, sxy)
sxx <- arrange(sxx, trait, re)
# sx_wide <- sxx%>%
#   pivot_wider(id = fam_stage, names_from=trait, values_from = re)
```

Here are the 15 combinations of family and stage that grow the most...

```{r}
filter(sxx, trait == "rg")%>%
  arrange(desc(re))%>%
  select(fam_stage, re_lwr, re, re_upr)%>%
  slice_head(n=15)
```

...and the least.

```{r}
filter(sxx, trait == "rg")%>%
  select(fam_stage, re_lwr, re, re_upr)%>%
  slice_head(n=15)
```

We make the same two tables for devo time. Here are the families that spend more time in the host than expected.

```{r}
filter(sxx, trait == "log_dt")%>%
  arrange(desc(re))%>%
  select(fam_stage, re_lwr, re, re_upr)%>%
  slice_head(n=15)
```

...and those that spend less time than expected. In general, the devo time random effects are more likely to overlap zero.

```{r}
filter(sxx, trait == "log_dt")%>%
  select(fam_stage, re_lwr, re, re_upr)%>%
  slice_head(n=15)
```

Our models estimate covariance among parasite starting size, ending size, and devo time at different levels (e.g. with and without taxonomy, among families, etc.). We calculate those correlations.

```{r}
x <- c("traitlog_start:traitlog_start.units", "traitlog_start:traitlog_end.units", 
       "traitlog_end:traitlog_start.units", "traitlog_end:traitlog_end.units")
sx <- summary(posterior.cor(mod_comb_vcvx[,colnames(mod_comb_vcvx) %in% x]))
sxx <- summary(posterior.cor(mod_comb_vcvy[,colnames(mod_comb_vcvy) %in% x]))
sy <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% x]))
syy <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% 
                                        gsub(x, pattern = "units", replacement = "fam_by_stage")]))
sz <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% 
                                        gsub(x, pattern = "units", replacement = "ord_by_stage")]))
dc1 <- data.frame(trait_cor = "ini_fin", 
           model = c("res, no tax", "res, tax", "res, tax2", "fam_cov", "ord_cov"),
           cor_lwr = c(sx$quantiles[2,1], sxx$quantiles[2,1], sy$quantiles[2,1], syy$quantiles[2,1], sz$quantiles[2,1]),
           cor = c(sx$quantiles[2,3], sxx$quantiles[2,3], sy$quantiles[2,3], syy$quantiles[2,3], sz$quantiles[2,3]),
           cor_upr = c(sx$quantiles[2,5], sxx$quantiles[2,5], sy$quantiles[2,5], syy$quantiles[2,5], sz$quantiles[2,5]))


x <- gsub(x, pattern = "log_end", replacement = "log_dt")
sx <- summary(posterior.cor(mod_comb_vcvx[,colnames(mod_comb_vcvx) %in% x]))
sxx <- summary(posterior.cor(mod_comb_vcvy[,colnames(mod_comb_vcvy) %in% x]))
sy <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% x]))
syy <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% 
                                        gsub(x, pattern = "units", replacement = "fam_by_stage")]))
sz <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% 
                                        gsub(x, pattern = "units", replacement = "ord_by_stage")]))
dc2 <- data.frame(trait_cor = "ini_dt", 
           model = c("res, no tax", "res, tax", "res, tax2", "fam_cov", "ord_cov"),
           cor_lwr = c(sx$quantiles[2,1], sxx$quantiles[2,1], sy$quantiles[2,1], syy$quantiles[2,1], sz$quantiles[2,1]),
           cor = c(sx$quantiles[2,3], sxx$quantiles[2,3], sy$quantiles[2,3], syy$quantiles[2,3], sz$quantiles[2,3]),
           cor_upr = c(sx$quantiles[2,5], sxx$quantiles[2,5], sy$quantiles[2,5], syy$quantiles[2,5], sz$quantiles[2,5]))

x <- gsub(x, pattern = "log_start", replacement = "log_end")
sx <- summary(posterior.cor(mod_comb_vcvx[,colnames(mod_comb_vcvx) %in% x]))
sxx <- summary(posterior.cor(mod_comb_vcvy[,colnames(mod_comb_vcvy) %in% x]))
sy <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% x]))
syy <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% 
                                        gsub(x, pattern = "units", replacement = "fam_by_stage")]))
sz <- summary(posterior.cor(mod_comb_vcvz[,colnames(mod_comb_vcvz) %in% 
                                        gsub(x, pattern = "units", replacement = "ord_by_stage")]))
dc3 <- data.frame(trait_cor = "dt_end", 
           model = c("res, no tax", "res, tax", "res, tax2", "fam_cov", "ord_cov"),
           cor_lwr = c(sx$quantiles[2,1], sxx$quantiles[2,1], sy$quantiles[2,1], syy$quantiles[2,1], sz$quantiles[2,1]),
           cor = c(sx$quantiles[2,3], sxx$quantiles[2,3], sy$quantiles[2,3], syy$quantiles[2,3], sz$quantiles[2,3]),
           cor_upr = c(sx$quantiles[2,5], sxx$quantiles[2,5], sy$quantiles[2,5], syy$quantiles[2,5], sz$quantiles[2,5]))

dc <- bind_rows(dc1, dc2, dc3)
rm(dc1, dc2, dc3, x, sx, sxx, sy, syy, sz)
dc <- dc%>%
  mutate(txt = paste0(round(cor, 2), " [", round(cor_lwr, 2), " to ",round(cor_upr, 2),"]"))
```

Since covariances were estimated in the models after accounting for host traits and stage identities, we extracted residuals from the models. Moreover, residual covariances were estimated with taxonomic effects (when taxonomy was not included in the model) or without them (when taxonomic random effects were included).

```{r}
# get residuals
l <- length(dxyz_imp$Parasite.species)
# multiv model without taxonomy, glm
p_stg <- predict.MCMCglmm(modx, # predictions from last imputation - should combine imputations, but would take a lot more code...
                          interval = "none")
p_stg <- data.frame(log_start_pred = p_stg[1:l,],
                log_end_pred = p_stg[(l+1):(l*2),],
                log_dt_pred = p_stg[(l*2+1):(l*3),]
                )

# multiv model with taxonomy, marginal residuals (no tax)
p_stg2 <- predict.MCMCglmm(mody,
                          interval = "none")
p_stg2 <- data.frame(log_start_pred2 = p_stg2[1:l,],
                log_end_pred2 = p_stg2[(l+1):(l*2),],
                log_dt_pred2 = p_stg2[(l*2+1):(l*3),]
                )

# multiv model with taxonomy, conditional residuals (yes tax)
p_stg3 <- predict.MCMCglmm(mody,
                          interval = "none",
                          marginal = NULL)
p_stg3 <- data.frame(log_start_pred3 = p_stg3[1:l,],
                log_end_pred3 = p_stg3[(l+1):(l*2),],
                log_dt_pred3 = p_stg3[(l*2+1):(l*3),]
                )

# multiv model with taxo cov, marginal residuals (no tax)
p_stg4 <- predict.MCMCglmm(modz,
                          interval = "none")
p_stg4 <- data.frame(log_start_pred4 = p_stg4[1:l,],
                log_end_pred4 = p_stg4[(l+1):(l*2),],
                log_dt_pred4 = p_stg4[(l*2+1):(l*3),]
                )

# multiv model with tax cov, conditional residuals (yes tax)
p_stg5 <- predict.MCMCglmm(modz,
                          interval = "none",
                          marginal = NULL)
p_stg5 <- data.frame(log_start_pred5 = p_stg5[1:l,],
                log_end_pred5 = p_stg5[(l+1):(l*2),],
                log_dt_pred5 = p_stg5[(l*2+1):(l*3),]
                )
dxy_p <- bind_cols(dxyz_imp, p_stg, p_stg2, p_stg3, p_stg4, p_stg5)%>%
  mutate(log_start_res_lm = log_start - log_start_pred,
         log_end_res_lm = log_end - log_end_pred,
         log_dt_res_lm = log_dt - log_dt_pred,
         log_start_res_notax1 = log_start - log_start_pred2,
         log_end_res_notax1 = log_end - log_end_pred2,
         log_dt_res_notax1 = log_dt - log_dt_pred2,
         log_start_res_tax1 = log_start - log_start_pred3,
         log_end_res_tax1 = log_end - log_end_pred3,
         log_dt_res_tax1 = log_dt - log_dt_pred3,
         log_start_res_notax2 = log_start - log_start_pred4,
         log_end_res_notax2 = log_end - log_end_pred4,
         log_dt_res_notax2 = log_dt - log_dt_pred4,
         log_start_res_tax2 = log_start - log_start_pred5,
         log_end_res_tax2 = log_end - log_end_pred5,
         log_dt_res_tax2 = log_dt - log_dt_pred5
         )
# no tax resid from different models tightly correlated, same for tax resid
```

To visualize covariances, we calculate confidence ellipses. The width of the ellipses represent variance, whereas the tilt represents covariance.

```{r}
# function to calculate CI ellipse
ci_ellipse <- function(cm, meanx, meany){ # take in 2x2 cov matrix, return 95% CI ellipsoid
  
  eigVal  <- eigen(cm)$values
  eigVec  <- eigen(cm)$vectors
  eigScl  <- eigVec %*% diag(sqrt(eigVal))  # scale eigenvectors to length = square-root
  angles <- seq(0, 2*pi, length.out = 300)
  ellBase <- cbind(sqrt(eigVal[1])*cos(angles), sqrt(eigVal[2])*sin(angles)) # normal ellipse
  xcrs <- which(ellBase[,1] == max(ellBase[,1]) | ellBase[,1] == min(ellBase[,1])) # id major axis
  ycrs <- which(ellBase[,2] == max(ellBase[,2]) | ellBase[,2] == min(ellBase[,2])) # id minor axis
  ellRot  <- eigVec %*% t(ellBase) # rotated ellipse
  ellRot <- data.frame(t(ellRot))
  ellRot <- cbind(angles, ellRot)
  names(ellRot) <- c("angles", "x", "y")
  ellRot <- mutate(ellRot, x = x + meanx, y = y + meany)
  ellRot$axes[xcrs] <- "major"
  ellRot$axes[ycrs] <- "minor"
  
  return(ellRot) # dataframe for ellipse
}

# function to extract cov matrixes from post dist
post_cov_matrices_df <- function(mod1, trait1, trait2, cv_level1, num_ps){
  
  ps <- sample(1:length(mod1[,1]), size = num_ps) # random posterior samples
  
  # trait names for extracting cov matrix from post dist
  v1x <- paste0("trait",trait1,":","trait",trait1,cv_level1)
  v2x <- paste0("trait",trait2,":","trait",trait2,cv_level1)
  cv12x <- paste0("trait",trait1,":","trait",trait2,cv_level1)
  cv21x <- paste0("trait",trait2,":","trait",trait1,cv_level1)

  # loop around to take sample
  for(i in ps){
    ell_i <- ci_ellipse(
      cm = matrix(6 * (mod1[i, c(v1x, cv12x, cv21x, v2x)]), 2,2),
      meanx = 0, #mod1$Sol[i, paste0("trait",trait1)]
      meany = 0 #mod1$Sol[i, paste0("trait",trait2)]
  )
    ell_i$p_samp <- as.character(i)
    if(i == ps[1]){
      ell_many <- ell_i
    } else {
      ell_many <- bind_rows(ell_many, ell_i)
    }
  }
  
  return(ell_many)

}
```


```{r}
# cov matrices from glm
ell_s_e <- post_cov_matrices_df(mod_comb_vcvx, "log_start", "log_end", ".units", 20)
ell_s_d <- post_cov_matrices_df(mod_comb_vcvx, "log_start", "log_dt", ".units", 20)
ell_d_e <- post_cov_matrices_df(mod_comb_vcvx, "log_dt", "log_end", ".units", 20)

# cov matrices from tax model
ell_s_e2 <- post_cov_matrices_df(mod_comb_vcvy, "log_start", "log_end", ".units", 20)
ell_s_d2 <- post_cov_matrices_df(mod_comb_vcvy, "log_start", "log_dt", ".units", 20)
ell_d_e2 <- post_cov_matrices_df(mod_comb_vcvy, "log_dt", "log_end", ".units", 20)

# cov matrices from tax model
ell_s_e3 <- post_cov_matrices_df(mod_comb_vcvz, "log_start", "log_end", ".units", 20)
ell_s_d3 <- post_cov_matrices_df(mod_comb_vcvz, "log_start", "log_dt", ".units", 20)
ell_d_e3 <- post_cov_matrices_df(mod_comb_vcvz, "log_dt", "log_end", ".units", 20)

# cov matrices from tax model
ell_s_e4 <- post_cov_matrices_df(mod_comb_vcvz, "log_start", "log_end", ".fam_by_stage", 20)
ell_s_d4 <- post_cov_matrices_df(mod_comb_vcvz, "log_start", "log_dt", ".fam_by_stage", 20)
ell_d_e4 <- post_cov_matrices_df(mod_comb_vcvz, "log_dt", "log_end", ".fam_by_stage", 20)

# cov matrices from tax model
ell_s_e5 <- post_cov_matrices_df(mod_comb_vcvz, "log_start", "log_end", ".ord_by_stage", 20)
ell_s_d5 <- post_cov_matrices_df(mod_comb_vcvz, "log_start", "log_dt", ".ord_by_stage", 20)
ell_d_e5 <- post_cov_matrices_df(mod_comb_vcvz, "log_dt", "log_end", ".ord_by_stage", 20)
```

```{r}
dp1 <- dxy_p%>%
  select(Parasite.species, stage_lcl, fam_by_stage, ord_by_stage, starts_with("log_start_res"))%>%
  pivot_longer(starts_with("log_start_res"), names_to = "model", values_to = "log_start_res")%>%
  mutate(model = gsub(x = model, pattern = "log_start_", replacement = ""))
dp2 <- dxy_p%>%
  select(starts_with("log_end_res"))%>%
  pivot_longer(starts_with("log_end_res"), names_to = "model", values_to = "log_end_res")%>%
  select(-model)
dp3 <- dxy_p%>%
  select(starts_with("log_dt_res"))%>%
  pivot_longer(starts_with("log_dt_res"), names_to = "model", values_to = "log_dt_res")%>%
  select(-model)
dp <- bind_cols(dp1, dp2, dp3)
dp <- mutate(dp, n = 1)

dp4 <- dp%>%
  filter(model == "res_notax2")%>%
  group_by(fam_by_stage)%>%
  summarize(n = n(),
            log_start_res = mean(log_start_res, na.rm = T),
            log_end_res = mean(log_end_res, na.rm = T),
            log_dt_res = mean(log_dt_res, na.rm = T))%>%
  ungroup()%>%
  mutate(model = "marg_fam")

dp5 <- dp%>%
  filter(model == "res_notax2")%>%
  group_by(ord_by_stage)%>%
  summarize(n = n(),
            log_start_res = mean(log_start_res, na.rm = T),
            log_end_res = mean(log_end_res, na.rm = T),
            log_dt_res = mean(log_dt_res, na.rm = T))%>%
  ungroup()%>%
  mutate(model = "marg_ord")

dp <- bind_rows(dp, dp4, dp5)
dp <- dp%>%
  mutate(model = fct_relevel(model, c("res_lm", "res_notax1", "res_notax2", "marg_ord", "marg_fam", "res_tax1", "res_tax2")))
rm(dp1, dp2, dp3, dp4, dp5)
```
We plot the covariances for each of the three trait correlations. And we plot four covariances: without taxonomic effects (marginal residuals), with taxonomic effects (conditional residuals), and at the order and family levels.

We start with the starting and end size correlation. Overall, worms that enter a host relatively large grow to be relatively large (a positive covariance). This is at least partially driven by order-level differences and therefore reflect differences in body plans between parasites. Interestingly, once we exclude taxonomy, we get negative covariance (conditional residuals). This suggests that worms that enter the host big, tend to grow less than we would expect given their host size, their own taxonomy, etc.
```{r}
pal <- RColorBrewer::brewer.pal(4, name = "Set1")
```

```{r}
fe3a <- ggplot(dp%>%
         filter(model %in% c("res_notax2", "res_tax2", "marg_fam", "marg_ord")),
       aes(x = log_start_res, y = log_end_res)) +
  geom_hline(yintercept = 0, linetype = "dashed") + geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(color = model, size = n),
             alpha = 0.2) +
  scale_color_manual(values = pal,
                     labels = c("Marginal residuals",
                                "Marginal residuals,\norder averages",
                                "Marginal residuals,\nfamily averages",
                                "Conditional residuals")
                     ) +
  geom_path(data = arrange(ell_s_e,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[1]) +
  geom_path(data = arrange(ell_s_e3,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[4]) +
  geom_path(data = arrange(ell_s_e4,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[3]) +
  geom_path(data = arrange(ell_s_e5,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[2]) +
  guides(size = F) +
  labs(x = "Residuals, initial size", y = "Residuals, final size", color = NULL) +
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = filter(dc, trait_cor == "ini_fin", model == "res, no tax")$txt,
           x = 10, y = -5, color = pal[1], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_fin", model == "ord_cov")$txt,
           x = 10, y = -6, color = pal[2], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_fin", model == "fam_cov")$txt,
           x = 10, y = -7, color = pal[3], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_fin", model == "res, tax2")$txt,
           x = 10, y = -8, color = pal[4], size = 2)
fe3a
```
Next, find the expected negative covariance between starting size and developmental time. This also seems to be driven by deep (order-level) phylogenetic differences.

```{r}
fe3b <- ggplot(dp%>%
         filter(model %in% c("res_notax2", "res_tax2", "marg_fam", "marg_ord")),
       aes(x = log_start_res, y = log_dt_res)) +
  geom_hline(yintercept = 0, linetype = "dashed") + geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(color = model, size = n),
             alpha = 0.2) +
  scale_color_manual(values = pal, 
                     labels = c("Marginal residuals",
                                "Marginal residuals,\norder averages",
                                "Marginal residuals,\nfamily averages",
                                "Conditional residuals")
                     ) +
  geom_path(data = arrange(ell_s_d,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[1]) +
  geom_path(data = arrange(ell_s_d3,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[4]) +
  geom_path(data = arrange(ell_s_d4,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[3]) +
  geom_path(data = arrange(ell_s_d5,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[2]) +
  guides(size = F,
         color = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = "Residuals, initial size", y = "Residuals, devo time", color = NULL) +
  theme(panel.grid.minor = element_blank(),
        legend.background = element_rect(color = "black")) +
  annotate("text", label = filter(dc, trait_cor == "ini_dt", model == "res, no tax")$txt,
           x = -4, y = -2.2, color = pal[1], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_dt", model == "ord_cov")$txt,
           x = -4, y = -2.5, color = pal[2], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_dt", model == "fam_cov")$txt,
           x = -4, y = -2.8, color = pal[3], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "ini_dt", model == "res, tax2")$txt,
           x = -4, y = -3.1, color = pal[4], size = 2) 
fe3b
```
Finally, there is a positive correlation between final size and devo time, as expected. This may be driven more by lower-level stages.

```{r}
fe3c <- ggplot(dp%>%
         filter(model %in% c("res_notax2", "res_tax2", "marg_fam", "marg_ord")),
       aes(x = log_dt_res, y = log_end_res)) +
  geom_hline(yintercept = 0, linetype = "dashed") + geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(color = model, size = n),
             alpha = 0.2) +
  scale_color_manual(values = pal, 
                     labels = c("Marginal residuals",
                                "Marginal residuals,\norder averages",
                                "Marginal residuals,\nfamily averages",
                                "Conditional residuals")
                     ) +
  geom_path(data = arrange(ell_d_e,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[1]) +
  geom_path(data = arrange(ell_d_e3,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[4]) +
  geom_path(data = arrange(ell_d_e4,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[3]) +
  geom_path(data = arrange(ell_d_e5,p_samp,angles),
              aes(x = x, y = y, group = p_samp),
              alpha = 0.25, color = pal[2]) +
  guides(size = F,
         color = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = "Residuals, initial size", y = "Residuals, devo time", color = NULL) +
  theme(panel.grid.minor = element_blank(),
        legend.background = element_rect(color = "black")) +
  labs(x = "Residuals, devo time", y = "Residuals, final size", color = NULL) +
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = filter(dc, trait_cor == "dt_end", model == "res, no tax")$txt,
           x = -2, y = 10, color = pal[1], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "dt_end", model == "ord_cov")$txt,
           x = -2, y = 8.5, color = pal[2], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "dt_end", model == "fam_cov")$txt,
           x = -2, y = 9, color = pal[3], size = 2) +
  annotate("text", label = filter(dc, trait_cor == "dt_end", model == "res, tax2")$txt,
           x = -2, y = 8, color = pal[4], size = 2)
fe3c
```




```{r}
save.image(file = "after_multi_models.RData")
```
